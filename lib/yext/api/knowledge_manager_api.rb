=begin
#Yext API

#No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 2.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.0.0

=end

require 'cgi'

module Yext
  class KnowledgeManagerApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Assets: Create
    # Creates a new asset in an account.  **NOTE:** * If the **`v`** parameter is on or before `20190624`: only the first folder the Asset is available for will be returned in the legacy **`folderId`** field. * If the **`v`** parameter is after `20190624`: the complete list of folders the Asset is available to will be returned in the new **`folderIds`** field. **`folderId`** will not be returned. 
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param format [String] The formatting langauge used to parse rich text field values. Present if and only if type of field is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60; 
    # @param asset [Asset] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def create_asset(account_id, v, format, asset, opts = {})
      data, _status_code, _headers = create_asset_with_http_info(account_id, v, format, asset, opts)
      data
    end

    # Assets: Create
    # Creates a new asset in an account.  **NOTE:** * If the **&#x60;v&#x60;** parameter is on or before &#x60;20190624&#x60;: only the first folder the Asset is available for will be returned in the legacy **&#x60;folderId&#x60;** field. * If the **&#x60;v&#x60;** parameter is after &#x60;20190624&#x60;: the complete list of folders the Asset is available to will be returned in the new **&#x60;folderIds&#x60;** field. **&#x60;folderId&#x60;** will not be returned. 
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param format [String] The formatting langauge used to parse rich text field values. Present if and only if type of field is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60; 
    # @param asset [Asset] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def create_asset_with_http_info(account_id, v, format, asset, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.create_asset ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.create_asset"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.create_asset"
      end
      # verify the required parameter 'format' is set
      if @api_client.config.client_side_validation && format.nil?
        fail ArgumentError, "Missing the required parameter 'format' when calling KnowledgeManagerApi.create_asset"
      end
      if @api_client.config.client_side_validation && format.to_s.length < 0
        fail ArgumentError, 'invalid value for "format" when calling KnowledgeManagerApi.create_asset, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'asset' is set
      if @api_client.config.client_side_validation && asset.nil?
        fail ArgumentError, "Missing the required parameter 'asset' when calling KnowledgeManagerApi.create_asset"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/assets'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'format'] = format

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(asset)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.create_asset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#create_asset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Bios: Create
    # Create new Bio List.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param bio [Bio] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def create_bio(account_id, v, bio, opts = {})
      data, _status_code, _headers = create_bio_with_http_info(account_id, v, bio, opts)
      data
    end

    # Bios: Create
    # Create new Bio List.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param bio [Bio] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def create_bio_with_http_info(account_id, v, bio, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.create_bio ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.create_bio"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.create_bio"
      end
      # verify the required parameter 'bio' is set
      if @api_client.config.client_side_validation && bio.nil?
        fail ArgumentError, "Missing the required parameter 'bio' when calling KnowledgeManagerApi.create_bio"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/bios'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/kjson'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(bio)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.create_bio",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#create_bio\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Custom Fields: Create
    # Creates a new Custom Field in an Account. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param field [Field] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def create_custom_field(v, account_id, field, opts = {})
      data, _status_code, _headers = create_custom_field_with_http_info(v, account_id, field, opts)
      data
    end

    # Custom Fields: Create
    # Creates a new Custom Field in an Account. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param field [Field] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def create_custom_field_with_http_info(v, account_id, field, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.create_custom_field ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.create_custom_field"
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.create_custom_field"
      end
      # verify the required parameter 'field' is set
      if @api_client.config.client_side_validation && field.nil?
        fail ArgumentError, "Missing the required parameter 'field' when calling KnowledgeManagerApi.create_custom_field"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/customfields'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(field)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.create_custom_field",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#create_custom_field\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entities: Create
    # Create a new Entity  **NOTE:**   * If the **`v`** parameter is before `20181129`: the 201 response contains the created Entity's **`id`**   * If the **`v`** parameter is on or after `20181129`: the 201 response contains the created Entity in its entirety 
    # @param account_id [String] 
    # @param entity_type [String] The type of entity to be created. Should be one of the following:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param entity_write [EntityWrite] The entity to be created
    # @param [Hash] opts the optional parameters
    # @option opts [String] :format The formatting language used to parse rich text field values. Present and **required** if an only if the request contains a field with type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;  (default to 'markdown')
    # @option opts [Boolean] :strip_unsupported_formats Optional parameter to strip unsupported formats in rich text fields. When this parameter is included, the unsupported formats in rich text fields will be stripped and saved as plain text; otherwise if this parameter is not included, unsupported formats will return an error. 
    # @option opts [String] :template_fields Comma-separated list of top-level fields to apply from the template. If provided, only the fields specified will be applied to the entity.  Ignored if **&#x60;templateId&#x60;** is not provided. 
    # @option opts [String] :template_id The ID of the template to apply to the entity  **NOTE:** Some fields that are part of the provided template but not present in the API will be applied - e.g. Linked Accounts 
    # @return [CreateEntity201Response]
    def create_entity(account_id, entity_type, v, entity_write, opts = {})
      data, _status_code, _headers = create_entity_with_http_info(account_id, entity_type, v, entity_write, opts)
      data
    end

    # Entities: Create
    # Create a new Entity  **NOTE:**   * If the **&#x60;v&#x60;** parameter is before &#x60;20181129&#x60;: the 201 response contains the created Entity&#39;s **&#x60;id&#x60;**   * If the **&#x60;v&#x60;** parameter is on or after &#x60;20181129&#x60;: the 201 response contains the created Entity in its entirety 
    # @param account_id [String] 
    # @param entity_type [String] The type of entity to be created. Should be one of the following:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param entity_write [EntityWrite] The entity to be created
    # @param [Hash] opts the optional parameters
    # @option opts [String] :format The formatting language used to parse rich text field values. Present and **required** if an only if the request contains a field with type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;  (default to 'markdown')
    # @option opts [Boolean] :strip_unsupported_formats Optional parameter to strip unsupported formats in rich text fields. When this parameter is included, the unsupported formats in rich text fields will be stripped and saved as plain text; otherwise if this parameter is not included, unsupported formats will return an error. 
    # @option opts [String] :template_fields Comma-separated list of top-level fields to apply from the template. If provided, only the fields specified will be applied to the entity.  Ignored if **&#x60;templateId&#x60;** is not provided. 
    # @option opts [String] :template_id The ID of the template to apply to the entity  **NOTE:** Some fields that are part of the provided template but not present in the API will be applied - e.g. Linked Accounts 
    # @return [Array<(CreateEntity201Response, Integer, Hash)>] CreateEntity201Response data, response status code and response headers
    def create_entity_with_http_info(account_id, entity_type, v, entity_write, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.create_entity ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.create_entity"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.create_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_type' is set
      if @api_client.config.client_side_validation && entity_type.nil?
        fail ArgumentError, "Missing the required parameter 'entity_type' when calling KnowledgeManagerApi.create_entity"
      end
      if @api_client.config.client_side_validation && entity_type.to_s.length < 0
        fail ArgumentError, 'invalid value for "entity_type" when calling KnowledgeManagerApi.create_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.create_entity"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.create_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_write' is set
      if @api_client.config.client_side_validation && entity_write.nil?
        fail ArgumentError, "Missing the required parameter 'entity_write' when calling KnowledgeManagerApi.create_entity"
      end
      if @api_client.config.client_side_validation && !opts[:'format'].nil? && opts[:'format'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"format"]" when calling KnowledgeManagerApi.create_entity, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'template_fields'].nil? && opts[:'template_fields'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"template_fields"]" when calling KnowledgeManagerApi.create_entity, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'template_id'].nil? && opts[:'template_id'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"template_id"]" when calling KnowledgeManagerApi.create_entity, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entities'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'entityType'] = entity_type
      query_params[:'v'] = v
      query_params[:'format'] = opts[:'format'] if !opts[:'format'].nil?
      query_params[:'stripUnsupportedFormats'] = opts[:'strip_unsupported_formats'] if !opts[:'strip_unsupported_formats'].nil?
      query_params[:'templateFields'] = opts[:'template_fields'] if !opts[:'template_fields'].nil?
      query_params[:'templateId'] = opts[:'template_id'] if !opts[:'template_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(entity_write)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateEntity201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.create_entity",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#create_entity\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Events (Legacy): Create
    # Create a new Event List.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param event [Event] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def create_event(account_id, v, event, opts = {})
      data, _status_code, _headers = create_event_with_http_info(account_id, v, event, opts)
      data
    end

    # Events (Legacy): Create
    # Create a new Event List.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param event [Event] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def create_event_with_http_info(account_id, v, event, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.create_event ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.create_event"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.create_event"
      end
      # verify the required parameter 'event' is set
      if @api_client.config.client_side_validation && event.nil?
        fail ArgumentError, "Missing the required parameter 'event' when calling KnowledgeManagerApi.create_event"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/events'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/kjson'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(event)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.create_event",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#create_event\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Locations (Legacy): Create
    # Create a new Location.   ## Required fields * **`locationName`** * **`address`** * **`city`** * **`state`** * **`zip`**   ## Optional fields that trigger warnings Submitting invalid values for certain optional fields will not trigger an error response. Instead, the success response will contain warning messages explaining why the invalid optional values were not stored in the system. The fields that generate warning messages are: <br><br> * **`logo`** * **`photos`** * **`twitterHandle`** * **`facebookPageUrl`** * **`languages`** 
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param location [Location] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def create_location(account_id, v, location, opts = {})
      data, _status_code, _headers = create_location_with_http_info(account_id, v, location, opts)
      data
    end

    # Locations (Legacy): Create
    # Create a new Location.   ## Required fields * **&#x60;locationName&#x60;** * **&#x60;address&#x60;** * **&#x60;city&#x60;** * **&#x60;state&#x60;** * **&#x60;zip&#x60;**   ## Optional fields that trigger warnings Submitting invalid values for certain optional fields will not trigger an error response. Instead, the success response will contain warning messages explaining why the invalid optional values were not stored in the system. The fields that generate warning messages are: &lt;br&gt;&lt;br&gt; * **&#x60;logo&#x60;** * **&#x60;photos&#x60;** * **&#x60;twitterHandle&#x60;** * **&#x60;facebookPageUrl&#x60;** * **&#x60;languages&#x60;** 
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param location [Location] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def create_location_with_http_info(account_id, v, location, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.create_location ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.create_location"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.create_location"
      end
      # verify the required parameter 'location' is set
      if @api_client.config.client_side_validation && location.nil?
        fail ArgumentError, "Missing the required parameter 'location' when calling KnowledgeManagerApi.create_location"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/locations'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(location)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.create_location",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#create_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Menus: Create
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param menu [Menu] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def create_menu(account_id, v, menu, opts = {})
      data, _status_code, _headers = create_menu_with_http_info(account_id, v, menu, opts)
      data
    end

    # Menus: Create
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param menu [Menu] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def create_menu_with_http_info(account_id, v, menu, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.create_menu ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.create_menu"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.create_menu"
      end
      # verify the required parameter 'menu' is set
      if @api_client.config.client_side_validation && menu.nil?
        fail ArgumentError, "Missing the required parameter 'menu' when calling KnowledgeManagerApi.create_menu"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/menus'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(menu)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.create_menu",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#create_menu\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Products: Create
    # Create a new Product List.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param product [Product] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def create_product(account_id, v, product, opts = {})
      data, _status_code, _headers = create_product_with_http_info(account_id, v, product, opts)
      data
    end

    # Products: Create
    # Create a new Product List.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param product [Product] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def create_product_with_http_info(account_id, v, product, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.create_product ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.create_product"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.create_product"
      end
      # verify the required parameter 'product' is set
      if @api_client.config.client_side_validation && product.nil?
        fail ArgumentError, "Missing the required parameter 'product' when calling KnowledgeManagerApi.create_product"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/products'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/kjson'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.create_product",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#create_product\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Assets: Delete
    # Delete a specific asset.
    # @param account_id [String] 
    # @param asset_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [EmptyResponse]
    def delete_asset(account_id, asset_id, v, opts = {})
      data, _status_code, _headers = delete_asset_with_http_info(account_id, asset_id, v, opts)
      data
    end

    # Assets: Delete
    # Delete a specific asset.
    # @param account_id [String] 
    # @param asset_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(EmptyResponse, Integer, Hash)>] EmptyResponse data, response status code and response headers
    def delete_asset_with_http_info(account_id, asset_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_asset ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_asset"
      end
      # verify the required parameter 'asset_id' is set
      if @api_client.config.client_side_validation && asset_id.nil?
        fail ArgumentError, "Missing the required parameter 'asset_id' when calling KnowledgeManagerApi.delete_asset"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_asset"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/assets/{assetId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'assetId' + '}', CGI.escape(asset_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EmptyResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_asset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_asset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Bios: Delete
    # Delete an existing Bios List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [EmptyResponse]
    def delete_bio_list(account_id, list_id, v, opts = {})
      data, _status_code, _headers = delete_bio_list_with_http_info(account_id, list_id, v, opts)
      data
    end

    # Bios: Delete
    # Delete an existing Bios List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(EmptyResponse, Integer, Hash)>] EmptyResponse data, response status code and response headers
    def delete_bio_list_with_http_info(account_id, list_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_bio_list ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_bio_list"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.delete_bio_list"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_bio_list"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/bios/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EmptyResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_bio_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_bio_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Custom Fields: Delete
    # Deletes a Custom Field in an Account.  The Custom Field will be removed from all locations, and all content entered in the Custom Field will be deleted permanently. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param custom_field_id [String] ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
    # @param [Hash] opts the optional parameters
    # @return [EmptyResponse]
    def delete_custom_field(v, account_id, custom_field_id, opts = {})
      data, _status_code, _headers = delete_custom_field_with_http_info(v, account_id, custom_field_id, opts)
      data
    end

    # Custom Fields: Delete
    # Deletes a Custom Field in an Account.  The Custom Field will be removed from all locations, and all content entered in the Custom Field will be deleted permanently. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param custom_field_id [String] ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
    # @param [Hash] opts the optional parameters
    # @return [Array<(EmptyResponse, Integer, Hash)>] EmptyResponse data, response status code and response headers
    def delete_custom_field_with_http_info(v, account_id, custom_field_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_custom_field ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_custom_field"
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_custom_field"
      end
      # verify the required parameter 'custom_field_id' is set
      if @api_client.config.client_side_validation && custom_field_id.nil?
        fail ArgumentError, "Missing the required parameter 'custom_field_id' when calling KnowledgeManagerApi.delete_custom_field"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/customfields/{customFieldId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'customFieldId' + '}', CGI.escape(custom_field_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EmptyResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_custom_field",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_custom_field\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entities: Delete
    # Delete the Entity with the given ID
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [DeleteEntity200Response]
    def delete_entity(account_id, entity_id, v, opts = {})
      data, _status_code, _headers = delete_entity_with_http_info(account_id, entity_id, v, opts)
      data
    end

    # Entities: Delete
    # Delete the Entity with the given ID
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeleteEntity200Response, Integer, Hash)>] DeleteEntity200Response data, response status code and response headers
    def delete_entity_with_http_info(account_id, entity_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_entity ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_entity"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.delete_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_id' is set
      if @api_client.config.client_side_validation && entity_id.nil?
        fail ArgumentError, "Missing the required parameter 'entity_id' when calling KnowledgeManagerApi.delete_entity"
      end
      if @api_client.config.client_side_validation && entity_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "entity_id" when calling KnowledgeManagerApi.delete_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_entity"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.delete_entity, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entities/{entityId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'entityId' + '}', CGI.escape(entity_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeleteEntity200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_entity",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_entity\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Events (Legacy): Delete
    # Delete an existing Event List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [EmptyResponse]
    def delete_event_list(account_id, list_id, v, opts = {})
      data, _status_code, _headers = delete_event_list_with_http_info(account_id, list_id, v, opts)
      data
    end

    # Events (Legacy): Delete
    # Delete an existing Event List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(EmptyResponse, Integer, Hash)>] EmptyResponse data, response status code and response headers
    def delete_event_list_with_http_info(account_id, list_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_event_list ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_event_list"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.delete_event_list"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_event_list"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/events/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EmptyResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_event_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_event_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entity Language Profiles: Delete
    # Delete a language profile
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param language_code [String] The language code corresponding to the language of the profile that the user wishes to delete
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [DeleteLanguageProfile200Response]
    def delete_language_profile(account_id, entity_id, language_code, v, opts = {})
      data, _status_code, _headers = delete_language_profile_with_http_info(account_id, entity_id, language_code, v, opts)
      data
    end

    # Entity Language Profiles: Delete
    # Delete a language profile
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param language_code [String] The language code corresponding to the language of the profile that the user wishes to delete
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeleteLanguageProfile200Response, Integer, Hash)>] DeleteLanguageProfile200Response data, response status code and response headers
    def delete_language_profile_with_http_info(account_id, entity_id, language_code, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_language_profile ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_language_profile"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.delete_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_id' is set
      if @api_client.config.client_side_validation && entity_id.nil?
        fail ArgumentError, "Missing the required parameter 'entity_id' when calling KnowledgeManagerApi.delete_language_profile"
      end
      if @api_client.config.client_side_validation && entity_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "entity_id" when calling KnowledgeManagerApi.delete_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'language_code' is set
      if @api_client.config.client_side_validation && language_code.nil?
        fail ArgumentError, "Missing the required parameter 'language_code' when calling KnowledgeManagerApi.delete_language_profile"
      end
      if @api_client.config.client_side_validation && language_code.to_s.length < 0
        fail ArgumentError, 'invalid value for "language_code" when calling KnowledgeManagerApi.delete_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_language_profile"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.delete_language_profile, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entityprofiles/{entityId}/{languageCode}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'entityId' + '}', CGI.escape(entity_id.to_s)).sub('{' + 'languageCode' + '}', CGI.escape(language_code.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeleteLanguageProfile200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_language_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_language_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Language Profiles (Legacy): Delete
    # Remove a Language Profile from a location.
    # @param account_id [String] 
    # @param location_id [String] 
    # @param language_code [String] Locale code.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [EmptyResponse]
    def delete_location_language_profile(account_id, location_id, language_code, v, opts = {})
      data, _status_code, _headers = delete_location_language_profile_with_http_info(account_id, location_id, language_code, v, opts)
      data
    end

    # Language Profiles (Legacy): Delete
    # Remove a Language Profile from a location.
    # @param account_id [String] 
    # @param location_id [String] 
    # @param language_code [String] Locale code.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(EmptyResponse, Integer, Hash)>] EmptyResponse data, response status code and response headers
    def delete_location_language_profile_with_http_info(account_id, location_id, language_code, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_location_language_profile ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_location_language_profile"
      end
      # verify the required parameter 'location_id' is set
      if @api_client.config.client_side_validation && location_id.nil?
        fail ArgumentError, "Missing the required parameter 'location_id' when calling KnowledgeManagerApi.delete_location_language_profile"
      end
      # verify the required parameter 'language_code' is set
      if @api_client.config.client_side_validation && language_code.nil?
        fail ArgumentError, "Missing the required parameter 'language_code' when calling KnowledgeManagerApi.delete_location_language_profile"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_location_language_profile"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/locations/{locationId}/profiles/{language_code}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'locationId' + '}', CGI.escape(location_id.to_s)).sub('{' + 'language_code' + '}', CGI.escape(language_code.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EmptyResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_location_language_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_location_language_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Menus: Delete
    # Delete an existing Menu.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [EmptyResponse]
    def delete_menu_list(account_id, list_id, v, opts = {})
      data, _status_code, _headers = delete_menu_list_with_http_info(account_id, list_id, v, opts)
      data
    end

    # Menus: Delete
    # Delete an existing Menu.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(EmptyResponse, Integer, Hash)>] EmptyResponse data, response status code and response headers
    def delete_menu_list_with_http_info(account_id, list_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_menu_list ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_menu_list"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.delete_menu_list"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_menu_list"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/menus/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EmptyResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_menu_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_menu_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Products: Delete
    # Delete an existing Products List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [EmptyResponse]
    def delete_product_list(account_id, list_id, v, opts = {})
      data, _status_code, _headers = delete_product_list_with_http_info(account_id, list_id, v, opts)
      data
    end

    # Products: Delete
    # Delete an existing Products List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(EmptyResponse, Integer, Hash)>] EmptyResponse data, response status code and response headers
    def delete_product_list_with_http_info(account_id, list_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.delete_product_list ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.delete_product_list"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.delete_product_list"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.delete_product_list"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/products/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EmptyResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.delete_product_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#delete_product_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Assets: Get
    # Get a specific asset.
    # @param account_id [String] 
    # @param asset_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param format [String] Present if and only if type of subfield is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
    # @param [Hash] opts the optional parameters
    # @return [AssetResponse]
    def get_asset(account_id, asset_id, v, format, opts = {})
      data, _status_code, _headers = get_asset_with_http_info(account_id, asset_id, v, format, opts)
      data
    end

    # Assets: Get
    # Get a specific asset.
    # @param account_id [String] 
    # @param asset_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param format [String] Present if and only if type of subfield is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AssetResponse, Integer, Hash)>] AssetResponse data, response status code and response headers
    def get_asset_with_http_info(account_id, asset_id, v, format, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_asset ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_asset"
      end
      # verify the required parameter 'asset_id' is set
      if @api_client.config.client_side_validation && asset_id.nil?
        fail ArgumentError, "Missing the required parameter 'asset_id' when calling KnowledgeManagerApi.get_asset"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_asset"
      end
      # verify the required parameter 'format' is set
      if @api_client.config.client_side_validation && format.nil?
        fail ArgumentError, "Missing the required parameter 'format' when calling KnowledgeManagerApi.get_asset"
      end
      if @api_client.config.client_side_validation && format.to_s.length < 0
        fail ArgumentError, 'invalid value for "format" when calling KnowledgeManagerApi.get_asset, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/assets/{assetId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'assetId' + '}', CGI.escape(asset_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'format'] = format

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'AssetResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_asset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_asset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Bios: Get
    # Retrieve a specific Bios List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [BioListResponse]
    def get_bio(account_id, list_id, v, opts = {})
      data, _status_code, _headers = get_bio_with_http_info(account_id, list_id, v, opts)
      data
    end

    # Bios: Get
    # Retrieve a specific Bios List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(BioListResponse, Integer, Hash)>] BioListResponse data, response status code and response headers
    def get_bio_with_http_info(account_id, list_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_bio ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_bio"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.get_bio"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_bio"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/bios/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'BioListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_bio",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_bio\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Bios: List
    # Retrieve all Bio Lists for an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @return [BioListsResponse]
    def get_bios(account_id, v, opts = {})
      data, _status_code, _headers = get_bios_with_http_info(account_id, v, opts)
      data
    end

    # Bios: List
    # Retrieve all Bio Lists for an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @return [Array<(BioListsResponse, Integer, Hash)>] BioListsResponse data, response status code and response headers
    def get_bios_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_bios ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_bios"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_bios"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.get_bios, must be smaller than or equal to 50.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/bios'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'BioListsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_bios",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_bios\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Categories: List
    # Get available Categories.  All Locations are required to have an associated Category to assist with organization and search. Yext provides a hierarchy of business categories for this purpose, exposed by this API. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :language Only categories that apply to this language will be returned.  Valid values: ISO 639-1 language codes  **Example:** en 
    # @option opts [String] :country Only categories that apply in this country will be returned.  Valid values: ISO 3166-1 alpha-2 country codes  **Example:** US 
    # @option opts [String] :entity_type Only categories that apply to the specified entity type will be returned. 
    # @return [BusinessCategoriesResponse]
    def get_business_categories(v, opts = {})
      data, _status_code, _headers = get_business_categories_with_http_info(v, opts)
      data
    end

    # Categories: List
    # Get available Categories.  All Locations are required to have an associated Category to assist with organization and search. Yext provides a hierarchy of business categories for this purpose, exposed by this API. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :language Only categories that apply to this language will be returned.  Valid values: ISO 639-1 language codes  **Example:** en 
    # @option opts [String] :country Only categories that apply in this country will be returned.  Valid values: ISO 3166-1 alpha-2 country codes  **Example:** US 
    # @option opts [String] :entity_type Only categories that apply to the specified entity type will be returned. 
    # @return [Array<(BusinessCategoriesResponse, Integer, Hash)>] BusinessCategoriesResponse data, response status code and response headers
    def get_business_categories_with_http_info(v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_business_categories ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_business_categories"
      end
      allowable_values = ["atm", "event", "healthcareFacility", "healthcareProfessional", "location", "restaurant"]
      if @api_client.config.client_side_validation && opts[:'entity_type'] && !allowable_values.include?(opts[:'entity_type'])
        fail ArgumentError, "invalid value for \"entity_type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/categories'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'language'] = opts[:'language'] if !opts[:'language'].nil?
      query_params[:'country'] = opts[:'country'] if !opts[:'country'].nil?
      query_params[:'entityType'] = opts[:'entity_type'] if !opts[:'entity_type'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'BusinessCategoriesResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_business_categories",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_business_categories\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Custom Fields: Get
    # Gets a specific Custom Field in an Account.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param custom_field_id [String] ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
    # @param [Hash] opts the optional parameters
    # @return [CustomFieldResponse]
    def get_custom_field(v, account_id, custom_field_id, opts = {})
      data, _status_code, _headers = get_custom_field_with_http_info(v, account_id, custom_field_id, opts)
      data
    end

    # Custom Fields: Get
    # Gets a specific Custom Field in an Account.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param custom_field_id [String] ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
    # @param [Hash] opts the optional parameters
    # @return [Array<(CustomFieldResponse, Integer, Hash)>] CustomFieldResponse data, response status code and response headers
    def get_custom_field_with_http_info(v, account_id, custom_field_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_custom_field ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_custom_field"
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_custom_field"
      end
      # verify the required parameter 'custom_field_id' is set
      if @api_client.config.client_side_validation && custom_field_id.nil?
        fail ArgumentError, "Missing the required parameter 'custom_field_id' when calling KnowledgeManagerApi.get_custom_field"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/customfields/{customFieldId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'customFieldId' + '}', CGI.escape(custom_field_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomFieldResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_custom_field",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_custom_field\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Custom Fields: List
    # Returns a list of Custom Fields in an Account.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @option opts [Integer] :limit Number of results to return. (default to 100)
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data. 
    # @return [CustomFieldsResponse]
    def get_custom_fields(v, account_id, opts = {})
      data, _status_code, _headers = get_custom_fields_with_http_info(v, account_id, opts)
      data
    end

    # Custom Fields: List
    # Returns a list of Custom Fields in an Account.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @option opts [Integer] :limit Number of results to return. (default to 100)
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data. 
    # @return [Array<(CustomFieldsResponse, Integer, Hash)>] CustomFieldsResponse data, response status code and response headers
    def get_custom_fields_with_http_info(v, account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_custom_fields ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_custom_fields"
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_custom_fields"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.get_custom_fields, must be smaller than or equal to 1000.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/customfields'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'pageToken'] = opts[:'page_token'] if !opts[:'page_token'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomFieldsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_custom_fields",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_custom_fields\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entities: Get
    # Retrieve information for an Entity with a given ID
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response.   - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot;   - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @return [CreateEntity201Response]
    def get_entity(account_id, entity_id, v, opts = {})
      data, _status_code, _headers = get_entity_with_http_info(account_id, entity_id, v, opts)
      data
    end

    # Entities: Get
    # Retrieve information for an Entity with a given ID
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response.   - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot;   - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @return [Array<(CreateEntity201Response, Integer, Hash)>] CreateEntity201Response data, response status code and response headers
    def get_entity_with_http_info(account_id, entity_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_entity ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_entity"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.get_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_id' is set
      if @api_client.config.client_side_validation && entity_id.nil?
        fail ArgumentError, "Missing the required parameter 'entity_id' when calling KnowledgeManagerApi.get_entity"
      end
      if @api_client.config.client_side_validation && entity_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "entity_id" when calling KnowledgeManagerApi.get_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_entity"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.get_entity, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'fields'].nil? && opts[:'fields'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"fields"]" when calling KnowledgeManagerApi.get_entity, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'format'].nil? && opts[:'format'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"format"]" when calling KnowledgeManagerApi.get_entity, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entities/{entityId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'entityId' + '}', CGI.escape(entity_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'fields'] = opts[:'fields'] if !opts[:'fields'].nil?
      query_params[:'format'] = opts[:'format'] if !opts[:'format'].nil?
      query_params[:'resolvePlaceholders'] = opts[:'resolve_placeholders'] if !opts[:'resolve_placeholders'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CreateEntity201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_entity",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_entity\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Events (Legacy): Get
    # Retrieve a specific Event List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [EventListResponse]
    def get_event(account_id, list_id, v, opts = {})
      data, _status_code, _headers = get_event_with_http_info(account_id, list_id, v, opts)
      data
    end

    # Events (Legacy): Get
    # Retrieve a specific Event List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(EventListResponse, Integer, Hash)>] EventListResponse data, response status code and response headers
    def get_event_with_http_info(account_id, list_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_event ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_event"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.get_event"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_event"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/events/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EventListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_event",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_event\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Events (Legacy): List
    # Retrieve all Event Lists for an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @return [EventListsResponse]
    def get_events(account_id, v, opts = {})
      data, _status_code, _headers = get_events_with_http_info(account_id, v, opts)
      data
    end

    # Events (Legacy): List
    # Retrieve all Event Lists for an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @return [Array<(EventListsResponse, Integer, Hash)>] EventListsResponse data, response status code and response headers
    def get_events_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_events ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_events"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_events"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.get_events, must be smaller than or equal to 50.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/events'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EventListsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_events",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_events\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Google Fields: List
    #  Use the Google Fields endpoint to retrieve a complete list of Google's location attributes for each business category. This list includes attributes that may not apply to all Locations in an account. The set of attributes available to a Location depends on its primary business category. You can view and edit the attributes of Locations in the **`googleAttributes`** Location field.  **NOTE:** Google Attributes are managed by Google and are subject to change without notice. To prevent errors, make sure your API implementation is not dependent on the presence of specific attributes. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :language The language code corresponding to the language in which the user would like to retrieve the Google Fields. Only categories that apply to this language will be returned. 
    # @option opts [String] :client_category_id A category id for the business that, if specified, will filter the result to only include any Google Fields that the provided id maps to. 
    # @option opts [String] :country_code The two-character ISO 3166-1 country code, if specified, will filter the result to only include any Google Fields that are eligible for that country. 
    # @return [GoogleFieldsResponse]
    def get_google_keywords(v, opts = {})
      data, _status_code, _headers = get_google_keywords_with_http_info(v, opts)
      data
    end

    # Google Fields: List
    #  Use the Google Fields endpoint to retrieve a complete list of Google&#39;s location attributes for each business category. This list includes attributes that may not apply to all Locations in an account. The set of attributes available to a Location depends on its primary business category. You can view and edit the attributes of Locations in the **&#x60;googleAttributes&#x60;** Location field.  **NOTE:** Google Attributes are managed by Google and are subject to change without notice. To prevent errors, make sure your API implementation is not dependent on the presence of specific attributes. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :language The language code corresponding to the language in which the user would like to retrieve the Google Fields. Only categories that apply to this language will be returned. 
    # @option opts [String] :client_category_id A category id for the business that, if specified, will filter the result to only include any Google Fields that the provided id maps to. 
    # @option opts [String] :country_code The two-character ISO 3166-1 country code, if specified, will filter the result to only include any Google Fields that are eligible for that country. 
    # @return [Array<(GoogleFieldsResponse, Integer, Hash)>] GoogleFieldsResponse data, response status code and response headers
    def get_google_keywords_with_http_info(v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_google_keywords ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_google_keywords"
      end
      # resource path
      local_var_path = '/googlefields'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'language'] = opts[:'language'] if !opts[:'language'].nil?
      query_params[:'clientCategoryId'] = opts[:'client_category_id'] if !opts[:'client_category_id'].nil?
      query_params[:'countryCode'] = opts[:'country_code'] if !opts[:'country_code'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GoogleFieldsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_google_keywords",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_google_keywords\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entity Language Profiles: Get
    # Retrieve a Language Profile for an Entity  **NOTE**:  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param language_code [String] The language code corresponding to the language of the profiles that the user wishes to retrieve
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [Boolean] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages.  (default to false)
    # @return [CreateEntity201Response]
    def get_language_profile(account_id, entity_id, language_code, v, opts = {})
      data, _status_code, _headers = get_language_profile_with_http_info(account_id, entity_id, language_code, v, opts)
      data
    end

    # Entity Language Profiles: Get
    # Retrieve a Language Profile for an Entity  **NOTE**:  * If the **&#x60;v&#x60;** parameter is before &#x60;20190103&#x60;: by default, returned alternate Language Profiles include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields * If the **&#x60;v&#x60;** parameter is &#x60;20190103&#x60; or later: by default, returned alternate Language Profiles do not include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields. However, these fields can still be retrieved if the **&#x60;rendered&#x60;** parameter in the request is set to &#x60;true&#x60;. 
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param language_code [String] The language code corresponding to the language of the profiles that the user wishes to retrieve
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [Boolean] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages.  (default to false)
    # @return [Array<(CreateEntity201Response, Integer, Hash)>] CreateEntity201Response data, response status code and response headers
    def get_language_profile_with_http_info(account_id, entity_id, language_code, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_language_profile ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_language_profile"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.get_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_id' is set
      if @api_client.config.client_side_validation && entity_id.nil?
        fail ArgumentError, "Missing the required parameter 'entity_id' when calling KnowledgeManagerApi.get_language_profile"
      end
      if @api_client.config.client_side_validation && entity_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "entity_id" when calling KnowledgeManagerApi.get_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'language_code' is set
      if @api_client.config.client_side_validation && language_code.nil?
        fail ArgumentError, "Missing the required parameter 'language_code' when calling KnowledgeManagerApi.get_language_profile"
      end
      if @api_client.config.client_side_validation && language_code.to_s.length < 0
        fail ArgumentError, 'invalid value for "language_code" when calling KnowledgeManagerApi.get_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_language_profile"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.get_language_profile, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'fields'].nil? && opts[:'fields'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"fields"]" when calling KnowledgeManagerApi.get_language_profile, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'format'].nil? && opts[:'format'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"format"]" when calling KnowledgeManagerApi.get_language_profile, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entityprofiles/{entityId}/{languageCode}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'entityId' + '}', CGI.escape(entity_id.to_s)).sub('{' + 'languageCode' + '}', CGI.escape(language_code.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'fields'] = opts[:'fields'] if !opts[:'fields'].nil?
      query_params[:'format'] = opts[:'format'] if !opts[:'format'].nil?
      query_params[:'rendered'] = opts[:'rendered'] if !opts[:'rendered'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CreateEntity201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_language_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_language_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Language Profiles (Legacy): List
    # Get Language Profiles for a Location.
    # @param account_id [String] 
    # @param location_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @return [LanguageProfilesResponse]
    def get_language_profiles(account_id, location_id, v, opts = {})
      data, _status_code, _headers = get_language_profiles_with_http_info(account_id, location_id, v, opts)
      data
    end

    # Language Profiles (Legacy): List
    # Get Language Profiles for a Location.
    # @param account_id [String] 
    # @param location_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @return [Array<(LanguageProfilesResponse, Integer, Hash)>] LanguageProfilesResponse data, response status code and response headers
    def get_language_profiles_with_http_info(account_id, location_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_language_profiles ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_language_profiles"
      end
      # verify the required parameter 'location_id' is set
      if @api_client.config.client_side_validation && location_id.nil?
        fail ArgumentError, "Missing the required parameter 'location_id' when calling KnowledgeManagerApi.get_language_profiles"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_language_profiles"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/locations/{locationId}/profiles'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'locationId' + '}', CGI.escape(location_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'resolvePlaceholders'] = opts[:'resolve_placeholders'] if !opts[:'resolve_placeholders'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'LanguageProfilesResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_language_profiles",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_language_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Locations (Legacy): Get
    # Gets the primary profile for a single Location.
    # @param account_id [String] 
    # @param location_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @return [LocationResponse]
    def get_location(account_id, location_id, v, opts = {})
      data, _status_code, _headers = get_location_with_http_info(account_id, location_id, v, opts)
      data
    end

    # Locations (Legacy): Get
    # Gets the primary profile for a single Location.
    # @param account_id [String] 
    # @param location_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @return [Array<(LocationResponse, Integer, Hash)>] LocationResponse data, response status code and response headers
    def get_location_with_http_info(account_id, location_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_location ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_location"
      end
      # verify the required parameter 'location_id' is set
      if @api_client.config.client_side_validation && location_id.nil?
        fail ArgumentError, "Missing the required parameter 'location_id' when calling KnowledgeManagerApi.get_location"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_location"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/locations/{locationId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'locationId' + '}', CGI.escape(location_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'resolvePlaceholders'] = opts[:'resolve_placeholders'] if !opts[:'resolve_placeholders'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'LocationResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_location",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Folders: List
    # Returns a list of Location Folders in an Account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @option opts [Integer] :limit Number of results to return. (default to 100)
    # @return [FoldersResponse]
    def get_location_folders(account_id, v, opts = {})
      data, _status_code, _headers = get_location_folders_with_http_info(account_id, v, opts)
      data
    end

    # Folders: List
    # Returns a list of Location Folders in an Account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @option opts [Integer] :limit Number of results to return. (default to 100)
    # @return [Array<(FoldersResponse, Integer, Hash)>] FoldersResponse data, response status code and response headers
    def get_location_folders_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_location_folders ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_location_folders"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_location_folders"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.get_location_folders, must be smaller than or equal to 1000.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/folders'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'FoldersResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_location_folders",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_location_folders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Language Profiles (Legacy): Get
    # Gets the the requested Language Profile for a given Location.
    # @param account_id [String] 
    # @param location_id [String] 
    # @param language_code [String] Locale code.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @return [LanguageProfileResponse]
    def get_location_language_profile(account_id, location_id, language_code, v, opts = {})
      data, _status_code, _headers = get_location_language_profile_with_http_info(account_id, location_id, language_code, v, opts)
      data
    end

    # Language Profiles (Legacy): Get
    # Gets the the requested Language Profile for a given Location.
    # @param account_id [String] 
    # @param location_id [String] 
    # @param language_code [String] Locale code.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @return [Array<(LanguageProfileResponse, Integer, Hash)>] LanguageProfileResponse data, response status code and response headers
    def get_location_language_profile_with_http_info(account_id, location_id, language_code, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_location_language_profile ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_location_language_profile"
      end
      # verify the required parameter 'location_id' is set
      if @api_client.config.client_side_validation && location_id.nil?
        fail ArgumentError, "Missing the required parameter 'location_id' when calling KnowledgeManagerApi.get_location_language_profile"
      end
      # verify the required parameter 'language_code' is set
      if @api_client.config.client_side_validation && language_code.nil?
        fail ArgumentError, "Missing the required parameter 'language_code' when calling KnowledgeManagerApi.get_location_language_profile"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_location_language_profile"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/locations/{locationId}/profiles/{language_code}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'locationId' + '}', CGI.escape(location_id.to_s)).sub('{' + 'language_code' + '}', CGI.escape(language_code.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'resolvePlaceholders'] = opts[:'resolve_placeholders'] if !opts[:'resolve_placeholders'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'LanguageProfileResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_location_language_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_location_language_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Locations (Legacy): List
    # Get multiple Locations (primary profiles only).
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;nextPageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data. 
    # @return [LocationsResponse]
    def get_locations(account_id, v, opts = {})
      data, _status_code, _headers = get_locations_with_http_info(account_id, v, opts)
      data
    end

    # Locations (Legacy): List
    # Get multiple Locations (primary profiles only).
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;nextPageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data. 
    # @return [Array<(LocationsResponse, Integer, Hash)>] LocationsResponse data, response status code and response headers
    def get_locations_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_locations ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_locations"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_locations"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.get_locations, must be smaller than or equal to 50.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/locations'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'resolvePlaceholders'] = opts[:'resolve_placeholders'] if !opts[:'resolve_placeholders'].nil?
      query_params[:'pageToken'] = opts[:'page_token'] if !opts[:'page_token'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'LocationsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_locations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Menus: Get
    # Retrieve a specific Menu.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [MenuListResponse]
    def get_menu(account_id, list_id, v, opts = {})
      data, _status_code, _headers = get_menu_with_http_info(account_id, list_id, v, opts)
      data
    end

    # Menus: Get
    # Retrieve a specific Menu.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(MenuListResponse, Integer, Hash)>] MenuListResponse data, response status code and response headers
    def get_menu_with_http_info(account_id, list_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_menu ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_menu"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.get_menu"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_menu"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/menus/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MenuListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_menu",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_menu\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Menus: List
    # Retrieve all Menus for an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @return [MenuListsResponse]
    def get_menus(account_id, v, opts = {})
      data, _status_code, _headers = get_menus_with_http_info(account_id, v, opts)
      data
    end

    # Menus: List
    # Retrieve all Menus for an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @return [Array<(MenuListsResponse, Integer, Hash)>] MenuListsResponse data, response status code and response headers
    def get_menus_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_menus ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_menus"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_menus"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.get_menus, must be smaller than or equal to 50.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/menus'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MenuListsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_menus",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_menus\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Products: Get
    # Retrieve a specific Product List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [ProductListResponse]
    def get_product(account_id, list_id, v, opts = {})
      data, _status_code, _headers = get_product_with_http_info(account_id, list_id, v, opts)
      data
    end

    # Products: Get
    # Retrieve a specific Product List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ProductListResponse, Integer, Hash)>] ProductListResponse data, response status code and response headers
    def get_product_with_http_info(account_id, list_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_product ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_product"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.get_product"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_product"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/products/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_product",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_product\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Products: List
    # Retrieve all Product Lists for an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @return [ProductListsResponse]
    def get_products(account_id, v, opts = {})
      data, _status_code, _headers = get_products_with_http_info(account_id, v, opts)
      data
    end

    # Products: List
    # Retrieve all Product Lists for an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @return [Array<(ProductListsResponse, Integer, Hash)>] ProductListsResponse data, response status code and response headers
    def get_products_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.get_products ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.get_products"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.get_products"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.get_products, must be smaller than or equal to 50.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/products'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductListsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.get_products",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#get_products\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entity Language Profiles: List All
    # Retrieve a list of Language Profiles for Entities within an account  **NOTE:**  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :filter This parameter represents one or more filtering conditions that are applied to the set of entities that would otherwise be returned. This parameter should be provided as a URL-encoded string containing a JSON object.  For example, if the filter JSON is &#x60;{\&quot;name\&quot;:{\&quot;$eq\&quot;:\&quot;John\&quot;}}&#x60;, then the filter param after URL-encoding will be: &#x60;filter&#x3D;%7B%22name%22%3A%7B%22%24eq%22%3A%22John%22%7D%7D&#x60;  **Basic Filter Structure**  The filter object at its core consists of a *matcher*, a *field*, and an *argument*.  For example, in the following filter JSON:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  &#x60;$eq&#x60; is the *matcher*, or filtering operation (equals, in this example),  &#x60;name&#x60; is the *field* being filtered by, and  &#x60;John&#x60; is *value* to be matched against.  **Combining Multiple Filters**  Multiple filters can be combined into one object using *combinators*. For example, the following filter JSON combines multiple filters using the combinator &#x60;$and&#x60;. &#x60;$or&#x60; is also supported. &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;firstName\&quot;:{         \&quot;$eq\&quot;:\&quot;John\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;$in\&quot;:[           \&quot;US\&quot;,           \&quot;GB\&quot;         ]       }     }   ] } &#x60;&#x60;&#x60;  **Filter Negation**  Certain filter types may be negated. For example:  &#x60;&#x60;&#x60; {   \&quot;$not\&quot; {     \&quot;name\&quot;:{       \&quot;$eq\&quot;:\&quot;John\&quot;     }   } } &#x60;&#x60;&#x60;  This can also be written more simply with a &#x60;!&#x60; in the &#x60;$eq&#x60; parameter. The following filter would have the same effect:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  **Filter Complement**  You can also search for the complement of a filter. This filter would match entities that do not contain \&quot;hello\&quot; in their descriptions, or do not have a description set. This is different from negation which can only match entities who have the negated field set to something.  &#x60;&#x60;&#x60; {   \&quot;$complement\&quot;:{     \&quot;description\&quot;:{       \&quot;$contains\&quot;:\&quot;hello\&quot;     }   } } &#x60;&#x60;&#x60;  **Addressing Subfields**  Subfields of fields can be addressed using the \&quot;dot\&quot; notation while filtering. For example, if you have a custom field called **&#x60;c_myCustomField&#x60;**:  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField\&quot;:{     \&quot;age\&quot;: 30,     \&quot;name\&quot;: \&quot;Jim\&quot;,   } } &#x60;&#x60;&#x60;  While filtering, subfields may be addressed using the \&quot;dot\&quot; notation.  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField.name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  Fields that are nested deeper may be addressed using dot notation, as well. For example, if **&#x60;name&#x60;** in the above example was a compound field with two subfields **&#x60;first&#x60;** and **&#x60;last&#x60;**, **&#x60;first&#x60;** may be addressed as **&#x60;c_myCustomField.name.first&#x60;**.  **Field Support**  Entity fields correspond to certain filter types, which support matchers. Going by the example above, the field **&#x60;name&#x60;** supports the &#x60;TEXT&#x60; filter type, which supports &#x60;$eq&#x60; (equals) and &#x60;$startsWith&#x60; (starts with).  **TEXT**  The &#x60;TEXT&#x60; filter type is supported for text fields. (e.g., **&#x60;name&#x60;**, **&#x60;countryCode&#x60;**)  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq (equals)&lt;/th&gt;     &lt;th&gt;      {       \&quot;countryCode\&quot;:{         \&quot;$eq\&quot;:\&quot;US\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;!$eq\&quot;:\&quot;US\&quot;       }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;Amazing\&quot; starts with \&quot;amaz\&quot;      {        \&quot;address.line1\&quot;:{           \&quot;$startsWith\&quot;: \&quot;Jo\&quot;        }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;firstName\&quot;:{         \&quot;$in\&quot;: [\&quot;John\&quot;, \&quot;Jimmy\&quot;]       }     }    Does not support negation. Negation can be mimicked by using an \&quot;OR\&quot; matcher, for example:      {       \&quot;$and\&quot;:[         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;John\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;Jimmy\&quot;           }         }       ]     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myString&#x60;**.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAny\&quot;:[           \&quot;sample1\&quot;, \&quot;sample2\&quot;         ]       }     }    This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAll\&quot;:[           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **BOOLEAN**   The BOOLEAN filter type is supported for boolean fields and Yes / No custom fields. &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;isFreeEvent\&quot;: {         \&quot;$eq\&quot;: true       }     }    For booleans, the filter takes a boolean value, not a string.   Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **STRUCT**  The STRUCT filter type is supported for compound fields with subfields.  *e.g., **&#x60;address&#x60;**, **&#x60;featuredMessage&#x60;**, fields of custom types*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$hasProperty&lt;/th&gt;     &lt;th&gt;    Matches if argument is a key (subfield) of field being filtered by. This filter type is useful for filtering by compound fields or to check if certain fields have a value set.      {       \&quot;address\&quot;: {         \&quot;$hasProperty\&quot;: \&quot;line1\&quot;       }     }    Note that if a given property of a compound field is not set, the filter will not match. For example, if &#x60;line1&#x60; of **&#x60;address&#x60;** is not set for an entity, then the above matcher will not match the entity.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **OPTION**  The OPTION filter type is supported for options custom fields and fields that have a predetermined list of valid values.   *e.g., **&#x60;eventStatus&#x60;**, **&#x60;gender&#x60;**, &#x60;SINGLE_OPTION&#x60; and &#x60;MULTI_OPTION&#x60; types of custom fields.*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Matching is case insensitive and insensitive to consecutive whitespace.    e.g., \&quot;XYZ 123\&quot; matches \&quot;xyz       123\&quot;      {       \&quot;eventStatus\&quot;: {         \&quot;$eq\&quot;: \&quot;SCHEDULED\&quot;       }     }    Supports negation. Negating &#x60;$eq&#x60; on the list will match any field that does not hold any of the provided values.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;      {       \&quot;eventStatus\&quot;: {         \&quot;$in\&quot;: [           \&quot;SCHEDULED\&quot;,           \&quot;POSTPONED\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values. For example:      {       \&quot;$and\&quot;: [         {           \&quot;eventStatus\&quot;:{             \&quot;!$eq\&quot;: \&quot;SCHEDULED\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;POSTPONED\&quot;           }         }       ]     }    &lt;/tr&gt; &lt;/table&gt;  **PHONE**  The PHONE filter type is supported for phone number fields only. PHONE will support the same matchers as TEXT, except that for &#x60;$eq&#x60;, the same phone number with or without calling code will match.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;+18187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;8187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;!$eq\&quot;:\&quot;9177076189\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;8187076189\&quot; starts with \&quot;818\&quot;      {       \&quot;mainPhone\&quot;:{         \&quot;$startsWith\&quot;: \&quot;818\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;mainPhone\&quot;:{         \&quot;$in\&quot;: [           \&quot;8185551616\&quot;,           \&quot;9171112211\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values.    &lt;/tr&gt; &lt;/table&gt;  **INTEGER, FLOAT, DATE, DATETIME, and TIME**  These filter types are strictly ordered -- therefore, they support the following matchers: - Equals - Less Than / Less Than or Equal To - Greater Than / Greater Than or Equal To  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Equals      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$eq\&quot;: \&quot;80\&quot;       }     }    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$lt&lt;/th&gt;     &lt;th&gt;    Less than      {       \&quot;time.start\&quot;: {         \&quot;$lt\&quot;: \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$gt&lt;/th&gt;     &lt;th&gt;    Greater than      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$gt\&quot;: \&quot;50\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$le&lt;/th&gt;     &lt;th&gt;    Less than or equal to      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$le\&quot;: \&quot;40\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$ge&lt;/th&gt;     &lt;th&gt;    Greater than or equal to      {       \&quot;time.end\&quot;: {         \&quot;$ge\&quot;:  \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;Combinations&lt;/th&gt;     &lt;th&gt;    While we do not support \&quot;between\&quot; in our filtering syntax, it is possible to combine multiple matchers for a result similar to an \&quot;and\&quot; operation:      {       \&quot;ageRange.maxValue : {         \&quot;$gt\&quot; : 10,         \&quot;$lt\&quot;: 20       }     }    &lt;/tr&gt; &lt;/table&gt;  **LIST OF TEXT**  Any field that has a list of valid values and supports any of the previously mentioned filter types will also support the &#x60;$contains&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eq\&quot;: \&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; EXACTLY matches any string within **&#x60;c_myStringList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if any one of \&quot;sample1\&quot; or \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;** . The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; AND \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;**. The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**.    Note that this matching is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }     This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAny&#x60; is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if BOTH \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in strings within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAll&#x60; is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$startsWith\&quot;:\&quot;sample\&quot;       }     }    This filter will match if any string within **&#x60;c_myStringList&#x60;** starts with \&quot;sample\&quot;.    Does not supports negation. Case Insensitive.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF BOOLEAN, OPTION, PHONE, INTEGER, FLOAT, DATE, DATETIME, OR TIME**  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myDateList\&quot;: {         \&quot;$eq\&quot;: \&quot;2019-01-01\&quot;       }     }     This filter will match if \&quot;2019-01-01\&quot; EXACTLY matches any date within **&#x60;c_myDateList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myIntegerList\&quot;: {         \&quot;$eqAny\&quot;: [1, 2]       }     }    This filter will match if 1 or 2 EXACTLY match any integer within **&#x60;c_myIntegerList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;2019-01-01\&quot; AND \&quot;2019-01-02\&quot; EXACTLY match a date within **&#x60;c_myDateList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF STRUCT**  Filtering on lists of struct types is a bit nuanced. Filtering can only be done on lists of structs of the SAME type. For example, if **&#x60;c_myStructList&#x60;** is a list of compound fields with the subfields **&#x60;age&#x60;** and **&#x60;name&#x60;**, then one can address the **&#x60;age&#x60;** properties of each field in **&#x60;c_myStructList&#x60;** as a flattened list of integers and filtering upon them. For example, the following filter:  &#x60;&#x60;&#x60; {   \&quot;c_myStructList.age\&quot;:{     \&quot;$eq\&quot;: 20   } } &#x60;&#x60;&#x60;  will match if any field in the list has an **&#x60;age&#x60;** property equal to 20. Similarly, any filter that can be applied to lists of integers could be applied to **&#x60;age&#x60;** in this case (&#x60;$eq&#x60;, &#x60;$eqAll&#x60;, &#x60;$eqAny&#x60;).   **HOURS**  By filtering on an hours field, you can find which entities are open or closed at a specified time or during a certain time range. All of these filters also take an entity’s holiday hours and reopen date into account.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openAt\&quot;:           \&quot;2019-01-06T13:45\&quot;       }     }     This filter would match entities open at the specified time.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedAt:           \&quot;2019-01-06T13:45\&quot;       }     }    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$openForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }     This filter would match only those entities that are open for the entire range between 2019-01-06T13:45 and 2019-01-06T15:00.      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;:           \&quot;2019-05-10\&quot;       }     }    This filter would match entities open for the entire 24 hour period on 2019-05-10.    You can also supply a year, a month, or an hour to filter for entities open for the entire year, month, or hour, respectively.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAnyOf\&quot;: {           \&quot;start\&quot;: \&quot;now\&quot;,           \&quot;end\&quot;: \&quot;now+2h\&quot;         }       }     }    This filter will match any entities that are open for at least a portion of the time range between now and two hours from now.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match only those entities that are closed for the entire given time range.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAnyOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match any entities that are closed for at least a portion of the given time range.   &lt;/tr&gt; &lt;/table&gt;   **Filtering by Dates and Times**  **Time zones**  The filtering language supports searching both in local time and within a certain time zone. Searching in local time will simply ignore the time zone on the target entities, while providing one will convert the zone of your queried time to the zone of the target entities.  To search in local time, simply provide the date or time without any zone: &#x60;2019-06-07T15:30&#x60; or &#x60;2019-06-07&#x60;.  To conduct a zoned search, provide the name of the time zone in brackets after the time, as it is shown in the tz database: &#x60;2019-06-07T15:30[America/New_York]&#x60; or &#x60;2019-06-06[America/Phoenix]&#x60;.   **Date and time types**  In addition to searching with dates and datetimes, you can also query with years, months, and hours. For example, the filter:  &#x60;&#x60;&#x60; {   \&quot;time.start\&quot;: {     \&quot;$eq\&quot;: \&quot;2018\&quot;   } } &#x60;&#x60;&#x60;  would match all start times in the year 2018. The same logic would apply for a month (&#x60;2019-05&#x60;), a date (&#x60;2019-05-01&#x60;), or an hour (&#x60;2019-05-01T06&#x60;).  These types also work with ordered searches. For example:  &#x60;&#x60;&#x60; {  \&quot;time.start\&quot;: {     \&quot;$lt\&quot;: \&quot;2018\&quot;  } } &#x60;&#x60;&#x60;  would match start times before 2018 (i.e., anything in 2017 or before). On the other hand, the same query with a &#x60;$le&#x60; matcher would include anything in or before 2018.  **\&quot;Now\&quot; and Date Math**  Instead of providing a static date or time, you can also use &#x60;now&#x60; in place of any date time. When you do so, the system will calculate the time when the query is made and conduct a zoned search.  In order to search for a future or past time relative to &#x60;now&#x60;, you can use date math. For example, you can enter &#x60;now+3h&#x60; or &#x60;now-1d&#x60;, which would mean 3 hours from now and 1 day ago, respectively. You can also add and subtract minutes (&#x60;m&#x60;), months (&#x60;M&#x60;), and years (&#x60;y&#x60;).  It is also possible to add or subtract time from a static date or datetime. Simply add &#x60;||&#x60; between the static value and any addition or subtraction. For example, &#x60;2019-02-03||+1d&#x60; would be the same as &#x60;2019-02-04&#x60;.  You can also convert date and time types to other types. For example, to convert the datetime &#x60;2019-05-06T22:15&#x60; to a date, use &#x60;2019-05-06T22:15||/d&#x60;. Doing so would yield the same result as using &#x60;2019-05-06&#x60;. This method also works with &#x60;now&#x60;: &#x60;now/d&#x60; will give you today’s date without the time.  **Filtering Across an Entity**  It is possible to search for a specific text string across all fields of an entity by using the &#x60;$anywhere&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$anywhere&lt;/th&gt;     &lt;th&gt;    Matches if the argument text appears anywhere in the entity (including subfields, structs, and lists)      {       \&quot;$anywhere\&quot;: \&quot;hello\&quot;     }    This filter will match all entities that contain the string \&quot;hello\&quot; or strings that begin with \&quot;hello\&quot;.    &lt;/tr&gt; &lt;/table&gt;  **Examples**  The following filter will match against entities that: - Are of type &#x60;event&#x60; (note that entity types can also be filtered by the **&#x60;entityTypes&#x60;** query parameter) - Have a name that starts with the text \&quot;Century\&quot; - Have a maximum age between 10 and 20 - Have a minimum age between 5 and 7 - Start after 7 PM (19:00) on August 28, 2018  &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;entityType\&quot;:{         \&quot;$eq\&quot;:\&quot;event\&quot;       }     },     {       \&quot;name\&quot;:{         \&quot;$startsWith\&quot;:\&quot;Century\&quot;       }     },     {       \&quot;ageRange.maxValue\&quot;:{         \&quot;$gt\&quot;:10,         \&quot;$lt\&quot;:20       }     },     {       \&quot;ageRange.minValue\&quot;:{         \&quot;$gt\&quot;:5,         \&quot;$lt\&quot;:7       }     },     {       \&quot;time.start\&quot;:{         \&quot;$ge\&quot;:\&quot;2018-08-28T19:00\&quot;       }     }   ] } &#x60;&#x60;&#x60; 
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [String] :language_codes The comma-separated language codes corresponding to the languages of the profile that the user wishes to retrieve
    # @option opts [Float] :limit Number of results to return.
    # @option opts [Float] :offset Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  For Live API requests, the offset cannot be higher than 9,950. For Knowledge API the maximum limit is only enforced if a filter and/or sortBy parameter are given. 
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
    # @option opts [String] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages.  (default to 'false')
    # @option opts [String] :sort_by A list of fields and sort directions to order results by. Each ordering in the list should be in the format &#x60;{\&quot;field_name\&quot;, \&quot;sort_direction\&quot;}&#x60;, where &#x60;sort_direction&#x60; is either &#x60;ASCENDING&#x60; or &#x60;DESCENDING&#x60;.  For example, to order by &#x60;name&#x60; the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. To order by &#x60;name&#x60; and then &#x60;description&#x60;, the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;},{\&quot;description\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. 
    # @return [ListAllLanguageProfiles200Response]
    def list_all_language_profiles(account_id, v, opts = {})
      data, _status_code, _headers = list_all_language_profiles_with_http_info(account_id, v, opts)
      data
    end

    # Entity Language Profiles: List All
    # Retrieve a list of Language Profiles for Entities within an account  **NOTE:**  * If the **&#x60;v&#x60;** parameter is before &#x60;20190103&#x60;: by default, returned alternate Language Profiles include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields * If the **&#x60;v&#x60;** parameter is &#x60;20190103&#x60; or later: by default, returned alternate Language Profiles do not include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields. However, these fields can still be retrieved if the **&#x60;rendered&#x60;** parameter in the request is set to &#x60;true&#x60;. 
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :filter This parameter represents one or more filtering conditions that are applied to the set of entities that would otherwise be returned. This parameter should be provided as a URL-encoded string containing a JSON object.  For example, if the filter JSON is &#x60;{\&quot;name\&quot;:{\&quot;$eq\&quot;:\&quot;John\&quot;}}&#x60;, then the filter param after URL-encoding will be: &#x60;filter&#x3D;%7B%22name%22%3A%7B%22%24eq%22%3A%22John%22%7D%7D&#x60;  **Basic Filter Structure**  The filter object at its core consists of a *matcher*, a *field*, and an *argument*.  For example, in the following filter JSON:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  &#x60;$eq&#x60; is the *matcher*, or filtering operation (equals, in this example),  &#x60;name&#x60; is the *field* being filtered by, and  &#x60;John&#x60; is *value* to be matched against.  **Combining Multiple Filters**  Multiple filters can be combined into one object using *combinators*. For example, the following filter JSON combines multiple filters using the combinator &#x60;$and&#x60;. &#x60;$or&#x60; is also supported. &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;firstName\&quot;:{         \&quot;$eq\&quot;:\&quot;John\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;$in\&quot;:[           \&quot;US\&quot;,           \&quot;GB\&quot;         ]       }     }   ] } &#x60;&#x60;&#x60;  **Filter Negation**  Certain filter types may be negated. For example:  &#x60;&#x60;&#x60; {   \&quot;$not\&quot; {     \&quot;name\&quot;:{       \&quot;$eq\&quot;:\&quot;John\&quot;     }   } } &#x60;&#x60;&#x60;  This can also be written more simply with a &#x60;!&#x60; in the &#x60;$eq&#x60; parameter. The following filter would have the same effect:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  **Filter Complement**  You can also search for the complement of a filter. This filter would match entities that do not contain \&quot;hello\&quot; in their descriptions, or do not have a description set. This is different from negation which can only match entities who have the negated field set to something.  &#x60;&#x60;&#x60; {   \&quot;$complement\&quot;:{     \&quot;description\&quot;:{       \&quot;$contains\&quot;:\&quot;hello\&quot;     }   } } &#x60;&#x60;&#x60;  **Addressing Subfields**  Subfields of fields can be addressed using the \&quot;dot\&quot; notation while filtering. For example, if you have a custom field called **&#x60;c_myCustomField&#x60;**:  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField\&quot;:{     \&quot;age\&quot;: 30,     \&quot;name\&quot;: \&quot;Jim\&quot;,   } } &#x60;&#x60;&#x60;  While filtering, subfields may be addressed using the \&quot;dot\&quot; notation.  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField.name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  Fields that are nested deeper may be addressed using dot notation, as well. For example, if **&#x60;name&#x60;** in the above example was a compound field with two subfields **&#x60;first&#x60;** and **&#x60;last&#x60;**, **&#x60;first&#x60;** may be addressed as **&#x60;c_myCustomField.name.first&#x60;**.  **Field Support**  Entity fields correspond to certain filter types, which support matchers. Going by the example above, the field **&#x60;name&#x60;** supports the &#x60;TEXT&#x60; filter type, which supports &#x60;$eq&#x60; (equals) and &#x60;$startsWith&#x60; (starts with).  **TEXT**  The &#x60;TEXT&#x60; filter type is supported for text fields. (e.g., **&#x60;name&#x60;**, **&#x60;countryCode&#x60;**)  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq (equals)&lt;/th&gt;     &lt;th&gt;      {       \&quot;countryCode\&quot;:{         \&quot;$eq\&quot;:\&quot;US\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;!$eq\&quot;:\&quot;US\&quot;       }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;Amazing\&quot; starts with \&quot;amaz\&quot;      {        \&quot;address.line1\&quot;:{           \&quot;$startsWith\&quot;: \&quot;Jo\&quot;        }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;firstName\&quot;:{         \&quot;$in\&quot;: [\&quot;John\&quot;, \&quot;Jimmy\&quot;]       }     }    Does not support negation. Negation can be mimicked by using an \&quot;OR\&quot; matcher, for example:      {       \&quot;$and\&quot;:[         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;John\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;Jimmy\&quot;           }         }       ]     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myString&#x60;**.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAny\&quot;:[           \&quot;sample1\&quot;, \&quot;sample2\&quot;         ]       }     }    This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAll\&quot;:[           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **BOOLEAN**   The BOOLEAN filter type is supported for boolean fields and Yes / No custom fields. &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;isFreeEvent\&quot;: {         \&quot;$eq\&quot;: true       }     }    For booleans, the filter takes a boolean value, not a string.   Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **STRUCT**  The STRUCT filter type is supported for compound fields with subfields.  *e.g., **&#x60;address&#x60;**, **&#x60;featuredMessage&#x60;**, fields of custom types*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$hasProperty&lt;/th&gt;     &lt;th&gt;    Matches if argument is a key (subfield) of field being filtered by. This filter type is useful for filtering by compound fields or to check if certain fields have a value set.      {       \&quot;address\&quot;: {         \&quot;$hasProperty\&quot;: \&quot;line1\&quot;       }     }    Note that if a given property of a compound field is not set, the filter will not match. For example, if &#x60;line1&#x60; of **&#x60;address&#x60;** is not set for an entity, then the above matcher will not match the entity.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **OPTION**  The OPTION filter type is supported for options custom fields and fields that have a predetermined list of valid values.   *e.g., **&#x60;eventStatus&#x60;**, **&#x60;gender&#x60;**, &#x60;SINGLE_OPTION&#x60; and &#x60;MULTI_OPTION&#x60; types of custom fields.*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Matching is case insensitive and insensitive to consecutive whitespace.    e.g., \&quot;XYZ 123\&quot; matches \&quot;xyz       123\&quot;      {       \&quot;eventStatus\&quot;: {         \&quot;$eq\&quot;: \&quot;SCHEDULED\&quot;       }     }    Supports negation. Negating &#x60;$eq&#x60; on the list will match any field that does not hold any of the provided values.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;      {       \&quot;eventStatus\&quot;: {         \&quot;$in\&quot;: [           \&quot;SCHEDULED\&quot;,           \&quot;POSTPONED\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values. For example:      {       \&quot;$and\&quot;: [         {           \&quot;eventStatus\&quot;:{             \&quot;!$eq\&quot;: \&quot;SCHEDULED\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;POSTPONED\&quot;           }         }       ]     }    &lt;/tr&gt; &lt;/table&gt;  **PHONE**  The PHONE filter type is supported for phone number fields only. PHONE will support the same matchers as TEXT, except that for &#x60;$eq&#x60;, the same phone number with or without calling code will match.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;+18187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;8187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;!$eq\&quot;:\&quot;9177076189\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;8187076189\&quot; starts with \&quot;818\&quot;      {       \&quot;mainPhone\&quot;:{         \&quot;$startsWith\&quot;: \&quot;818\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;mainPhone\&quot;:{         \&quot;$in\&quot;: [           \&quot;8185551616\&quot;,           \&quot;9171112211\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values.    &lt;/tr&gt; &lt;/table&gt;  **INTEGER, FLOAT, DATE, DATETIME, and TIME**  These filter types are strictly ordered -- therefore, they support the following matchers: - Equals - Less Than / Less Than or Equal To - Greater Than / Greater Than or Equal To  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Equals      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$eq\&quot;: \&quot;80\&quot;       }     }    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$lt&lt;/th&gt;     &lt;th&gt;    Less than      {       \&quot;time.start\&quot;: {         \&quot;$lt\&quot;: \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$gt&lt;/th&gt;     &lt;th&gt;    Greater than      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$gt\&quot;: \&quot;50\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$le&lt;/th&gt;     &lt;th&gt;    Less than or equal to      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$le\&quot;: \&quot;40\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$ge&lt;/th&gt;     &lt;th&gt;    Greater than or equal to      {       \&quot;time.end\&quot;: {         \&quot;$ge\&quot;:  \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;Combinations&lt;/th&gt;     &lt;th&gt;    While we do not support \&quot;between\&quot; in our filtering syntax, it is possible to combine multiple matchers for a result similar to an \&quot;and\&quot; operation:      {       \&quot;ageRange.maxValue : {         \&quot;$gt\&quot; : 10,         \&quot;$lt\&quot;: 20       }     }    &lt;/tr&gt; &lt;/table&gt;  **LIST OF TEXT**  Any field that has a list of valid values and supports any of the previously mentioned filter types will also support the &#x60;$contains&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eq\&quot;: \&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; EXACTLY matches any string within **&#x60;c_myStringList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if any one of \&quot;sample1\&quot; or \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;** . The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; AND \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;**. The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**.    Note that this matching is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }     This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAny&#x60; is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if BOTH \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in strings within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAll&#x60; is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$startsWith\&quot;:\&quot;sample\&quot;       }     }    This filter will match if any string within **&#x60;c_myStringList&#x60;** starts with \&quot;sample\&quot;.    Does not supports negation. Case Insensitive.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF BOOLEAN, OPTION, PHONE, INTEGER, FLOAT, DATE, DATETIME, OR TIME**  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myDateList\&quot;: {         \&quot;$eq\&quot;: \&quot;2019-01-01\&quot;       }     }     This filter will match if \&quot;2019-01-01\&quot; EXACTLY matches any date within **&#x60;c_myDateList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myIntegerList\&quot;: {         \&quot;$eqAny\&quot;: [1, 2]       }     }    This filter will match if 1 or 2 EXACTLY match any integer within **&#x60;c_myIntegerList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;2019-01-01\&quot; AND \&quot;2019-01-02\&quot; EXACTLY match a date within **&#x60;c_myDateList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF STRUCT**  Filtering on lists of struct types is a bit nuanced. Filtering can only be done on lists of structs of the SAME type. For example, if **&#x60;c_myStructList&#x60;** is a list of compound fields with the subfields **&#x60;age&#x60;** and **&#x60;name&#x60;**, then one can address the **&#x60;age&#x60;** properties of each field in **&#x60;c_myStructList&#x60;** as a flattened list of integers and filtering upon them. For example, the following filter:  &#x60;&#x60;&#x60; {   \&quot;c_myStructList.age\&quot;:{     \&quot;$eq\&quot;: 20   } } &#x60;&#x60;&#x60;  will match if any field in the list has an **&#x60;age&#x60;** property equal to 20. Similarly, any filter that can be applied to lists of integers could be applied to **&#x60;age&#x60;** in this case (&#x60;$eq&#x60;, &#x60;$eqAll&#x60;, &#x60;$eqAny&#x60;).   **HOURS**  By filtering on an hours field, you can find which entities are open or closed at a specified time or during a certain time range. All of these filters also take an entity’s holiday hours and reopen date into account.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openAt\&quot;:           \&quot;2019-01-06T13:45\&quot;       }     }     This filter would match entities open at the specified time.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedAt:           \&quot;2019-01-06T13:45\&quot;       }     }    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$openForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }     This filter would match only those entities that are open for the entire range between 2019-01-06T13:45 and 2019-01-06T15:00.      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;:           \&quot;2019-05-10\&quot;       }     }    This filter would match entities open for the entire 24 hour period on 2019-05-10.    You can also supply a year, a month, or an hour to filter for entities open for the entire year, month, or hour, respectively.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAnyOf\&quot;: {           \&quot;start\&quot;: \&quot;now\&quot;,           \&quot;end\&quot;: \&quot;now+2h\&quot;         }       }     }    This filter will match any entities that are open for at least a portion of the time range between now and two hours from now.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match only those entities that are closed for the entire given time range.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAnyOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match any entities that are closed for at least a portion of the given time range.   &lt;/tr&gt; &lt;/table&gt;   **Filtering by Dates and Times**  **Time zones**  The filtering language supports searching both in local time and within a certain time zone. Searching in local time will simply ignore the time zone on the target entities, while providing one will convert the zone of your queried time to the zone of the target entities.  To search in local time, simply provide the date or time without any zone: &#x60;2019-06-07T15:30&#x60; or &#x60;2019-06-07&#x60;.  To conduct a zoned search, provide the name of the time zone in brackets after the time, as it is shown in the tz database: &#x60;2019-06-07T15:30[America/New_York]&#x60; or &#x60;2019-06-06[America/Phoenix]&#x60;.   **Date and time types**  In addition to searching with dates and datetimes, you can also query with years, months, and hours. For example, the filter:  &#x60;&#x60;&#x60; {   \&quot;time.start\&quot;: {     \&quot;$eq\&quot;: \&quot;2018\&quot;   } } &#x60;&#x60;&#x60;  would match all start times in the year 2018. The same logic would apply for a month (&#x60;2019-05&#x60;), a date (&#x60;2019-05-01&#x60;), or an hour (&#x60;2019-05-01T06&#x60;).  These types also work with ordered searches. For example:  &#x60;&#x60;&#x60; {  \&quot;time.start\&quot;: {     \&quot;$lt\&quot;: \&quot;2018\&quot;  } } &#x60;&#x60;&#x60;  would match start times before 2018 (i.e., anything in 2017 or before). On the other hand, the same query with a &#x60;$le&#x60; matcher would include anything in or before 2018.  **\&quot;Now\&quot; and Date Math**  Instead of providing a static date or time, you can also use &#x60;now&#x60; in place of any date time. When you do so, the system will calculate the time when the query is made and conduct a zoned search.  In order to search for a future or past time relative to &#x60;now&#x60;, you can use date math. For example, you can enter &#x60;now+3h&#x60; or &#x60;now-1d&#x60;, which would mean 3 hours from now and 1 day ago, respectively. You can also add and subtract minutes (&#x60;m&#x60;), months (&#x60;M&#x60;), and years (&#x60;y&#x60;).  It is also possible to add or subtract time from a static date or datetime. Simply add &#x60;||&#x60; between the static value and any addition or subtraction. For example, &#x60;2019-02-03||+1d&#x60; would be the same as &#x60;2019-02-04&#x60;.  You can also convert date and time types to other types. For example, to convert the datetime &#x60;2019-05-06T22:15&#x60; to a date, use &#x60;2019-05-06T22:15||/d&#x60;. Doing so would yield the same result as using &#x60;2019-05-06&#x60;. This method also works with &#x60;now&#x60;: &#x60;now/d&#x60; will give you today’s date without the time.  **Filtering Across an Entity**  It is possible to search for a specific text string across all fields of an entity by using the &#x60;$anywhere&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$anywhere&lt;/th&gt;     &lt;th&gt;    Matches if the argument text appears anywhere in the entity (including subfields, structs, and lists)      {       \&quot;$anywhere\&quot;: \&quot;hello\&quot;     }    This filter will match all entities that contain the string \&quot;hello\&quot; or strings that begin with \&quot;hello\&quot;.    &lt;/tr&gt; &lt;/table&gt;  **Examples**  The following filter will match against entities that: - Are of type &#x60;event&#x60; (note that entity types can also be filtered by the **&#x60;entityTypes&#x60;** query parameter) - Have a name that starts with the text \&quot;Century\&quot; - Have a maximum age between 10 and 20 - Have a minimum age between 5 and 7 - Start after 7 PM (19:00) on August 28, 2018  &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;entityType\&quot;:{         \&quot;$eq\&quot;:\&quot;event\&quot;       }     },     {       \&quot;name\&quot;:{         \&quot;$startsWith\&quot;:\&quot;Century\&quot;       }     },     {       \&quot;ageRange.maxValue\&quot;:{         \&quot;$gt\&quot;:10,         \&quot;$lt\&quot;:20       }     },     {       \&quot;ageRange.minValue\&quot;:{         \&quot;$gt\&quot;:5,         \&quot;$lt\&quot;:7       }     },     {       \&quot;time.start\&quot;:{         \&quot;$ge\&quot;:\&quot;2018-08-28T19:00\&quot;       }     }   ] } &#x60;&#x60;&#x60; 
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [String] :language_codes The comma-separated language codes corresponding to the languages of the profile that the user wishes to retrieve
    # @option opts [Float] :limit Number of results to return.
    # @option opts [Float] :offset Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  For Live API requests, the offset cannot be higher than 9,950. For Knowledge API the maximum limit is only enforced if a filter and/or sortBy parameter are given. 
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
    # @option opts [String] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages.  (default to 'false')
    # @option opts [String] :sort_by A list of fields and sort directions to order results by. Each ordering in the list should be in the format &#x60;{\&quot;field_name\&quot;, \&quot;sort_direction\&quot;}&#x60;, where &#x60;sort_direction&#x60; is either &#x60;ASCENDING&#x60; or &#x60;DESCENDING&#x60;.  For example, to order by &#x60;name&#x60; the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. To order by &#x60;name&#x60; and then &#x60;description&#x60;, the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;},{\&quot;description\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. 
    # @return [Array<(ListAllLanguageProfiles200Response, Integer, Hash)>] ListAllLanguageProfiles200Response data, response status code and response headers
    def list_all_language_profiles_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.list_all_language_profiles ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.list_all_language_profiles"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.list_all_language_profiles"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'entity_types'].nil? && opts[:'entity_types'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"entity_types"]" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'fields'].nil? && opts[:'fields'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"fields"]" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'filter'].nil? && opts[:'filter'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"filter"]" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'format'].nil? && opts[:'format'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"format"]" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'language_codes'].nil? && opts[:'language_codes'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"language_codes"]" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.list_all_language_profiles, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_token'].nil? && opts[:'page_token'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"page_token"]" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'rendered'].nil? && opts[:'rendered'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"rendered"]" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'sort_by'].nil? && opts[:'sort_by'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"sort_by"]" when calling KnowledgeManagerApi.list_all_language_profiles, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entityprofiles'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'entityTypes'] = opts[:'entity_types'] if !opts[:'entity_types'].nil?
      query_params[:'fields'] = opts[:'fields'] if !opts[:'fields'].nil?
      query_params[:'filter'] = opts[:'filter'] if !opts[:'filter'].nil?
      query_params[:'format'] = opts[:'format'] if !opts[:'format'].nil?
      query_params[:'languageCodes'] = opts[:'language_codes'] if !opts[:'language_codes'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'pageToken'] = opts[:'page_token'] if !opts[:'page_token'].nil?
      query_params[:'rendered'] = opts[:'rendered'] if !opts[:'rendered'].nil?
      query_params[:'sortBy'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListAllLanguageProfiles200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.list_all_language_profiles",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#list_all_language_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Assets: List
    # List assets in an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param format [String] Present if and only if type of subfield is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @option opts [Integer] :limit Number of results to return. (default to 100)
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
    # @return [AssetsResponse]
    def list_assets(account_id, v, format, opts = {})
      data, _status_code, _headers = list_assets_with_http_info(account_id, v, format, opts)
      data
    end

    # Assets: List
    # List assets in an account.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param format [String] Present if and only if type of subfield is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  (default to 0)
    # @option opts [Integer] :limit Number of results to return. (default to 100)
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
    # @return [Array<(AssetsResponse, Integer, Hash)>] AssetsResponse data, response status code and response headers
    def list_assets_with_http_info(account_id, v, format, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.list_assets ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.list_assets"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.list_assets"
      end
      # verify the required parameter 'format' is set
      if @api_client.config.client_side_validation && format.nil?
        fail ArgumentError, "Missing the required parameter 'format' when calling KnowledgeManagerApi.list_assets"
      end
      if @api_client.config.client_side_validation && format.to_s.length < 0
        fail ArgumentError, 'invalid value for "format" when calling KnowledgeManagerApi.list_assets, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.list_assets, must be smaller than or equal to 1000.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/assets'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'format'] = format
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'pageToken'] = opts[:'page_token'] if !opts[:'page_token'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'AssetsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.list_assets",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#list_assets\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entities: List
    # Retrieve a list of Entities within an account
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :filter This parameter represents one or more filtering conditions that are applied to the set of entities that would otherwise be returned. This parameter should be provided as a URL-encoded string containing a JSON object.  For example, if the filter JSON is &#x60;{\&quot;name\&quot;:{\&quot;$eq\&quot;:\&quot;John\&quot;}}&#x60;, then the filter param after URL-encoding will be: &#x60;filter&#x3D;%7B%22name%22%3A%7B%22%24eq%22%3A%22John%22%7D%7D&#x60;  **Basic Filter Structure**  The filter object at its core consists of a *matcher*, a *field*, and an *argument*.  For example, in the following filter JSON:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  &#x60;$eq&#x60; is the *matcher*, or filtering operation (equals, in this example),  &#x60;name&#x60; is the *field* being filtered by, and  &#x60;John&#x60; is *value* to be matched against.  **Combining Multiple Filters**  Multiple filters can be combined into one object using *combinators*. For example, the following filter JSON combines multiple filters using the combinator &#x60;$and&#x60;. &#x60;$or&#x60; is also supported. &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;firstName\&quot;:{         \&quot;$eq\&quot;:\&quot;John\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;$in\&quot;:[           \&quot;US\&quot;,           \&quot;GB\&quot;         ]       }     }   ] } &#x60;&#x60;&#x60;  **Filter Negation**  Certain filter types may be negated. For example:  &#x60;&#x60;&#x60; {   \&quot;$not\&quot; {     \&quot;name\&quot;:{       \&quot;$eq\&quot;:\&quot;John\&quot;     }   } } &#x60;&#x60;&#x60;  This can also be written more simply with a &#x60;!&#x60; in the &#x60;$eq&#x60; parameter. The following filter would have the same effect:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  **Filter Complement**  You can also search for the complement of a filter. This filter would match entities that do not contain \&quot;hello\&quot; in their descriptions, or do not have a description set. This is different from negation which can only match entities who have the negated field set to something.  &#x60;&#x60;&#x60; {   \&quot;$complement\&quot;:{     \&quot;description\&quot;:{       \&quot;$contains\&quot;:\&quot;hello\&quot;     }   } } &#x60;&#x60;&#x60;  **Addressing Subfields**  Subfields of fields can be addressed using the \&quot;dot\&quot; notation while filtering. For example, if you have a custom field called **&#x60;c_myCustomField&#x60;**:  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField\&quot;:{     \&quot;age\&quot;: 30,     \&quot;name\&quot;: \&quot;Jim\&quot;,   } } &#x60;&#x60;&#x60;  While filtering, subfields may be addressed using the \&quot;dot\&quot; notation.  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField.name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  Fields that are nested deeper may be addressed using dot notation, as well. For example, if **&#x60;name&#x60;** in the above example was a compound field with two subfields **&#x60;first&#x60;** and **&#x60;last&#x60;**, **&#x60;first&#x60;** may be addressed as **&#x60;c_myCustomField.name.first&#x60;**.  **Field Support**  Entity fields correspond to certain filter types, which support matchers. Going by the example above, the field **&#x60;name&#x60;** supports the &#x60;TEXT&#x60; filter type, which supports &#x60;$eq&#x60; (equals) and &#x60;$startsWith&#x60; (starts with).  **TEXT**  The &#x60;TEXT&#x60; filter type is supported for text fields. (e.g., **&#x60;name&#x60;**, **&#x60;countryCode&#x60;**)  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq (equals)&lt;/th&gt;     &lt;th&gt;      {       \&quot;countryCode\&quot;:{         \&quot;$eq\&quot;:\&quot;US\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;!$eq\&quot;:\&quot;US\&quot;       }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;Amazing\&quot; starts with \&quot;amaz\&quot;      {        \&quot;address.line1\&quot;:{           \&quot;$startsWith\&quot;: \&quot;Jo\&quot;        }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;firstName\&quot;:{         \&quot;$in\&quot;: [\&quot;John\&quot;, \&quot;Jimmy\&quot;]       }     }    Does not support negation. Negation can be mimicked by using an \&quot;OR\&quot; matcher, for example:      {       \&quot;$and\&quot;:[         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;John\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;Jimmy\&quot;           }         }       ]     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myString&#x60;**.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAny\&quot;:[           \&quot;sample1\&quot;, \&quot;sample2\&quot;         ]       }     }    This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAll\&quot;:[           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **BOOLEAN**   The BOOLEAN filter type is supported for boolean fields and Yes / No custom fields. &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;isFreeEvent\&quot;: {         \&quot;$eq\&quot;: true       }     }    For booleans, the filter takes a boolean value, not a string.   Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **STRUCT**  The STRUCT filter type is supported for compound fields with subfields.  *e.g., **&#x60;address&#x60;**, **&#x60;featuredMessage&#x60;**, fields of custom types*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$hasProperty&lt;/th&gt;     &lt;th&gt;    Matches if argument is a key (subfield) of field being filtered by. This filter type is useful for filtering by compound fields or to check if certain fields have a value set.      {       \&quot;address\&quot;: {         \&quot;$hasProperty\&quot;: \&quot;line1\&quot;       }     }    Note that if a given property of a compound field is not set, the filter will not match. For example, if &#x60;line1&#x60; of **&#x60;address&#x60;** is not set for an entity, then the above matcher will not match the entity.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **OPTION**  The OPTION filter type is supported for options custom fields and fields that have a predetermined list of valid values.   *e.g., **&#x60;eventStatus&#x60;**, **&#x60;gender&#x60;**, &#x60;SINGLE_OPTION&#x60; and &#x60;MULTI_OPTION&#x60; types of custom fields.*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Matching is case insensitive and insensitive to consecutive whitespace.    e.g., \&quot;XYZ 123\&quot; matches \&quot;xyz       123\&quot;      {       \&quot;eventStatus\&quot;: {         \&quot;$eq\&quot;: \&quot;SCHEDULED\&quot;       }     }    Supports negation. Negating &#x60;$eq&#x60; on the list will match any field that does not hold any of the provided values.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;      {       \&quot;eventStatus\&quot;: {         \&quot;$in\&quot;: [           \&quot;SCHEDULED\&quot;,           \&quot;POSTPONED\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values. For example:      {       \&quot;$and\&quot;: [         {           \&quot;eventStatus\&quot;:{             \&quot;!$eq\&quot;: \&quot;SCHEDULED\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;POSTPONED\&quot;           }         }       ]     }    &lt;/tr&gt; &lt;/table&gt;  **PHONE**  The PHONE filter type is supported for phone number fields only. PHONE will support the same matchers as TEXT, except that for &#x60;$eq&#x60;, the same phone number with or without calling code will match.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;+18187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;8187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;!$eq\&quot;:\&quot;9177076189\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;8187076189\&quot; starts with \&quot;818\&quot;      {       \&quot;mainPhone\&quot;:{         \&quot;$startsWith\&quot;: \&quot;818\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;mainPhone\&quot;:{         \&quot;$in\&quot;: [           \&quot;8185551616\&quot;,           \&quot;9171112211\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values.    &lt;/tr&gt; &lt;/table&gt;  **INTEGER, FLOAT, DATE, DATETIME, and TIME**  These filter types are strictly ordered -- therefore, they support the following matchers: - Equals - Less Than / Less Than or Equal To - Greater Than / Greater Than or Equal To  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Equals      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$eq\&quot;: \&quot;80\&quot;       }     }    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$lt&lt;/th&gt;     &lt;th&gt;    Less than      {       \&quot;time.start\&quot;: {         \&quot;$lt\&quot;: \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$gt&lt;/th&gt;     &lt;th&gt;    Greater than      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$gt\&quot;: \&quot;50\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$le&lt;/th&gt;     &lt;th&gt;    Less than or equal to      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$le\&quot;: \&quot;40\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$ge&lt;/th&gt;     &lt;th&gt;    Greater than or equal to      {       \&quot;time.end\&quot;: {         \&quot;$ge\&quot;:  \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;Combinations&lt;/th&gt;     &lt;th&gt;    While we do not support \&quot;between\&quot; in our filtering syntax, it is possible to combine multiple matchers for a result similar to an \&quot;and\&quot; operation:      {       \&quot;ageRange.maxValue : {         \&quot;$gt\&quot; : 10,         \&quot;$lt\&quot;: 20       }     }    &lt;/tr&gt; &lt;/table&gt;  **LIST OF TEXT**  Any field that has a list of valid values and supports any of the previously mentioned filter types will also support the &#x60;$contains&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eq\&quot;: \&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; EXACTLY matches any string within **&#x60;c_myStringList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if any one of \&quot;sample1\&quot; or \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;** . The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; AND \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;**. The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**.    Note that this matching is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }     This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAny&#x60; is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if BOTH \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in strings within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAll&#x60; is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$startsWith\&quot;:\&quot;sample\&quot;       }     }    This filter will match if any string within **&#x60;c_myStringList&#x60;** starts with \&quot;sample\&quot;.    Does not supports negation. Case Insensitive.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF BOOLEAN, OPTION, PHONE, INTEGER, FLOAT, DATE, DATETIME, OR TIME**  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myDateList\&quot;: {         \&quot;$eq\&quot;: \&quot;2019-01-01\&quot;       }     }     This filter will match if \&quot;2019-01-01\&quot; EXACTLY matches any date within **&#x60;c_myDateList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myIntegerList\&quot;: {         \&quot;$eqAny\&quot;: [1, 2]       }     }    This filter will match if 1 or 2 EXACTLY match any integer within **&#x60;c_myIntegerList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;2019-01-01\&quot; AND \&quot;2019-01-02\&quot; EXACTLY match a date within **&#x60;c_myDateList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF STRUCT**  Filtering on lists of struct types is a bit nuanced. Filtering can only be done on lists of structs of the SAME type. For example, if **&#x60;c_myStructList&#x60;** is a list of compound fields with the subfields **&#x60;age&#x60;** and **&#x60;name&#x60;**, then one can address the **&#x60;age&#x60;** properties of each field in **&#x60;c_myStructList&#x60;** as a flattened list of integers and filtering upon them. For example, the following filter:  &#x60;&#x60;&#x60; {   \&quot;c_myStructList.age\&quot;:{     \&quot;$eq\&quot;: 20   } } &#x60;&#x60;&#x60;  will match if any field in the list has an **&#x60;age&#x60;** property equal to 20. Similarly, any filter that can be applied to lists of integers could be applied to **&#x60;age&#x60;** in this case (&#x60;$eq&#x60;, &#x60;$eqAll&#x60;, &#x60;$eqAny&#x60;).   **HOURS**  By filtering on an hours field, you can find which entities are open or closed at a specified time or during a certain time range. All of these filters also take an entity’s holiday hours and reopen date into account.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openAt\&quot;:           \&quot;2019-01-06T13:45\&quot;       }     }     This filter would match entities open at the specified time.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedAt:           \&quot;2019-01-06T13:45\&quot;       }     }    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$openForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }     This filter would match only those entities that are open for the entire range between 2019-01-06T13:45 and 2019-01-06T15:00.      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;:           \&quot;2019-05-10\&quot;       }     }    This filter would match entities open for the entire 24 hour period on 2019-05-10.    You can also supply a year, a month, or an hour to filter for entities open for the entire year, month, or hour, respectively.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAnyOf\&quot;: {           \&quot;start\&quot;: \&quot;now\&quot;,           \&quot;end\&quot;: \&quot;now+2h\&quot;         }       }     }    This filter will match any entities that are open for at least a portion of the time range between now and two hours from now.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match only those entities that are closed for the entire given time range.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAnyOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match any entities that are closed for at least a portion of the given time range.   &lt;/tr&gt; &lt;/table&gt;   **Filtering by Dates and Times**  **Time zones**  The filtering language supports searching both in local time and within a certain time zone. Searching in local time will simply ignore the time zone on the target entities, while providing one will convert the zone of your queried time to the zone of the target entities.  To search in local time, simply provide the date or time without any zone: &#x60;2019-06-07T15:30&#x60; or &#x60;2019-06-07&#x60;.  To conduct a zoned search, provide the name of the time zone in brackets after the time, as it is shown in the tz database: &#x60;2019-06-07T15:30[America/New_York]&#x60; or &#x60;2019-06-06[America/Phoenix]&#x60;.   **Date and time types**  In addition to searching with dates and datetimes, you can also query with years, months, and hours. For example, the filter:  &#x60;&#x60;&#x60; {   \&quot;time.start\&quot;: {     \&quot;$eq\&quot;: \&quot;2018\&quot;   } } &#x60;&#x60;&#x60;  would match all start times in the year 2018. The same logic would apply for a month (&#x60;2019-05&#x60;), a date (&#x60;2019-05-01&#x60;), or an hour (&#x60;2019-05-01T06&#x60;).  These types also work with ordered searches. For example:  &#x60;&#x60;&#x60; {  \&quot;time.start\&quot;: {     \&quot;$lt\&quot;: \&quot;2018\&quot;  } } &#x60;&#x60;&#x60;  would match start times before 2018 (i.e., anything in 2017 or before). On the other hand, the same query with a &#x60;$le&#x60; matcher would include anything in or before 2018.  **\&quot;Now\&quot; and Date Math**  Instead of providing a static date or time, you can also use &#x60;now&#x60; in place of any date time. When you do so, the system will calculate the time when the query is made and conduct a zoned search.  In order to search for a future or past time relative to &#x60;now&#x60;, you can use date math. For example, you can enter &#x60;now+3h&#x60; or &#x60;now-1d&#x60;, which would mean 3 hours from now and 1 day ago, respectively. You can also add and subtract minutes (&#x60;m&#x60;), months (&#x60;M&#x60;), and years (&#x60;y&#x60;).  It is also possible to add or subtract time from a static date or datetime. Simply add &#x60;||&#x60; between the static value and any addition or subtraction. For example, &#x60;2019-02-03||+1d&#x60; would be the same as &#x60;2019-02-04&#x60;.  You can also convert date and time types to other types. For example, to convert the datetime &#x60;2019-05-06T22:15&#x60; to a date, use &#x60;2019-05-06T22:15||/d&#x60;. Doing so would yield the same result as using &#x60;2019-05-06&#x60;. This method also works with &#x60;now&#x60;: &#x60;now/d&#x60; will give you today’s date without the time.  **Filtering Across an Entity**  It is possible to search for a specific text string across all fields of an entity by using the &#x60;$anywhere&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$anywhere&lt;/th&gt;     &lt;th&gt;    Matches if the argument text appears anywhere in the entity (including subfields, structs, and lists)      {       \&quot;$anywhere\&quot;: \&quot;hello\&quot;     }    This filter will match all entities that contain the string \&quot;hello\&quot; or strings that begin with \&quot;hello\&quot;.    &lt;/tr&gt; &lt;/table&gt;  **Examples**  The following filter will match against entities that: - Are of type &#x60;event&#x60; (note that entity types can also be filtered by the **&#x60;entityTypes&#x60;** query parameter) - Have a name that starts with the text \&quot;Century\&quot; - Have a maximum age between 10 and 20 - Have a minimum age between 5 and 7 - Start after 7 PM (19:00) on August 28, 2018  &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;entityType\&quot;:{         \&quot;$eq\&quot;:\&quot;event\&quot;       }     },     {       \&quot;name\&quot;:{         \&quot;$startsWith\&quot;:\&quot;Century\&quot;       }     },     {       \&quot;ageRange.maxValue\&quot;:{         \&quot;$gt\&quot;:10,         \&quot;$lt\&quot;:20       }     },     {       \&quot;ageRange.minValue\&quot;:{         \&quot;$gt\&quot;:5,         \&quot;$lt\&quot;:7       }     },     {       \&quot;time.start\&quot;:{         \&quot;$ge\&quot;:\&quot;2018-08-28T19:00\&quot;       }     }   ] } &#x60;&#x60;&#x60; 
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [String] :languages Comma-separated list of language codes.  When present, the system will return Entities that have profiles in one or more of the provided languages. For each Location, only the first available profile from the provided list of languages will be returned. The keyword &#x60;\&quot;primary\&quot;&#x60; can be used to refer to a Location’s primary profile without providing a specific language code. If an Entity does not have profiles in any of the languages provided, that Entity&#39;s primary profile will be returned. 
    # @option opts [Float] :limit Number of results to return.
    # @option opts [Float] :offset Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  For Live API requests, the offset cannot be higher than 9,950. For Knowledge API the maximum limit is only enforced if a filter and/or sortBy parameter are given. 
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response.   - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot;   - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @option opts [String] :sort_by A list of fields and sort directions to order results by. Each ordering in the list should be in the format &#x60;{\&quot;field_name\&quot;, \&quot;sort_direction\&quot;}&#x60;, where &#x60;sort_direction&#x60; is either &#x60;ASCENDING&#x60; or &#x60;DESCENDING&#x60;.  For example, to order by &#x60;name&#x60; the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. To order by &#x60;name&#x60; and then &#x60;description&#x60;, the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;},{\&quot;description\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. 
    # @return [ListEntities200Response]
    def list_entities(account_id, v, opts = {})
      data, _status_code, _headers = list_entities_with_http_info(account_id, v, opts)
      data
    end

    # Entities: List
    # Retrieve a list of Entities within an account
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :filter This parameter represents one or more filtering conditions that are applied to the set of entities that would otherwise be returned. This parameter should be provided as a URL-encoded string containing a JSON object.  For example, if the filter JSON is &#x60;{\&quot;name\&quot;:{\&quot;$eq\&quot;:\&quot;John\&quot;}}&#x60;, then the filter param after URL-encoding will be: &#x60;filter&#x3D;%7B%22name%22%3A%7B%22%24eq%22%3A%22John%22%7D%7D&#x60;  **Basic Filter Structure**  The filter object at its core consists of a *matcher*, a *field*, and an *argument*.  For example, in the following filter JSON:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  &#x60;$eq&#x60; is the *matcher*, or filtering operation (equals, in this example),  &#x60;name&#x60; is the *field* being filtered by, and  &#x60;John&#x60; is *value* to be matched against.  **Combining Multiple Filters**  Multiple filters can be combined into one object using *combinators*. For example, the following filter JSON combines multiple filters using the combinator &#x60;$and&#x60;. &#x60;$or&#x60; is also supported. &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;firstName\&quot;:{         \&quot;$eq\&quot;:\&quot;John\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;$in\&quot;:[           \&quot;US\&quot;,           \&quot;GB\&quot;         ]       }     }   ] } &#x60;&#x60;&#x60;  **Filter Negation**  Certain filter types may be negated. For example:  &#x60;&#x60;&#x60; {   \&quot;$not\&quot; {     \&quot;name\&quot;:{       \&quot;$eq\&quot;:\&quot;John\&quot;     }   } } &#x60;&#x60;&#x60;  This can also be written more simply with a &#x60;!&#x60; in the &#x60;$eq&#x60; parameter. The following filter would have the same effect:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  **Filter Complement**  You can also search for the complement of a filter. This filter would match entities that do not contain \&quot;hello\&quot; in their descriptions, or do not have a description set. This is different from negation which can only match entities who have the negated field set to something.  &#x60;&#x60;&#x60; {   \&quot;$complement\&quot;:{     \&quot;description\&quot;:{       \&quot;$contains\&quot;:\&quot;hello\&quot;     }   } } &#x60;&#x60;&#x60;  **Addressing Subfields**  Subfields of fields can be addressed using the \&quot;dot\&quot; notation while filtering. For example, if you have a custom field called **&#x60;c_myCustomField&#x60;**:  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField\&quot;:{     \&quot;age\&quot;: 30,     \&quot;name\&quot;: \&quot;Jim\&quot;,   } } &#x60;&#x60;&#x60;  While filtering, subfields may be addressed using the \&quot;dot\&quot; notation.  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField.name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  Fields that are nested deeper may be addressed using dot notation, as well. For example, if **&#x60;name&#x60;** in the above example was a compound field with two subfields **&#x60;first&#x60;** and **&#x60;last&#x60;**, **&#x60;first&#x60;** may be addressed as **&#x60;c_myCustomField.name.first&#x60;**.  **Field Support**  Entity fields correspond to certain filter types, which support matchers. Going by the example above, the field **&#x60;name&#x60;** supports the &#x60;TEXT&#x60; filter type, which supports &#x60;$eq&#x60; (equals) and &#x60;$startsWith&#x60; (starts with).  **TEXT**  The &#x60;TEXT&#x60; filter type is supported for text fields. (e.g., **&#x60;name&#x60;**, **&#x60;countryCode&#x60;**)  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq (equals)&lt;/th&gt;     &lt;th&gt;      {       \&quot;countryCode\&quot;:{         \&quot;$eq\&quot;:\&quot;US\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;!$eq\&quot;:\&quot;US\&quot;       }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;Amazing\&quot; starts with \&quot;amaz\&quot;      {        \&quot;address.line1\&quot;:{           \&quot;$startsWith\&quot;: \&quot;Jo\&quot;        }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;firstName\&quot;:{         \&quot;$in\&quot;: [\&quot;John\&quot;, \&quot;Jimmy\&quot;]       }     }    Does not support negation. Negation can be mimicked by using an \&quot;OR\&quot; matcher, for example:      {       \&quot;$and\&quot;:[         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;John\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;Jimmy\&quot;           }         }       ]     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myString&#x60;**.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAny\&quot;:[           \&quot;sample1\&quot;, \&quot;sample2\&quot;         ]       }     }    This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAll\&quot;:[           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **BOOLEAN**   The BOOLEAN filter type is supported for boolean fields and Yes / No custom fields. &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;isFreeEvent\&quot;: {         \&quot;$eq\&quot;: true       }     }    For booleans, the filter takes a boolean value, not a string.   Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **STRUCT**  The STRUCT filter type is supported for compound fields with subfields.  *e.g., **&#x60;address&#x60;**, **&#x60;featuredMessage&#x60;**, fields of custom types*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$hasProperty&lt;/th&gt;     &lt;th&gt;    Matches if argument is a key (subfield) of field being filtered by. This filter type is useful for filtering by compound fields or to check if certain fields have a value set.      {       \&quot;address\&quot;: {         \&quot;$hasProperty\&quot;: \&quot;line1\&quot;       }     }    Note that if a given property of a compound field is not set, the filter will not match. For example, if &#x60;line1&#x60; of **&#x60;address&#x60;** is not set for an entity, then the above matcher will not match the entity.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **OPTION**  The OPTION filter type is supported for options custom fields and fields that have a predetermined list of valid values.   *e.g., **&#x60;eventStatus&#x60;**, **&#x60;gender&#x60;**, &#x60;SINGLE_OPTION&#x60; and &#x60;MULTI_OPTION&#x60; types of custom fields.*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Matching is case insensitive and insensitive to consecutive whitespace.    e.g., \&quot;XYZ 123\&quot; matches \&quot;xyz       123\&quot;      {       \&quot;eventStatus\&quot;: {         \&quot;$eq\&quot;: \&quot;SCHEDULED\&quot;       }     }    Supports negation. Negating &#x60;$eq&#x60; on the list will match any field that does not hold any of the provided values.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;      {       \&quot;eventStatus\&quot;: {         \&quot;$in\&quot;: [           \&quot;SCHEDULED\&quot;,           \&quot;POSTPONED\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values. For example:      {       \&quot;$and\&quot;: [         {           \&quot;eventStatus\&quot;:{             \&quot;!$eq\&quot;: \&quot;SCHEDULED\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;POSTPONED\&quot;           }         }       ]     }    &lt;/tr&gt; &lt;/table&gt;  **PHONE**  The PHONE filter type is supported for phone number fields only. PHONE will support the same matchers as TEXT, except that for &#x60;$eq&#x60;, the same phone number with or without calling code will match.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;+18187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;8187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;!$eq\&quot;:\&quot;9177076189\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;8187076189\&quot; starts with \&quot;818\&quot;      {       \&quot;mainPhone\&quot;:{         \&quot;$startsWith\&quot;: \&quot;818\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;mainPhone\&quot;:{         \&quot;$in\&quot;: [           \&quot;8185551616\&quot;,           \&quot;9171112211\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values.    &lt;/tr&gt; &lt;/table&gt;  **INTEGER, FLOAT, DATE, DATETIME, and TIME**  These filter types are strictly ordered -- therefore, they support the following matchers: - Equals - Less Than / Less Than or Equal To - Greater Than / Greater Than or Equal To  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Equals      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$eq\&quot;: \&quot;80\&quot;       }     }    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$lt&lt;/th&gt;     &lt;th&gt;    Less than      {       \&quot;time.start\&quot;: {         \&quot;$lt\&quot;: \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$gt&lt;/th&gt;     &lt;th&gt;    Greater than      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$gt\&quot;: \&quot;50\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$le&lt;/th&gt;     &lt;th&gt;    Less than or equal to      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$le\&quot;: \&quot;40\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$ge&lt;/th&gt;     &lt;th&gt;    Greater than or equal to      {       \&quot;time.end\&quot;: {         \&quot;$ge\&quot;:  \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;Combinations&lt;/th&gt;     &lt;th&gt;    While we do not support \&quot;between\&quot; in our filtering syntax, it is possible to combine multiple matchers for a result similar to an \&quot;and\&quot; operation:      {       \&quot;ageRange.maxValue : {         \&quot;$gt\&quot; : 10,         \&quot;$lt\&quot;: 20       }     }    &lt;/tr&gt; &lt;/table&gt;  **LIST OF TEXT**  Any field that has a list of valid values and supports any of the previously mentioned filter types will also support the &#x60;$contains&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eq\&quot;: \&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; EXACTLY matches any string within **&#x60;c_myStringList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if any one of \&quot;sample1\&quot; or \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;** . The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; AND \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;**. The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**.    Note that this matching is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }     This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAny&#x60; is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if BOTH \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in strings within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAll&#x60; is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$startsWith\&quot;:\&quot;sample\&quot;       }     }    This filter will match if any string within **&#x60;c_myStringList&#x60;** starts with \&quot;sample\&quot;.    Does not supports negation. Case Insensitive.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF BOOLEAN, OPTION, PHONE, INTEGER, FLOAT, DATE, DATETIME, OR TIME**  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myDateList\&quot;: {         \&quot;$eq\&quot;: \&quot;2019-01-01\&quot;       }     }     This filter will match if \&quot;2019-01-01\&quot; EXACTLY matches any date within **&#x60;c_myDateList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myIntegerList\&quot;: {         \&quot;$eqAny\&quot;: [1, 2]       }     }    This filter will match if 1 or 2 EXACTLY match any integer within **&#x60;c_myIntegerList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;2019-01-01\&quot; AND \&quot;2019-01-02\&quot; EXACTLY match a date within **&#x60;c_myDateList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF STRUCT**  Filtering on lists of struct types is a bit nuanced. Filtering can only be done on lists of structs of the SAME type. For example, if **&#x60;c_myStructList&#x60;** is a list of compound fields with the subfields **&#x60;age&#x60;** and **&#x60;name&#x60;**, then one can address the **&#x60;age&#x60;** properties of each field in **&#x60;c_myStructList&#x60;** as a flattened list of integers and filtering upon them. For example, the following filter:  &#x60;&#x60;&#x60; {   \&quot;c_myStructList.age\&quot;:{     \&quot;$eq\&quot;: 20   } } &#x60;&#x60;&#x60;  will match if any field in the list has an **&#x60;age&#x60;** property equal to 20. Similarly, any filter that can be applied to lists of integers could be applied to **&#x60;age&#x60;** in this case (&#x60;$eq&#x60;, &#x60;$eqAll&#x60;, &#x60;$eqAny&#x60;).   **HOURS**  By filtering on an hours field, you can find which entities are open or closed at a specified time or during a certain time range. All of these filters also take an entity’s holiday hours and reopen date into account.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openAt\&quot;:           \&quot;2019-01-06T13:45\&quot;       }     }     This filter would match entities open at the specified time.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedAt:           \&quot;2019-01-06T13:45\&quot;       }     }    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$openForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }     This filter would match only those entities that are open for the entire range between 2019-01-06T13:45 and 2019-01-06T15:00.      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;:           \&quot;2019-05-10\&quot;       }     }    This filter would match entities open for the entire 24 hour period on 2019-05-10.    You can also supply a year, a month, or an hour to filter for entities open for the entire year, month, or hour, respectively.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAnyOf\&quot;: {           \&quot;start\&quot;: \&quot;now\&quot;,           \&quot;end\&quot;: \&quot;now+2h\&quot;         }       }     }    This filter will match any entities that are open for at least a portion of the time range between now and two hours from now.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match only those entities that are closed for the entire given time range.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAnyOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match any entities that are closed for at least a portion of the given time range.   &lt;/tr&gt; &lt;/table&gt;   **Filtering by Dates and Times**  **Time zones**  The filtering language supports searching both in local time and within a certain time zone. Searching in local time will simply ignore the time zone on the target entities, while providing one will convert the zone of your queried time to the zone of the target entities.  To search in local time, simply provide the date or time without any zone: &#x60;2019-06-07T15:30&#x60; or &#x60;2019-06-07&#x60;.  To conduct a zoned search, provide the name of the time zone in brackets after the time, as it is shown in the tz database: &#x60;2019-06-07T15:30[America/New_York]&#x60; or &#x60;2019-06-06[America/Phoenix]&#x60;.   **Date and time types**  In addition to searching with dates and datetimes, you can also query with years, months, and hours. For example, the filter:  &#x60;&#x60;&#x60; {   \&quot;time.start\&quot;: {     \&quot;$eq\&quot;: \&quot;2018\&quot;   } } &#x60;&#x60;&#x60;  would match all start times in the year 2018. The same logic would apply for a month (&#x60;2019-05&#x60;), a date (&#x60;2019-05-01&#x60;), or an hour (&#x60;2019-05-01T06&#x60;).  These types also work with ordered searches. For example:  &#x60;&#x60;&#x60; {  \&quot;time.start\&quot;: {     \&quot;$lt\&quot;: \&quot;2018\&quot;  } } &#x60;&#x60;&#x60;  would match start times before 2018 (i.e., anything in 2017 or before). On the other hand, the same query with a &#x60;$le&#x60; matcher would include anything in or before 2018.  **\&quot;Now\&quot; and Date Math**  Instead of providing a static date or time, you can also use &#x60;now&#x60; in place of any date time. When you do so, the system will calculate the time when the query is made and conduct a zoned search.  In order to search for a future or past time relative to &#x60;now&#x60;, you can use date math. For example, you can enter &#x60;now+3h&#x60; or &#x60;now-1d&#x60;, which would mean 3 hours from now and 1 day ago, respectively. You can also add and subtract minutes (&#x60;m&#x60;), months (&#x60;M&#x60;), and years (&#x60;y&#x60;).  It is also possible to add or subtract time from a static date or datetime. Simply add &#x60;||&#x60; between the static value and any addition or subtraction. For example, &#x60;2019-02-03||+1d&#x60; would be the same as &#x60;2019-02-04&#x60;.  You can also convert date and time types to other types. For example, to convert the datetime &#x60;2019-05-06T22:15&#x60; to a date, use &#x60;2019-05-06T22:15||/d&#x60;. Doing so would yield the same result as using &#x60;2019-05-06&#x60;. This method also works with &#x60;now&#x60;: &#x60;now/d&#x60; will give you today’s date without the time.  **Filtering Across an Entity**  It is possible to search for a specific text string across all fields of an entity by using the &#x60;$anywhere&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$anywhere&lt;/th&gt;     &lt;th&gt;    Matches if the argument text appears anywhere in the entity (including subfields, structs, and lists)      {       \&quot;$anywhere\&quot;: \&quot;hello\&quot;     }    This filter will match all entities that contain the string \&quot;hello\&quot; or strings that begin with \&quot;hello\&quot;.    &lt;/tr&gt; &lt;/table&gt;  **Examples**  The following filter will match against entities that: - Are of type &#x60;event&#x60; (note that entity types can also be filtered by the **&#x60;entityTypes&#x60;** query parameter) - Have a name that starts with the text \&quot;Century\&quot; - Have a maximum age between 10 and 20 - Have a minimum age between 5 and 7 - Start after 7 PM (19:00) on August 28, 2018  &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;entityType\&quot;:{         \&quot;$eq\&quot;:\&quot;event\&quot;       }     },     {       \&quot;name\&quot;:{         \&quot;$startsWith\&quot;:\&quot;Century\&quot;       }     },     {       \&quot;ageRange.maxValue\&quot;:{         \&quot;$gt\&quot;:10,         \&quot;$lt\&quot;:20       }     },     {       \&quot;ageRange.minValue\&quot;:{         \&quot;$gt\&quot;:5,         \&quot;$lt\&quot;:7       }     },     {       \&quot;time.start\&quot;:{         \&quot;$ge\&quot;:\&quot;2018-08-28T19:00\&quot;       }     }   ] } &#x60;&#x60;&#x60; 
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [String] :languages Comma-separated list of language codes.  When present, the system will return Entities that have profiles in one or more of the provided languages. For each Location, only the first available profile from the provided list of languages will be returned. The keyword &#x60;\&quot;primary\&quot;&#x60; can be used to refer to a Location’s primary profile without providing a specific language code. If an Entity does not have profiles in any of the languages provided, that Entity&#39;s primary profile will be returned. 
    # @option opts [Float] :limit Number of results to return.
    # @option opts [Float] :offset Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  For Live API requests, the offset cannot be higher than 9,950. For Knowledge API the maximum limit is only enforced if a filter and/or sortBy parameter are given. 
    # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
    # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response.   - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot;   - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot;  (default to false)
    # @option opts [String] :sort_by A list of fields and sort directions to order results by. Each ordering in the list should be in the format &#x60;{\&quot;field_name\&quot;, \&quot;sort_direction\&quot;}&#x60;, where &#x60;sort_direction&#x60; is either &#x60;ASCENDING&#x60; or &#x60;DESCENDING&#x60;.  For example, to order by &#x60;name&#x60; the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. To order by &#x60;name&#x60; and then &#x60;description&#x60;, the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;},{\&quot;description\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. 
    # @return [Array<(ListEntities200Response, Integer, Hash)>] ListEntities200Response data, response status code and response headers
    def list_entities_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.list_entities ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.list_entities"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.list_entities"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'entity_types'].nil? && opts[:'entity_types'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"entity_types"]" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'fields'].nil? && opts[:'fields'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"fields"]" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'filter'].nil? && opts[:'filter'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"filter"]" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'format'].nil? && opts[:'format'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"format"]" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'languages'].nil? && opts[:'languages'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"languages"]" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.list_entities, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_token'].nil? && opts[:'page_token'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"page_token"]" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'sort_by'].nil? && opts[:'sort_by'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"sort_by"]" when calling KnowledgeManagerApi.list_entities, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entities'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'entityTypes'] = opts[:'entity_types'] if !opts[:'entity_types'].nil?
      query_params[:'fields'] = opts[:'fields'] if !opts[:'fields'].nil?
      query_params[:'filter'] = opts[:'filter'] if !opts[:'filter'].nil?
      query_params[:'format'] = opts[:'format'] if !opts[:'format'].nil?
      query_params[:'languages'] = opts[:'languages'] if !opts[:'languages'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'pageToken'] = opts[:'page_token'] if !opts[:'page_token'].nil?
      query_params[:'resolvePlaceholders'] = opts[:'resolve_placeholders'] if !opts[:'resolve_placeholders'].nil?
      query_params[:'sortBy'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListEntities200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.list_entities",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#list_entities\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entity Language Profiles: List
    # Retrieve Language Profiles for an Entity  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [String] :language_codes The comma-separated language codes corresponding to the languages of the profile that the user wishes to retrieve
    # @option opts [String] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages.  (default to 'false')
    # @return [ListLanguageProfiles200Response]
    def list_language_profiles(account_id, entity_id, v, opts = {})
      data, _status_code, _headers = list_language_profiles_with_http_info(account_id, entity_id, v, opts)
      data
    end

    # Entity Language Profiles: List
    # Retrieve Language Profiles for an Entity  * If the **&#x60;v&#x60;** parameter is before &#x60;20190103&#x60;: by default, returned alternate Language Profiles include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields * If the **&#x60;v&#x60;** parameter is &#x60;20190103&#x60; or later: by default, returned alternate Language Profiles do not include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields. However, these fields can still be retrieved if the **&#x60;rendered&#x60;** parameter in the request is set to &#x60;true&#x60;. 
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
    # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
    # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60;  (default to 'markdown')
    # @option opts [String] :language_codes The comma-separated language codes corresponding to the languages of the profile that the user wishes to retrieve
    # @option opts [String] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages.  (default to 'false')
    # @return [Array<(ListLanguageProfiles200Response, Integer, Hash)>] ListLanguageProfiles200Response data, response status code and response headers
    def list_language_profiles_with_http_info(account_id, entity_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.list_language_profiles ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.list_language_profiles"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.list_language_profiles, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_id' is set
      if @api_client.config.client_side_validation && entity_id.nil?
        fail ArgumentError, "Missing the required parameter 'entity_id' when calling KnowledgeManagerApi.list_language_profiles"
      end
      if @api_client.config.client_side_validation && entity_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "entity_id" when calling KnowledgeManagerApi.list_language_profiles, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.list_language_profiles"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.list_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'entity_types'].nil? && opts[:'entity_types'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"entity_types"]" when calling KnowledgeManagerApi.list_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'fields'].nil? && opts[:'fields'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"fields"]" when calling KnowledgeManagerApi.list_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'format'].nil? && opts[:'format'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"format"]" when calling KnowledgeManagerApi.list_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'language_codes'].nil? && opts[:'language_codes'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"language_codes"]" when calling KnowledgeManagerApi.list_language_profiles, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'rendered'].nil? && opts[:'rendered'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"rendered"]" when calling KnowledgeManagerApi.list_language_profiles, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entityprofiles/{entityId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'entityId' + '}', CGI.escape(entity_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'entityTypes'] = opts[:'entity_types'] if !opts[:'entity_types'].nil?
      query_params[:'fields'] = opts[:'fields'] if !opts[:'fields'].nil?
      query_params[:'format'] = opts[:'format'] if !opts[:'format'].nil?
      query_params[:'languageCodes'] = opts[:'language_codes'] if !opts[:'language_codes'].nil?
      query_params[:'rendered'] = opts[:'rendered'] if !opts[:'rendered'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListLanguageProfiles200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.list_language_profiles",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#list_language_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Locations (Legacy): Search
    # Get multiple Locations (primary profiles only) that match provided filters.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset Number of results to skip. Used to page through results. (default to 0)
    # @option opts [String] :filters A set of filters that is applied to the set of locations that would otherwise be returned. Should be provided as a URL-encoded string containing a JSON array. The array should have one or more filter objects defined. All filter objects will apply as an intersection (i.e., AND). Field names reference Location fields, as well as custom fields using the format &#x60;custom###&#x60;, where \&quot;###\&quot; is the custom field’s **&#x60;id&#x60;**.  For example, to provide a filter that would match location names containing the word \&quot;gourmet\&quot;, the filter parameter would be &#x60;[{\&quot;name\&quot;:{\&quot;contains\&quot;:[\&quot;gourmet\&quot;]}}]&#x60;, which URL-encoded would be &#x60;%5B%7B%22name%22%3A%7B%22contains%22%3A%5B%22gourmet%22%5D%7D%7D%5D&#x60;.  NOTE: \&quot;x\&quot;, \&quot;xx\&quot;, and \&quot;xxx\&quot; are reserved keywords that, when passed in a &#x60;contains&#x60; matcher for a Full or Text filter, will cause that filter to match on all locations.  The filter types are the following. Note there may be multiple available specifications for a given filter type:  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Filter Type&lt;/th&gt;     &lt;th&gt;Syntax&lt;/th&gt;     &lt;th&gt;Description&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Full&lt;/td&gt;     &lt;td&gt;fieldName: {contains: $search}&lt;/td&gt;     &lt;td&gt;$search is the search string&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$search,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [contains,doesNotContain,startsWith,equalTo], $search is an array of search strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [empty,notEmpty]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $value}&lt;/td&gt;     &lt;td&gt;$type is one of [eq,lt,gt,le,ge], $value is the numeric value&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$value1, $value2]}&lt;/td&gt;     &lt;td&gt;$type is one of [between], $value1 and $value2 are numeric values&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $value}&lt;/td&gt;     &lt;td&gt;$type is one of [eq,lt,gt,le,ge], $value is a string of \&quot;YYYY-MM-DD\&quot; formatted date&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [empty,notEmpty]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$value1, $value2]}&lt;/td&gt;     &lt;td&gt;$type is one of [between], $value1 and $value2 are strings of \&quot;YYYY-MM-DD\&quot; formatted date&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of numeric category IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [none]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Assets&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of numeric category IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Assets&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [none]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Country&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$country,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $country is an array of country code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;PrimaryLanguage&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$language,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $language is an array of language code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;AlternateLanguage&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$language,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes, notIncludes], $language is an array of language code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$string,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $string is an array of strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$string,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $string is an array of strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;LocationType&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $id is an array of location type IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [true,false]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Option&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $id}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $id is an option ID (For single option custom fields)&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Option&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of option IDs, combined with OR (For multi option custom fields)&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: [$id,...]&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: $id&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID, $type is one of [&#39;isIn&#39;, &#39;isNotIn&#39;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Labels&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of label IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt;  The following fields can be specified in the request (Field name/Filter Type/Example(s)):  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Field Name&lt;/th&gt;     &lt;th&gt;Filter Type&lt;/th&gt;     &lt;th&gt;Example(s)&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;location&lt;/td&gt;     &lt;td&gt;Full&lt;/td&gt;     &lt;td&gt;\&quot;location\&quot;: {\&quot;contains\&quot;: \&quot;Atlanta\&quot;}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;name&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;name\&quot;: {\&quot;startsWith\&quot;: [\&quot;Guitar\&quot;]}, \&quot;name\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;address&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;address\&quot;: {\&quot;startsWith\&quot;: [\&quot;South\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;address2&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;address2\&quot;: {\&quot;contains\&quot;: [\&quot;Suite\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;city&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;city\&quot;: {\&quot;contains\&quot;: [\&quot;Atlanta\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;state&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;state\&quot;: {\&quot;contains\&quot;: [\&quot;AK\&quot;,\&quot;VA\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;zip&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;zip\&quot;: {\&quot;contains\&quot;: [\&quot;M5K 7QB\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;phones&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;phones\&quot;: {\&quot;startsWith\&quot;: [\&quot;703\&quot;,\&quot;571\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;specialOffer&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;specialOffer\&quot;: \&quot;notEmpty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;emails&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;emails\&quot;: {\&quot;doesNotContain\&quot;: [\&quot;@yext.com\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;website&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;website\&quot;: {\&quot;equalTo\&quot;: [\&quot;https://www.yext.com/\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;categories&lt;/td&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;\&quot;categories\&quot;: {\&quot;includes\&quot;: [23,755,34]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;closed&lt;/td&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;\&quot;closed\&quot;: true&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;storeId&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;storeId\&quot;: {\&quot;equalTo\&quot;: [\&quot;MCD0001\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;countryCode&lt;/td&gt;     &lt;td&gt;Country&lt;/td&gt;     &lt;td&gt;\&quot;countryCode\&quot;: {\&quot;notIncludes\&quot;: [\&quot;US\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;products&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;products\&quot;: {\&quot;startsWith\&quot;: [\&quot;Burger\&quot;,\&quot;Fries\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;services&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;services\&quot;: {\&quot;contains\&quot;: [\&quot;Manicures\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;specialities&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;services\&quot;: \&quot;notEmpty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;associations&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;associations\&quot;: \&quot;empty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;brands&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;brands\&quot;: {\&quot;equalTo\&quot;: [\&quot;North Face\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;languages&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;languages\&quot;: {\&quot;equalTo\&quot;: [\&quot;English\&quot;,\&quot;Spanish\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;keywords&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;keywords\&quot;: {\&quot;startsWith\&quot;: [\&quot;Franchise\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;menuIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;menuIds\&quot;: {\&quot;includes\&quot;: [\&quot;m-23\&quot;,\&quot;755\&quot;,\&quot;menu34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;productListIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;productListIds\&quot;: {\&quot;notIncludes\&quot;: [\&quot;pl-2\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;calendarIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;calendarIds\&quot;: {\&quot;notIncludes\&quot;: [\&quot;cal34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;bioIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;bioIds\&quot;: {\&quot;includes\&quot;: [\&quot;b23\&quot;,\&quot;34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;custom###&lt;/td&gt;     &lt;td&gt;Text (for Multiline Text, URL, Text List, and Text Custom Fields), Number, Date, Bool, or Option&lt;/td&gt;     &lt;td&gt;\&quot;custom123\&quot;: {\&quot;equalTo\&quot;: [\&quot;asdf\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;folder&lt;/td&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;\&quot;folder\&quot;: 123, \&quot;folder\&quot;: [123,456]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;primary_language&lt;/td&gt;     &lt;td&gt;PrimaryLanguage&lt;/td&gt;     &lt;td&gt;\&quot;primary_language\&quot;: {\&quot;is\&quot;: \&quot;fr_CA\&quot;}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;alternateProfileLanguage&lt;/td&gt;     &lt;td&gt;AlternateLanguage&lt;/td&gt;     &lt;td&gt;\&quot;alternateProfileLanguage\&quot;: {\&quot;includes\&quot;: [\&quot;en\&quot;, \&quot;fr\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;npi&lt;/td&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;\&quot;npi\&quot;: {\&quot;is\&quot;: [\&quot;1234567890\&quot;, \&quot;1111111111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;conditionsTreated&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;conditionsTreated\&quot;: {\&quot;startsWith\&quot;: [\&quot;Influenza\&quot;]}, \&quot;conditionsTreated\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;lastUpdated&lt;/td&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;\&quot;lastUpdated\&quot;: {\&quot;eq\&quot;: \&quot;2018-01-01\&quot;}, \&quot;lastUpdated\&quot;: {\&quot;between\&quot;: [\&quot;2017-01-01\&quot;, \&quot;2018-01-01\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;fieldsWithData&lt;/td&gt;     &lt;td&gt;Fields&lt;/td&gt;     &lt;td&gt;\&quot;fieldsWithData\&quot;: [\&quot;email\&quot;, \&quot;hours\&quot;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;fieldsWithoutData&lt;/td&gt;     &lt;td&gt;Fields&lt;/td&gt;     &lt;td&gt;\&quot;fieldsWithoutData\&quot;: [\&quot;logo\&quot;, \&quot;video\&quot;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;reviewCount&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;review_count\&quot;: {\&quot;gt\&quot;: 1}, \&quot;review_count \&quot;: {\&quot;lt\&quot;: 10}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;averageRating&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;averageRating\&quot;: {\&quot;lt\&quot;: 3}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;locationType&lt;/td&gt;     &lt;td&gt;LocationType&lt;/td&gt;     &lt;td&gt;\&quot;locationType\&quot;: {\&quot;is\&quot;: [1]}, \&quot;locationType\&quot;: {\&quot;isNot\&quot;: [123]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;gender&lt;/td&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;\&quot;gender\&quot;: {\&quot;is\&quot;: [\&quot;FEMALE\&quot;]}, \&quot;gender\&quot;: {\&quot;isNot\&quot;: [\&quot;MALE\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;degrees&lt;/td&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;\&quot;degrees\&quot;: {\&quot;includes\&quot;: [\&quot;MD\&quot;]}, \&quot;degrees\&quot;: {\&quot;notIncludes\&quot;: [\&quot;PHD\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;experiences&lt;/td&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;\&quot;experiences\&quot;: {\&quot;includes\&quot;: [\&quot;FELLOWSHIP\&quot;]}, \&quot;experiences\&quot;: {\&quot;notIncludes\&quot;:[\&quot;INTERNSHIP\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;yearCompleted&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;yearCompleted\&quot;: {\&quot;gt\&quot;: 2000}, \&quot;yearCompleted\&quot;: {\&quot;lt\&quot;: 2015}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;acceptingNewPatients&lt;/td&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;\&quot;acceptingNewPatients\&quot;: true&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;firstName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;firstName\&quot;: {\&quot;startsWith\&quot;: [\&quot;David\&quot;]}, \&quot;firstName\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;middleName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;middleName\&quot;: {\&quot;startsWith\&quot;: [\&quot;P\&quot;]}, \&quot;middleName\&quot;: {\&quot;contains\&quot;: [\&quot;N\&quot;,\&quot;E\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;lastName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;lastName\&quot;: {\&quot;startsWith\&quot;: [\&quot;Sm\&quot;]}, \&quot;lastName\&quot;: {\&quot;contains\&quot;: [\&quot;Y\&quot;,\&quot;Z\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;officeName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;officeName\&quot;: {\&quot;startsWith\&quot;: [\&quot;Chiropractic\&quot;]}, \&quot;officeName\&quot;: {\&quot;contains\&quot;:[\&quot;Center\&quot;,\&quot;P\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;certifications&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;certifications\&quot;: {\&quot;contains\&quot;: [\&quot;Radiation Oncology\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;institutionName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;institutionName\&quot;: {\&quot;startsWith\&quot;: [\&quot;New York\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;insuranceAccepted&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;insuranceAccepted\&quot;: {\&quot;startsWith\&quot;: [\&quot;United\&quot;]}, \&quot;insuranceAccepted\&quot;:{\&quot;contains\&quot;: [\&quot;C\&quot;,\&quot;Health\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;admittingHospitals&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;admittingHospitals\&quot;: {\&quot;startsWith\&quot;: [\&quot;Children&#39;s\&quot;]}, \&quot;admittingHospitals\&quot;:{\&quot;contains\&quot;: [\&quot;Medical\&quot;,\&quot;University\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;subscriptions&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;subscriptions\&quot;: {\&quot;notIncludes\&quot;: [\&quot;123\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;facebookAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;facebookAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;foursquareAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;foursquareAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;googleplusAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;googleplusAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;labels&lt;/td&gt;     &lt;td&gt;Labels&lt;/td&gt;     &lt;td&gt;\&quot;labels\&quot;: {\&quot;includes\&quot;: [1, 100]}&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; 
    # @return [LocationsSearchResponse]
    def search_locations(account_id, v, opts = {})
      data, _status_code, _headers = search_locations_with_http_info(account_id, v, opts)
      data
    end

    # Locations (Legacy): Search
    # Get multiple Locations (primary profiles only) that match provided filters.
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of results to return. (default to 10)
    # @option opts [Integer] :offset Number of results to skip. Used to page through results. (default to 0)
    # @option opts [String] :filters A set of filters that is applied to the set of locations that would otherwise be returned. Should be provided as a URL-encoded string containing a JSON array. The array should have one or more filter objects defined. All filter objects will apply as an intersection (i.e., AND). Field names reference Location fields, as well as custom fields using the format &#x60;custom###&#x60;, where \&quot;###\&quot; is the custom field’s **&#x60;id&#x60;**.  For example, to provide a filter that would match location names containing the word \&quot;gourmet\&quot;, the filter parameter would be &#x60;[{\&quot;name\&quot;:{\&quot;contains\&quot;:[\&quot;gourmet\&quot;]}}]&#x60;, which URL-encoded would be &#x60;%5B%7B%22name%22%3A%7B%22contains%22%3A%5B%22gourmet%22%5D%7D%7D%5D&#x60;.  NOTE: \&quot;x\&quot;, \&quot;xx\&quot;, and \&quot;xxx\&quot; are reserved keywords that, when passed in a &#x60;contains&#x60; matcher for a Full or Text filter, will cause that filter to match on all locations.  The filter types are the following. Note there may be multiple available specifications for a given filter type:  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Filter Type&lt;/th&gt;     &lt;th&gt;Syntax&lt;/th&gt;     &lt;th&gt;Description&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Full&lt;/td&gt;     &lt;td&gt;fieldName: {contains: $search}&lt;/td&gt;     &lt;td&gt;$search is the search string&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$search,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [contains,doesNotContain,startsWith,equalTo], $search is an array of search strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [empty,notEmpty]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $value}&lt;/td&gt;     &lt;td&gt;$type is one of [eq,lt,gt,le,ge], $value is the numeric value&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$value1, $value2]}&lt;/td&gt;     &lt;td&gt;$type is one of [between], $value1 and $value2 are numeric values&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $value}&lt;/td&gt;     &lt;td&gt;$type is one of [eq,lt,gt,le,ge], $value is a string of \&quot;YYYY-MM-DD\&quot; formatted date&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [empty,notEmpty]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$value1, $value2]}&lt;/td&gt;     &lt;td&gt;$type is one of [between], $value1 and $value2 are strings of \&quot;YYYY-MM-DD\&quot; formatted date&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of numeric category IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [none]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Assets&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of numeric category IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Assets&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [none]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Country&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$country,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $country is an array of country code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;PrimaryLanguage&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$language,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $language is an array of language code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;AlternateLanguage&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$language,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes, notIncludes], $language is an array of language code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$string,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $string is an array of strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$string,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $string is an array of strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;LocationType&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $id is an array of location type IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [true,false]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Option&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $id}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $id is an option ID (For single option custom fields)&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Option&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of option IDs, combined with OR (For multi option custom fields)&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: [$id,...]&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: $id&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID, $type is one of [&#39;isIn&#39;, &#39;isNotIn&#39;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Labels&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of label IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt;  The following fields can be specified in the request (Field name/Filter Type/Example(s)):  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Field Name&lt;/th&gt;     &lt;th&gt;Filter Type&lt;/th&gt;     &lt;th&gt;Example(s)&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;location&lt;/td&gt;     &lt;td&gt;Full&lt;/td&gt;     &lt;td&gt;\&quot;location\&quot;: {\&quot;contains\&quot;: \&quot;Atlanta\&quot;}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;name&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;name\&quot;: {\&quot;startsWith\&quot;: [\&quot;Guitar\&quot;]}, \&quot;name\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;address&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;address\&quot;: {\&quot;startsWith\&quot;: [\&quot;South\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;address2&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;address2\&quot;: {\&quot;contains\&quot;: [\&quot;Suite\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;city&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;city\&quot;: {\&quot;contains\&quot;: [\&quot;Atlanta\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;state&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;state\&quot;: {\&quot;contains\&quot;: [\&quot;AK\&quot;,\&quot;VA\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;zip&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;zip\&quot;: {\&quot;contains\&quot;: [\&quot;M5K 7QB\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;phones&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;phones\&quot;: {\&quot;startsWith\&quot;: [\&quot;703\&quot;,\&quot;571\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;specialOffer&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;specialOffer\&quot;: \&quot;notEmpty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;emails&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;emails\&quot;: {\&quot;doesNotContain\&quot;: [\&quot;@yext.com\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;website&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;website\&quot;: {\&quot;equalTo\&quot;: [\&quot;https://www.yext.com/\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;categories&lt;/td&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;\&quot;categories\&quot;: {\&quot;includes\&quot;: [23,755,34]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;closed&lt;/td&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;\&quot;closed\&quot;: true&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;storeId&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;storeId\&quot;: {\&quot;equalTo\&quot;: [\&quot;MCD0001\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;countryCode&lt;/td&gt;     &lt;td&gt;Country&lt;/td&gt;     &lt;td&gt;\&quot;countryCode\&quot;: {\&quot;notIncludes\&quot;: [\&quot;US\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;products&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;products\&quot;: {\&quot;startsWith\&quot;: [\&quot;Burger\&quot;,\&quot;Fries\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;services&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;services\&quot;: {\&quot;contains\&quot;: [\&quot;Manicures\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;specialities&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;services\&quot;: \&quot;notEmpty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;associations&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;associations\&quot;: \&quot;empty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;brands&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;brands\&quot;: {\&quot;equalTo\&quot;: [\&quot;North Face\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;languages&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;languages\&quot;: {\&quot;equalTo\&quot;: [\&quot;English\&quot;,\&quot;Spanish\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;keywords&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;keywords\&quot;: {\&quot;startsWith\&quot;: [\&quot;Franchise\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;menuIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;menuIds\&quot;: {\&quot;includes\&quot;: [\&quot;m-23\&quot;,\&quot;755\&quot;,\&quot;menu34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;productListIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;productListIds\&quot;: {\&quot;notIncludes\&quot;: [\&quot;pl-2\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;calendarIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;calendarIds\&quot;: {\&quot;notIncludes\&quot;: [\&quot;cal34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;bioIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;bioIds\&quot;: {\&quot;includes\&quot;: [\&quot;b23\&quot;,\&quot;34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;custom###&lt;/td&gt;     &lt;td&gt;Text (for Multiline Text, URL, Text List, and Text Custom Fields), Number, Date, Bool, or Option&lt;/td&gt;     &lt;td&gt;\&quot;custom123\&quot;: {\&quot;equalTo\&quot;: [\&quot;asdf\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;folder&lt;/td&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;\&quot;folder\&quot;: 123, \&quot;folder\&quot;: [123,456]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;primary_language&lt;/td&gt;     &lt;td&gt;PrimaryLanguage&lt;/td&gt;     &lt;td&gt;\&quot;primary_language\&quot;: {\&quot;is\&quot;: \&quot;fr_CA\&quot;}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;alternateProfileLanguage&lt;/td&gt;     &lt;td&gt;AlternateLanguage&lt;/td&gt;     &lt;td&gt;\&quot;alternateProfileLanguage\&quot;: {\&quot;includes\&quot;: [\&quot;en\&quot;, \&quot;fr\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;npi&lt;/td&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;\&quot;npi\&quot;: {\&quot;is\&quot;: [\&quot;1234567890\&quot;, \&quot;1111111111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;conditionsTreated&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;conditionsTreated\&quot;: {\&quot;startsWith\&quot;: [\&quot;Influenza\&quot;]}, \&quot;conditionsTreated\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;lastUpdated&lt;/td&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;\&quot;lastUpdated\&quot;: {\&quot;eq\&quot;: \&quot;2018-01-01\&quot;}, \&quot;lastUpdated\&quot;: {\&quot;between\&quot;: [\&quot;2017-01-01\&quot;, \&quot;2018-01-01\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;fieldsWithData&lt;/td&gt;     &lt;td&gt;Fields&lt;/td&gt;     &lt;td&gt;\&quot;fieldsWithData\&quot;: [\&quot;email\&quot;, \&quot;hours\&quot;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;fieldsWithoutData&lt;/td&gt;     &lt;td&gt;Fields&lt;/td&gt;     &lt;td&gt;\&quot;fieldsWithoutData\&quot;: [\&quot;logo\&quot;, \&quot;video\&quot;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;reviewCount&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;review_count\&quot;: {\&quot;gt\&quot;: 1}, \&quot;review_count \&quot;: {\&quot;lt\&quot;: 10}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;averageRating&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;averageRating\&quot;: {\&quot;lt\&quot;: 3}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;locationType&lt;/td&gt;     &lt;td&gt;LocationType&lt;/td&gt;     &lt;td&gt;\&quot;locationType\&quot;: {\&quot;is\&quot;: [1]}, \&quot;locationType\&quot;: {\&quot;isNot\&quot;: [123]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;gender&lt;/td&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;\&quot;gender\&quot;: {\&quot;is\&quot;: [\&quot;FEMALE\&quot;]}, \&quot;gender\&quot;: {\&quot;isNot\&quot;: [\&quot;MALE\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;degrees&lt;/td&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;\&quot;degrees\&quot;: {\&quot;includes\&quot;: [\&quot;MD\&quot;]}, \&quot;degrees\&quot;: {\&quot;notIncludes\&quot;: [\&quot;PHD\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;experiences&lt;/td&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;\&quot;experiences\&quot;: {\&quot;includes\&quot;: [\&quot;FELLOWSHIP\&quot;]}, \&quot;experiences\&quot;: {\&quot;notIncludes\&quot;:[\&quot;INTERNSHIP\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;yearCompleted&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;yearCompleted\&quot;: {\&quot;gt\&quot;: 2000}, \&quot;yearCompleted\&quot;: {\&quot;lt\&quot;: 2015}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;acceptingNewPatients&lt;/td&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;\&quot;acceptingNewPatients\&quot;: true&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;firstName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;firstName\&quot;: {\&quot;startsWith\&quot;: [\&quot;David\&quot;]}, \&quot;firstName\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;middleName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;middleName\&quot;: {\&quot;startsWith\&quot;: [\&quot;P\&quot;]}, \&quot;middleName\&quot;: {\&quot;contains\&quot;: [\&quot;N\&quot;,\&quot;E\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;lastName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;lastName\&quot;: {\&quot;startsWith\&quot;: [\&quot;Sm\&quot;]}, \&quot;lastName\&quot;: {\&quot;contains\&quot;: [\&quot;Y\&quot;,\&quot;Z\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;officeName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;officeName\&quot;: {\&quot;startsWith\&quot;: [\&quot;Chiropractic\&quot;]}, \&quot;officeName\&quot;: {\&quot;contains\&quot;:[\&quot;Center\&quot;,\&quot;P\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;certifications&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;certifications\&quot;: {\&quot;contains\&quot;: [\&quot;Radiation Oncology\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;institutionName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;institutionName\&quot;: {\&quot;startsWith\&quot;: [\&quot;New York\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;insuranceAccepted&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;insuranceAccepted\&quot;: {\&quot;startsWith\&quot;: [\&quot;United\&quot;]}, \&quot;insuranceAccepted\&quot;:{\&quot;contains\&quot;: [\&quot;C\&quot;,\&quot;Health\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;admittingHospitals&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;admittingHospitals\&quot;: {\&quot;startsWith\&quot;: [\&quot;Children&#39;s\&quot;]}, \&quot;admittingHospitals\&quot;:{\&quot;contains\&quot;: [\&quot;Medical\&quot;,\&quot;University\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;subscriptions&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;subscriptions\&quot;: {\&quot;notIncludes\&quot;: [\&quot;123\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;facebookAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;facebookAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;foursquareAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;foursquareAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;googleplusAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;googleplusAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;labels&lt;/td&gt;     &lt;td&gt;Labels&lt;/td&gt;     &lt;td&gt;\&quot;labels\&quot;: {\&quot;includes\&quot;: [1, 100]}&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; 
    # @return [Array<(LocationsSearchResponse, Integer, Hash)>] LocationsSearchResponse data, response status code and response headers
    def search_locations_with_http_info(account_id, v, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.search_locations ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.search_locations"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.search_locations"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling KnowledgeManagerApi.search_locations, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] > 9950
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling KnowledgeManagerApi.search_locations, must be smaller than or equal to 9950.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/locationsearch'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'filters'] = opts[:'filters'] if !opts[:'filters'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'LocationsSearchResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.search_locations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#search_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Assets: Update
    # Update a specific asset.  **NOTE**: This endpoint is a true PUT. Fields that are not provided in an update will be cleared. The entire Asset object must be provided in the request, except for its **`id`**, which is given in the path.  **NOTE:** * If the **`v`** parameter is on or before `20190624`: only the first folder the Asset is available for will be returned in the legacy **`folderId`** field. * If the **`v`** parameter is after `20190624`: the complete list of folders the Asset is available to will be returned in the new **`folderIds`** field. **`folderId`** will not be returned. 
    # @param account_id [String] 
    # @param asset_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param format [String] The formatting langauge used to parse rich text field values. Present if and only if type of field is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60; 
    # @param asset [Asset] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def update_asset(account_id, asset_id, v, format, asset, opts = {})
      data, _status_code, _headers = update_asset_with_http_info(account_id, asset_id, v, format, asset, opts)
      data
    end

    # Assets: Update
    # Update a specific asset.  **NOTE**: This endpoint is a true PUT. Fields that are not provided in an update will be cleared. The entire Asset object must be provided in the request, except for its **&#x60;id&#x60;**, which is given in the path.  **NOTE:** * If the **&#x60;v&#x60;** parameter is on or before &#x60;20190624&#x60;: only the first folder the Asset is available for will be returned in the legacy **&#x60;folderId&#x60;** field. * If the **&#x60;v&#x60;** parameter is after &#x60;20190624&#x60;: the complete list of folders the Asset is available to will be returned in the new **&#x60;folderIds&#x60;** field. **&#x60;folderId&#x60;** will not be returned. 
    # @param account_id [String] 
    # @param asset_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param format [String] The formatting langauge used to parse rich text field values. Present if and only if type of field is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60; 
    # @param asset [Asset] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def update_asset_with_http_info(account_id, asset_id, v, format, asset, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.update_asset ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.update_asset"
      end
      # verify the required parameter 'asset_id' is set
      if @api_client.config.client_side_validation && asset_id.nil?
        fail ArgumentError, "Missing the required parameter 'asset_id' when calling KnowledgeManagerApi.update_asset"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.update_asset"
      end
      # verify the required parameter 'format' is set
      if @api_client.config.client_side_validation && format.nil?
        fail ArgumentError, "Missing the required parameter 'format' when calling KnowledgeManagerApi.update_asset"
      end
      if @api_client.config.client_side_validation && format.to_s.length < 0
        fail ArgumentError, 'invalid value for "format" when calling KnowledgeManagerApi.update_asset, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'asset' is set
      if @api_client.config.client_side_validation && asset.nil?
        fail ArgumentError, "Missing the required parameter 'asset' when calling KnowledgeManagerApi.update_asset"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/assets/{assetId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'assetId' + '}', CGI.escape(asset_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'format'] = format

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(asset)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.update_asset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#update_asset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Bios: Update
    # Update an existing Bios List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param bio [Bio] 
    # @param [Hash] opts the optional parameters
    # @return [BioListResponse]
    def update_bio(account_id, list_id, v, bio, opts = {})
      data, _status_code, _headers = update_bio_with_http_info(account_id, list_id, v, bio, opts)
      data
    end

    # Bios: Update
    # Update an existing Bios List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param bio [Bio] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BioListResponse, Integer, Hash)>] BioListResponse data, response status code and response headers
    def update_bio_with_http_info(account_id, list_id, v, bio, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.update_bio ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.update_bio"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.update_bio"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.update_bio"
      end
      # verify the required parameter 'bio' is set
      if @api_client.config.client_side_validation && bio.nil?
        fail ArgumentError, "Missing the required parameter 'bio' when calling KnowledgeManagerApi.update_bio"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/bios/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/kjson'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(bio)

      # return_type
      return_type = opts[:debug_return_type] || 'BioListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.update_bio",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#update_bio\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Custom Fields: Update
    # Updates a single Custom Field in an Account.  Note that the only updatable values in an existing Custom Field are its name, group, description, alternate language behavior, as well as available options if its `type` is `SINGLE_OPTION` or `MULTI_OPTION`.  * If options are modified, every location with that option selected will have the new value.  * If options are deleted, all locations with that option will no longer have that option selected.  * If the deleted options are the only options selected for a location, the location will no longer have a value set for that Custom Field. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param custom_field_id [String] ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
    # @param field_update [FieldUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def update_custom_field(v, account_id, custom_field_id, field_update, opts = {})
      data, _status_code, _headers = update_custom_field_with_http_info(v, account_id, custom_field_id, field_update, opts)
      data
    end

    # Custom Fields: Update
    # Updates a single Custom Field in an Account.  Note that the only updatable values in an existing Custom Field are its name, group, description, alternate language behavior, as well as available options if its &#x60;type&#x60; is &#x60;SINGLE_OPTION&#x60; or &#x60;MULTI_OPTION&#x60;.  * If options are modified, every location with that option selected will have the new value.  * If options are deleted, all locations with that option will no longer have that option selected.  * If the deleted options are the only options selected for a location, the location will no longer have a value set for that Custom Field. 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param account_id [String] 
    # @param custom_field_id [String] ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
    # @param field_update [FieldUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def update_custom_field_with_http_info(v, account_id, custom_field_id, field_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.update_custom_field ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.update_custom_field"
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.update_custom_field"
      end
      # verify the required parameter 'custom_field_id' is set
      if @api_client.config.client_side_validation && custom_field_id.nil?
        fail ArgumentError, "Missing the required parameter 'custom_field_id' when calling KnowledgeManagerApi.update_custom_field"
      end
      # verify the required parameter 'field_update' is set
      if @api_client.config.client_side_validation && field_update.nil?
        fail ArgumentError, "Missing the required parameter 'field_update' when calling KnowledgeManagerApi.update_custom_field"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/customfields/{customFieldId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'customFieldId' + '}', CGI.escape(custom_field_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(field_update)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.update_custom_field",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#update_custom_field\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entities: Update
    # Update the Entity with the given ID
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param entity_write [EntityWrite] Information to update on the entity
    # @param [Hash] opts the optional parameters
    # @option opts [String] :format The formatting language used to parse rich text field values. Present and **required** if an only if the request contains a field with type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;  (default to 'markdown')
    # @option opts [Boolean] :strip_unsupported_formats Optional parameter to strip unsupported formats in rich text fields. When this parameter is included, the unsupported formats in rich text fields will be stripped and saved as plain text; otherwise if this parameter is not included, unsupported formats will return an error. 
    # @option opts [String] :template_fields Comma-separated list of top-level fields to apply from the template. If provided, only the fields specified will be applied to the entity.  Ignored if **&#x60;templateId&#x60;** is not provided. 
    # @option opts [String] :template_id The ID of the template to apply to the entity  **NOTE:** Some fields that are part of the provided template but not present in the API will be applied - e.g. Linked Accounts 
    # @return [CreateEntity201Response]
    def update_entity(account_id, entity_id, v, entity_write, opts = {})
      data, _status_code, _headers = update_entity_with_http_info(account_id, entity_id, v, entity_write, opts)
      data
    end

    # Entities: Update
    # Update the Entity with the given ID
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param entity_write [EntityWrite] Information to update on the entity
    # @param [Hash] opts the optional parameters
    # @option opts [String] :format The formatting language used to parse rich text field values. Present and **required** if an only if the request contains a field with type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;  (default to 'markdown')
    # @option opts [Boolean] :strip_unsupported_formats Optional parameter to strip unsupported formats in rich text fields. When this parameter is included, the unsupported formats in rich text fields will be stripped and saved as plain text; otherwise if this parameter is not included, unsupported formats will return an error. 
    # @option opts [String] :template_fields Comma-separated list of top-level fields to apply from the template. If provided, only the fields specified will be applied to the entity.  Ignored if **&#x60;templateId&#x60;** is not provided. 
    # @option opts [String] :template_id The ID of the template to apply to the entity  **NOTE:** Some fields that are part of the provided template but not present in the API will be applied - e.g. Linked Accounts 
    # @return [Array<(CreateEntity201Response, Integer, Hash)>] CreateEntity201Response data, response status code and response headers
    def update_entity_with_http_info(account_id, entity_id, v, entity_write, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.update_entity ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.update_entity"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.update_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_id' is set
      if @api_client.config.client_side_validation && entity_id.nil?
        fail ArgumentError, "Missing the required parameter 'entity_id' when calling KnowledgeManagerApi.update_entity"
      end
      if @api_client.config.client_side_validation && entity_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "entity_id" when calling KnowledgeManagerApi.update_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.update_entity"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.update_entity, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_write' is set
      if @api_client.config.client_side_validation && entity_write.nil?
        fail ArgumentError, "Missing the required parameter 'entity_write' when calling KnowledgeManagerApi.update_entity"
      end
      if @api_client.config.client_side_validation && !opts[:'format'].nil? && opts[:'format'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"format"]" when calling KnowledgeManagerApi.update_entity, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'template_fields'].nil? && opts[:'template_fields'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"template_fields"]" when calling KnowledgeManagerApi.update_entity, the character length must be great than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'template_id'].nil? && opts[:'template_id'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"template_id"]" when calling KnowledgeManagerApi.update_entity, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/entities/{entityId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'entityId' + '}', CGI.escape(entity_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'format'] = opts[:'format'] if !opts[:'format'].nil?
      query_params[:'stripUnsupportedFormats'] = opts[:'strip_unsupported_formats'] if !opts[:'strip_unsupported_formats'].nil?
      query_params[:'templateFields'] = opts[:'template_fields'] if !opts[:'template_fields'].nil?
      query_params[:'templateId'] = opts[:'template_id'] if !opts[:'template_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(entity_write)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateEntity201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.update_entity",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#update_entity\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Events (Legacy): Update
    # Update an existing Event List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param event [Event] 
    # @param [Hash] opts the optional parameters
    # @return [EventListResponse]
    def update_event(account_id, list_id, v, event, opts = {})
      data, _status_code, _headers = update_event_with_http_info(account_id, list_id, v, event, opts)
      data
    end

    # Events (Legacy): Update
    # Update an existing Event List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param event [Event] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(EventListResponse, Integer, Hash)>] EventListResponse data, response status code and response headers
    def update_event_with_http_info(account_id, list_id, v, event, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.update_event ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.update_event"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.update_event"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.update_event"
      end
      # verify the required parameter 'event' is set
      if @api_client.config.client_side_validation && event.nil?
        fail ArgumentError, "Missing the required parameter 'event' when calling KnowledgeManagerApi.update_event"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/events/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/kjson'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(event)

      # return_type
      return_type = opts[:debug_return_type] || 'EventListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.update_event",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#update_event\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Locations (Legacy): Update
    # Updates the primary profile for a Location.  **NOTE:** Despite using the PUT method, Locations: Update only updates supplied fields. Omitted fields are not modified.  **NOTE:** The Location's primary profile language can be changed by calling this endpoint with a different, but unused, language code. 
    # @param account_id [String] 
    # @param location_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param location [Location] 
    # @param [Hash] opts the optional parameters
    # @return [IdResponse]
    def update_location(account_id, location_id, v, location, opts = {})
      data, _status_code, _headers = update_location_with_http_info(account_id, location_id, v, location, opts)
      data
    end

    # Locations (Legacy): Update
    # Updates the primary profile for a Location.  **NOTE:** Despite using the PUT method, Locations: Update only updates supplied fields. Omitted fields are not modified.  **NOTE:** The Location&#39;s primary profile language can be changed by calling this endpoint with a different, but unused, language code. 
    # @param account_id [String] 
    # @param location_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param location [Location] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def update_location_with_http_info(account_id, location_id, v, location, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.update_location ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.update_location"
      end
      # verify the required parameter 'location_id' is set
      if @api_client.config.client_side_validation && location_id.nil?
        fail ArgumentError, "Missing the required parameter 'location_id' when calling KnowledgeManagerApi.update_location"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.update_location"
      end
      # verify the required parameter 'location' is set
      if @api_client.config.client_side_validation && location.nil?
        fail ArgumentError, "Missing the required parameter 'location' when calling KnowledgeManagerApi.update_location"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/locations/{locationId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'locationId' + '}', CGI.escape(location_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(location)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.update_location",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#update_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Menus: Update
    # Update an existing Menu.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param menu [Menu] 
    # @param [Hash] opts the optional parameters
    # @return [MenuListResponse]
    def update_menu(account_id, list_id, v, menu, opts = {})
      data, _status_code, _headers = update_menu_with_http_info(account_id, list_id, v, menu, opts)
      data
    end

    # Menus: Update
    # Update an existing Menu.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param menu [Menu] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MenuListResponse, Integer, Hash)>] MenuListResponse data, response status code and response headers
    def update_menu_with_http_info(account_id, list_id, v, menu, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.update_menu ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.update_menu"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.update_menu"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.update_menu"
      end
      # verify the required parameter 'menu' is set
      if @api_client.config.client_side_validation && menu.nil?
        fail ArgumentError, "Missing the required parameter 'menu' when calling KnowledgeManagerApi.update_menu"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/menus/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(menu)

      # return_type
      return_type = opts[:debug_return_type] || 'MenuListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.update_menu",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#update_menu\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Products: Update
    # Update an existing Product List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param product [Product] 
    # @param [Hash] opts the optional parameters
    # @return [ProductListResponse]
    def update_product(account_id, list_id, v, product, opts = {})
      data, _status_code, _headers = update_product_with_http_info(account_id, list_id, v, product, opts)
      data
    end

    # Products: Update
    # Update an existing Product List.
    # @param account_id [String] 
    # @param list_id [String] ID of this List.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param product [Product] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ProductListResponse, Integer, Hash)>] ProductListResponse data, response status code and response headers
    def update_product_with_http_info(account_id, list_id, v, product, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.update_product ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.update_product"
      end
      # verify the required parameter 'list_id' is set
      if @api_client.config.client_side_validation && list_id.nil?
        fail ArgumentError, "Missing the required parameter 'list_id' when calling KnowledgeManagerApi.update_product"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.update_product"
      end
      # verify the required parameter 'product' is set
      if @api_client.config.client_side_validation && product.nil?
        fail ArgumentError, "Missing the required parameter 'product' when calling KnowledgeManagerApi.update_product"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/products/{listId}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'listId' + '}', CGI.escape(list_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/kjson'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product)

      # return_type
      return_type = opts[:debug_return_type] || 'ProductListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.update_product",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#update_product\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Entity Language Profiles: Upsert
    # Add a language profile
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param language_code [String] The language code corresponding to the language of the profile that the user wishes to create or update
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param entity_write [EntityWrite] The entity profile to create
    # @param [Hash] opts the optional parameters
    # @return [CreateEntity201Response]
    def upsert_language_profile(account_id, entity_id, language_code, v, entity_write, opts = {})
      data, _status_code, _headers = upsert_language_profile_with_http_info(account_id, entity_id, language_code, v, entity_write, opts)
      data
    end

    # Entity Language Profiles: Upsert
    # Add a language profile
    # @param account_id [String] 
    # @param entity_id [String] The external ID of the requested Entity
    # @param language_code [String] The language code corresponding to the language of the profile that the user wishes to create or update
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param entity_write [EntityWrite] The entity profile to create
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateEntity201Response, Integer, Hash)>] CreateEntity201Response data, response status code and response headers
    def upsert_language_profile_with_http_info(account_id, entity_id, language_code, v, entity_write, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.upsert_language_profile ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.upsert_language_profile"
      end
      if @api_client.config.client_side_validation && account_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "account_id" when calling KnowledgeManagerApi.upsert_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_id' is set
      if @api_client.config.client_side_validation && entity_id.nil?
        fail ArgumentError, "Missing the required parameter 'entity_id' when calling KnowledgeManagerApi.upsert_language_profile"
      end
      if @api_client.config.client_side_validation && entity_id.to_s.length < 0
        fail ArgumentError, 'invalid value for "entity_id" when calling KnowledgeManagerApi.upsert_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'language_code' is set
      if @api_client.config.client_side_validation && language_code.nil?
        fail ArgumentError, "Missing the required parameter 'language_code' when calling KnowledgeManagerApi.upsert_language_profile"
      end
      if @api_client.config.client_side_validation && language_code.to_s.length < 0
        fail ArgumentError, 'invalid value for "language_code" when calling KnowledgeManagerApi.upsert_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.upsert_language_profile"
      end
      if @api_client.config.client_side_validation && v.to_s.length < 0
        fail ArgumentError, 'invalid value for "v" when calling KnowledgeManagerApi.upsert_language_profile, the character length must be great than or equal to 0.'
      end

      # verify the required parameter 'entity_write' is set
      if @api_client.config.client_side_validation && entity_write.nil?
        fail ArgumentError, "Missing the required parameter 'entity_write' when calling KnowledgeManagerApi.upsert_language_profile"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/entityprofiles/{entityId}/{languageCode}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'entityId' + '}', CGI.escape(entity_id.to_s)).sub('{' + 'languageCode' + '}', CGI.escape(language_code.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(entity_write)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateEntity201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.upsert_language_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#upsert_language_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Language Profiles (Legacy): Upsert
    # Creates and / or sets the fields for a Language Profile  **NOTE:** You can change a Language Profile’s language by supplying a different (but unused) language code. 
    # @param account_id [String] 
    # @param location_id [String] 
    # @param language_code [String] Locale code.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param location [Location] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :primary When present and set to true, the specified profile will become the location’s primary Language Profile.
    # @return [EmptyResponse]
    def upsert_location_language_profile(account_id, location_id, language_code, v, location, opts = {})
      data, _status_code, _headers = upsert_location_language_profile_with_http_info(account_id, location_id, language_code, v, location, opts)
      data
    end

    # Language Profiles (Legacy): Upsert
    # Creates and / or sets the fields for a Language Profile  **NOTE:** You can change a Language Profile’s language by supplying a different (but unused) language code. 
    # @param account_id [String] 
    # @param location_id [String] 
    # @param language_code [String] Locale code.
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param location [Location] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :primary When present and set to true, the specified profile will become the location’s primary Language Profile.
    # @return [Array<(EmptyResponse, Integer, Hash)>] EmptyResponse data, response status code and response headers
    def upsert_location_language_profile_with_http_info(account_id, location_id, language_code, v, location, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.upsert_location_language_profile ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.upsert_location_language_profile"
      end
      # verify the required parameter 'location_id' is set
      if @api_client.config.client_side_validation && location_id.nil?
        fail ArgumentError, "Missing the required parameter 'location_id' when calling KnowledgeManagerApi.upsert_location_language_profile"
      end
      # verify the required parameter 'language_code' is set
      if @api_client.config.client_side_validation && language_code.nil?
        fail ArgumentError, "Missing the required parameter 'language_code' when calling KnowledgeManagerApi.upsert_location_language_profile"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.upsert_location_language_profile"
      end
      # verify the required parameter 'location' is set
      if @api_client.config.client_side_validation && location.nil?
        fail ArgumentError, "Missing the required parameter 'location' when calling KnowledgeManagerApi.upsert_location_language_profile"
      end
      # resource path
      local_var_path = '/accounts/{accountId}/locations/{locationId}/profiles/{language_code}'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s)).sub('{' + 'locationId' + '}', CGI.escape(location_id.to_s)).sub('{' + 'language_code' + '}', CGI.escape(language_code.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'primary'] = opts[:'primary'] if !opts[:'primary'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(location)

      # return_type
      return_type = opts[:debug_return_type] || 'EmptyResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.upsert_location_language_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#upsert_location_language_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Suggestion: Upsert
    # Create a suggestion via API.  **NOTE:**   * If a suggestion already exists from your app on the specified field, the suggestion will be updated.   * Suggestions on categories and keywords fields, as well ECLs are not currently supported. 
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param suggestion [Suggestion] The suggestion to be upserted
    # @param [Hash] opts the optional parameters
    # @option opts [String] :format The formatting language used to parse rich text field values. Present and **required** if an only if the request contains a field with type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;  (default to 'markdown')
    # @return [IdResponse]
    def upsert_suggestion(account_id, v, suggestion, opts = {})
      data, _status_code, _headers = upsert_suggestion_with_http_info(account_id, v, suggestion, opts)
      data
    end

    # Suggestion: Upsert
    # Create a suggestion via API.  **NOTE:**   * If a suggestion already exists from your app on the specified field, the suggestion will be updated.   * Suggestions on categories and keywords fields, as well ECLs are not currently supported. 
    # @param account_id [String] 
    # @param v [String] A date in &#x60;YYYYMMDD&#x60; format.
    # @param suggestion [Suggestion] The suggestion to be upserted
    # @param [Hash] opts the optional parameters
    # @option opts [String] :format The formatting language used to parse rich text field values. Present and **required** if an only if the request contains a field with type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;  (default to 'markdown')
    # @return [Array<(IdResponse, Integer, Hash)>] IdResponse data, response status code and response headers
    def upsert_suggestion_with_http_info(account_id, v, suggestion, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: KnowledgeManagerApi.upsert_suggestion ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling KnowledgeManagerApi.upsert_suggestion"
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling KnowledgeManagerApi.upsert_suggestion"
      end
      # verify the required parameter 'suggestion' is set
      if @api_client.config.client_side_validation && suggestion.nil?
        fail ArgumentError, "Missing the required parameter 'suggestion' when calling KnowledgeManagerApi.upsert_suggestion"
      end
      if @api_client.config.client_side_validation && !opts[:'format'].nil? && opts[:'format'].to_s.length < 0
        fail ArgumentError, 'invalid value for "opts[:"format"]" when calling KnowledgeManagerApi.upsert_suggestion, the character length must be great than or equal to 0.'
      end

      # resource path
      local_var_path = '/accounts/{accountId}/suggestions'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'format'] = opts[:'format'] if !opts[:'format'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(suggestion)

      # return_type
      return_type = opts[:debug_return_type] || 'IdResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key', 'api_key']

      new_options = opts.merge(
        :operation => :"KnowledgeManagerApi.upsert_suggestion",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: KnowledgeManagerApi#upsert_suggestion\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
