=begin
#Yext API

#No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 2.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.4.0

=end

require 'date'
require 'time'

module Yext
  class AnalyticsFilter
    # Backend(s) used to return results.
    attr_accessor :answers_backend

    # Indicates whether no Search Term was entered for Search.
    attr_accessor :answers_blank_search_term

    # Label assigned to CTA_CLICK types.
    attr_accessor :answers_click_label

    # Type of click performed by user.
    attr_accessor :answers_click_type

    # URL user was sent to on click, e.g. Google Maps on Driving Directions click.
    attr_accessor :answers_click_url

    # Name of the Cluster a Search Term belongs to. Search Term Clusters are named by using the most popular Search Term (based on Sessions) within the Cluster.
    attr_accessor :answers_cluster

    # Version Number of Configuration Search was run on.
    attr_accessor :answers_configuration_version

    # Version Label of Configuration Search was run on.
    attr_accessor :answers_configuration_version_label

    # Indicates whether click was a from Direct Answer.
    attr_accessor :answers_direct_answer_click

    # Field returned in Direct Answer.
    attr_accessor :answers_direct_answer_field

    # Type of Field used for Direct Answer returned for a Search.
    attr_accessor :answers_direct_answer_field_type

    # Value returned in Direct Answer.
    attr_accessor :answers_direct_answer_field_value

    # Type of Direct Answers returned for a Search.
    attr_accessor :answers_direct_answer_type

    # Name of Answers Experience.
    attr_accessor :answers_experience

    # Field from the Knowledge Graph which Search filtered on.
    attr_accessor :answers_filter_key

    # Operator used for filter.
    attr_accessor :answers_filter_operator

    # Operator used for filter.
    attr_accessor :answers_filter_source

    # Type of filter applied.
    attr_accessor :answers_filter_type

    # Value used to filter Search.
    attr_accessor :answers_filter_value

    # Indicates the first search in the case creation process.
    attr_accessor :answers_has_case_start

    # Indicates the last search in the case creation process.
    attr_accessor :answers_has_case_submit

    # Include only searches with results from the Knowledge Graph.
    attr_accessor :answers_has_kg_results

    # Indicates whether a Search Term belongs to a Search Term Cluster. Search Terms may not belong to a cluster if they do not pertain to any other terms searched on your experience or if it is a new term that has been searched for the first time since clustering was last run.
    attr_accessor :answers_has_search_term_cluster

    # Includes only searches made using voice search.
    attr_accessor :answers_has_voice_search

    # The integration source from which this search originated. This includes the following options: STANDARD (standard search bar) and OVERLAY (within an search overlay).
    attr_accessor :answers_query_source

    # Raw Search Term entered by user for Search.
    attr_accessor :answers_raw_search_term

    # Domain of page where user was sent from, e.g. jobs.mysite.com.
    attr_accessor :answers_referrer_domain

    # URL of page where user was sent from e.g. https://jobs.mysite.com/careers/open-positions/.
    attr_accessor :answers_referrer_page_url

    # Position Entity was returned within Vertical.
    attr_accessor :answers_result_entity_position

    # Title of Result from Third Party Backends. For results that come from Knowledge Graph backends this will be blank.
    attr_accessor :answers_result_title

    # Position of Verticals in Result.
    attr_accessor :answers_result_vertical_position

    # ID of Search.
    attr_accessor :answers_search_id

    # Normalized Search Term of Search. Normalization removes: Capitalization, Punctuation, White Space.
    attr_accessor :answers_search_term

    # Identify how well a cluster is performing based on % of Total Searches and Click Through Rate. Cluster Performance breaks down into four groups with ids between 0-3. 0: Needs Attention - Large Cluster 1: Needs Attention - Small Cluster 2: Performing Well - Small Cluster 3: Performing Well - Large Cluster 
    attr_accessor :answers_search_term_cluster_performance

    # Whether Search Term should be boosted or blacklisted based on your experience config. Options include BOOSTED and BLACKLISTED.
    attr_accessor :answers_search_term_intent

    # Vertical Search was ran on.
    attr_accessor :answers_search_vertical

    # ID of Session Search was run in.
    attr_accessor :answers_session_id

    # Type of Traffic.
    attr_accessor :answers_traffic_type

    # Browser of the user running the Search.
    attr_accessor :answers_user_browser

    # City of user running Search.
    attr_accessor :answers_user_city

    # Country of user running Search.
    attr_accessor :answers_user_country

    # Device of user running Search.
    attr_accessor :answers_user_device_class

    # Lat, Long of user running Search.
    attr_accessor :answers_user_lat_long

    # Method for identifying user location. Options include Unknown, Device, and IP.
    attr_accessor :answers_user_location_accuracy

    # Postal code of the user running the Search.
    attr_accessor :answers_user_postal_code

    # Region of the user running the Search.
    attr_accessor :answers_user_region

    # Vertical returned in results for a Search.
    attr_accessor :answers_vertical_returned

    # Conversion Tracking click type.
    attr_accessor :click_type

    # Configuration Version Label.
    attr_accessor :configuration_version_label

    # Conversion Type.
    attr_accessor :conversion_type

    # Conversion tracking medium.
    attr_accessor :medium

    # Identify conversion analytics by the product in which they occurred.
    attr_accessor :product

    # Identify conversion analytics by the source of the traffic.
    attr_accessor :traffic_source

    # Identify conversion analytics by their value proposition.
    attr_accessor :value_proposition

    # Vertical Config ID.
    attr_accessor :vertical_config_id

    # Array of age groups. Can only be used with Facebook metrics.
    attr_accessor :age

    # Email of Unique Visitor who triggered event.
    attr_accessor :visitor_email

    # ID of Unique Visitor who triggered event.
    attr_accessor :visitor_id

    # Method used to identify Visitor.
    attr_accessor :visitor_id_method

    # Name of Unique Visitor who triggered event.
    attr_accessor :visitor_name

    # Competitors monitored by the Intelligent Search Tracker. Can only be used with Intelligent Search Tracker metrics.
    attr_accessor :competitor

    # Array of 3166 Alpha-2 country codes.
    attr_accessor :countries

    # Specifies the type of customer actions to be included in the report. Can only be used with the `GOOGLE_CUSTOMER_ACTIONS` and `YELP_CUSTOMER_ACTIONS` metrics. 
    attr_accessor :customer_action_type

    # The exclusive end date for the report data. Defaults to the earliest of the relevant maximum reporting dates. Must be after the date given in **`startDate`**. NOTES: - If **`dimensions`** contains `WEEKS`, `MONTHS`, or `MONTHS_RETAIL`, the end date must coincide with the end of a week or month, depending on the dimension chosen. - If the **`v`** parameter is before `20180314`, the end date is inclusive, and the end date must be on or after the date given in **`startDate`**. 
    attr_accessor :end_date

    # Array of entity groups.
    attr_accessor :entity_group

    # Array of entity IDs.
    attr_accessor :entity_ids

    # Array of entity types.
    attr_accessor :entity_type

    # Array of event search conditions.
    attr_accessor :event_search_condition

    # Array of Facebook impression types.
    attr_accessor :facebook_impression_type

    # Array of Facebook RSVP types.
    attr_accessor :facebook_rsvp_type

    # Array of Facebook RSVP types.
    attr_accessor :facebook_story_type

    # Specifies a list of folders whose locations and subfolders should be included in the results. Defaults to all folders. Cannot be used when `ACCOUNT_ID` is in **`dimensions`**. 
    attr_accessor :folder_ids

    # Array of Foursquare check-in age groups.
    attr_accessor :foursquare_checkin_age

    # Foursquare check-in gender.
    attr_accessor :foursquare_checkin_gender

    # Array of Foursquare check-in times.
    attr_accessor :foursquare_checkin_time_of_day

    # Foursquare check-in type.
    attr_accessor :foursquare_checkin_type

    # Specifies the words that should be included in the report. Can only be used with Reviews metrics.
    attr_accessor :frequent_words

    attr_accessor :gender

    # Specifies the type of customer actions to be included in the report. Can only be used with the `GOOGLE_CUSTOMER_ACTIONS` metric. 
    attr_accessor :google_action_type

    # Specifies the type of queries to be included in the report. Can only be used with the `GOOGLE_SEARCH_QUERIES` metric.
    attr_accessor :google_query_type

    # Specifies the hour(s) of day that should be included in the report. Can only, and must be used with the `GOOGLE_PHONE_CALLS` metric.
    attr_accessor :hours

    # Instagram content type.
    attr_accessor :instagram_content_type

    # The keyword used to create search requests. Can only be used with Intelligent Search Tracker metrics.
    attr_accessor :keyword

    # Specifies the type of listings live that should be included in the report. Can only be used with `LISTINGS_LIVE` metric.
    attr_accessor :listings_live_type

    # Array of location IDs
    attr_accessor :location_ids

    # Array of location labels. Cannot be used with `NEW_REVIEWS` or `AVERAGE_RATING` metrics.
    attr_accessor :location_labels

    # The local pack or organic position of the search result. Can only be used with Intelligent Search Tracker metrics.
    attr_accessor :match_position

    # One of Local Map Pack, Listings, Pages and Corporate Website. Can only be used with Intelligent Search Tracker metrics.
    attr_accessor :match_type

    # Maximum number of times a search term may have been used.
    attr_accessor :max_search_frequency

    # Minimum number of times a search term may have been used.
    attr_accessor :min_search_frequency

    # Specifies the Pages page types that should be included in the report. Can only be used with Store Pages metrics
    attr_accessor :page_types

    # Specifies the partners that should be included in the report. Can only be used with Reviews metrics.
    attr_accessor :partners

    # Array of platform types.
    attr_accessor :platform_type

    # Specifies the types of publisher suggestions that should be included in the report. Can only be used with `PUBLISHER_SUGGESTIONS` metric.
    attr_accessor :publisher_suggestion_type

    # The query template used to create search requests. Can only be used with Intelligent Search Tracker metrics.
    attr_accessor :query_template

    # Specifies the ratings to be included in the report. Can only be used with Reviews metrics.
    attr_accessor :ratings

    # Specifies the review labels that should be included in the report. Can only be used with Reviews metrics.
    attr_accessor :review_labels

    # The search engine used for the Intelligent Search Tracker. Can only be used with Intelligent Search Tracker metrics.
    attr_accessor :search_engine

    # One of Organic, Local Pack or Knowledge Card. Can only be used with Intelligent Search Tracker metrics.
    attr_accessor :search_result_type

    attr_accessor :search_terms

    # Specifies the sentiment collection that should be included in the report. Can only be used with Reviews metrics.
    attr_accessor :sentiment_collection

    # The inclusive start date for the report data. Defaults to 90 days before the end date. Must be before the date given in **`endDate`**. E.g. ‘2016-08-22’ NOTE: If `WEEKS`, `MONTHS`, or `MONTHS_RETAIL` is in **`dimensions`**, **`startDate`** must coincide with the beginning and end of a week or month, depending on the dimension chosen. 
    attr_accessor :start_date

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'answers_backend' => :'ANSWERS_BACKEND',
        :'answers_blank_search_term' => :'ANSWERS_BLANK_SEARCH_TERM',
        :'answers_click_label' => :'ANSWERS_CLICK_LABEL',
        :'answers_click_type' => :'ANSWERS_CLICK_TYPE',
        :'answers_click_url' => :'ANSWERS_CLICK_URL',
        :'answers_cluster' => :'ANSWERS_CLUSTER',
        :'answers_configuration_version' => :'ANSWERS_CONFIGURATION_VERSION',
        :'answers_configuration_version_label' => :'ANSWERS_CONFIGURATION_VERSION_LABEL',
        :'answers_direct_answer_click' => :'ANSWERS_DIRECT_ANSWER_CLICK',
        :'answers_direct_answer_field' => :'ANSWERS_DIRECT_ANSWER_FIELD',
        :'answers_direct_answer_field_type' => :'ANSWERS_DIRECT_ANSWER_FIELD_TYPE',
        :'answers_direct_answer_field_value' => :'ANSWERS_DIRECT_ANSWER_FIELD_VALUE',
        :'answers_direct_answer_type' => :'ANSWERS_DIRECT_ANSWER_TYPE',
        :'answers_experience' => :'ANSWERS_EXPERIENCE',
        :'answers_filter_key' => :'ANSWERS_FILTER_KEY',
        :'answers_filter_operator' => :'ANSWERS_FILTER_OPERATOR',
        :'answers_filter_source' => :'ANSWERS_FILTER_SOURCE',
        :'answers_filter_type' => :'ANSWERS_FILTER_TYPE',
        :'answers_filter_value' => :'ANSWERS_FILTER_VALUE',
        :'answers_has_case_start' => :'ANSWERS_HAS_CASE_START',
        :'answers_has_case_submit' => :'ANSWERS_HAS_CASE_SUBMIT',
        :'answers_has_kg_results' => :'ANSWERS_HAS_KG_RESULTS',
        :'answers_has_search_term_cluster' => :'ANSWERS_HAS_SEARCH_TERM_CLUSTER',
        :'answers_has_voice_search' => :'ANSWERS_HAS_VOICE_SEARCH',
        :'answers_query_source' => :'ANSWERS_QUERY_SOURCE',
        :'answers_raw_search_term' => :'ANSWERS_RAW_SEARCH_TERM',
        :'answers_referrer_domain' => :'ANSWERS_REFERRER_DOMAIN',
        :'answers_referrer_page_url' => :'ANSWERS_REFERRER_PAGE_URL',
        :'answers_result_entity_position' => :'ANSWERS_RESULT_ENTITY_POSITION',
        :'answers_result_title' => :'ANSWERS_RESULT_TITLE',
        :'answers_result_vertical_position' => :'ANSWERS_RESULT_VERTICAL_POSITION',
        :'answers_search_id' => :'ANSWERS_SEARCH_ID',
        :'answers_search_term' => :'ANSWERS_SEARCH_TERM',
        :'answers_search_term_cluster_performance' => :'ANSWERS_SEARCH_TERM_CLUSTER_PERFORMANCE',
        :'answers_search_term_intent' => :'ANSWERS_SEARCH_TERM_INTENT',
        :'answers_search_vertical' => :'ANSWERS_SEARCH_VERTICAL',
        :'answers_session_id' => :'ANSWERS_SESSION_ID',
        :'answers_traffic_type' => :'ANSWERS_TRAFFIC_TYPE',
        :'answers_user_browser' => :'ANSWERS_USER_BROWSER',
        :'answers_user_city' => :'ANSWERS_USER_CITY',
        :'answers_user_country' => :'ANSWERS_USER_COUNTRY',
        :'answers_user_device_class' => :'ANSWERS_USER_DEVICE_CLASS',
        :'answers_user_lat_long' => :'ANSWERS_USER_LAT_LONG',
        :'answers_user_location_accuracy' => :'ANSWERS_USER_LOCATION_ACCURACY',
        :'answers_user_postal_code' => :'ANSWERS_USER_POSTAL_CODE',
        :'answers_user_region' => :'ANSWERS_USER_REGION',
        :'answers_vertical_returned' => :'ANSWERS_VERTICAL_RETURNED',
        :'click_type' => :'CLICK_TYPE',
        :'configuration_version_label' => :'CONFIGURATION_VERSION_LABEL',
        :'conversion_type' => :'CONVERSION_TYPE',
        :'medium' => :'MEDIUM',
        :'product' => :'PRODUCT',
        :'traffic_source' => :'TRAFFIC_SOURCE',
        :'value_proposition' => :'VALUE_PROPOSITION',
        :'vertical_config_id' => :'VERTICAL_CONFIG_ID',
        :'age' => :'age',
        :'visitor_email' => :'VISITOR_EMAIL',
        :'visitor_id' => :'VISITOR_ID',
        :'visitor_id_method' => :'VISITOR_ID_METHOD',
        :'visitor_name' => :'VISITOR_NAME',
        :'competitor' => :'competitor',
        :'countries' => :'countries',
        :'customer_action_type' => :'customerActionType',
        :'end_date' => :'endDate',
        :'entity_group' => :'entityGroup',
        :'entity_ids' => :'entityIds',
        :'entity_type' => :'entityType',
        :'event_search_condition' => :'eventSearchCondition',
        :'facebook_impression_type' => :'facebookImpressionType',
        :'facebook_rsvp_type' => :'facebookRsvpType',
        :'facebook_story_type' => :'facebookStoryType',
        :'folder_ids' => :'folderIds',
        :'foursquare_checkin_age' => :'foursquareCheckinAge',
        :'foursquare_checkin_gender' => :'foursquareCheckinGender',
        :'foursquare_checkin_time_of_day' => :'foursquareCheckinTimeOfDay',
        :'foursquare_checkin_type' => :'foursquareCheckinType',
        :'frequent_words' => :'frequentWords',
        :'gender' => :'gender',
        :'google_action_type' => :'googleActionType',
        :'google_query_type' => :'googleQueryType',
        :'hours' => :'hours',
        :'instagram_content_type' => :'instagramContentType',
        :'keyword' => :'keyword',
        :'listings_live_type' => :'listingsLiveType',
        :'location_ids' => :'locationIds',
        :'location_labels' => :'locationLabels',
        :'match_position' => :'matchPosition',
        :'match_type' => :'matchType',
        :'max_search_frequency' => :'maxSearchFrequency',
        :'min_search_frequency' => :'minSearchFrequency',
        :'page_types' => :'pageTypes',
        :'partners' => :'partners',
        :'platform_type' => :'platformType',
        :'publisher_suggestion_type' => :'publisherSuggestionType',
        :'query_template' => :'queryTemplate',
        :'ratings' => :'ratings',
        :'review_labels' => :'reviewLabels',
        :'search_engine' => :'searchEngine',
        :'search_result_type' => :'searchResultType',
        :'search_terms' => :'searchTerms',
        :'sentiment_collection' => :'sentimentCollection',
        :'start_date' => :'startDate'
      }
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'answers_backend' => :'Array<String>',
        :'answers_blank_search_term' => :'Boolean',
        :'answers_click_label' => :'String',
        :'answers_click_type' => :'String',
        :'answers_click_url' => :'String',
        :'answers_cluster' => :'String',
        :'answers_configuration_version' => :'Array<String>',
        :'answers_configuration_version_label' => :'Array<String>',
        :'answers_direct_answer_click' => :'Boolean',
        :'answers_direct_answer_field' => :'String',
        :'answers_direct_answer_field_type' => :'Array<String>',
        :'answers_direct_answer_field_value' => :'String',
        :'answers_direct_answer_type' => :'Array<String>',
        :'answers_experience' => :'Array<String>',
        :'answers_filter_key' => :'Array<String>',
        :'answers_filter_operator' => :'Array<String>',
        :'answers_filter_source' => :'Array<String>',
        :'answers_filter_type' => :'Array<String>',
        :'answers_filter_value' => :'Array<String>',
        :'answers_has_case_start' => :'Boolean',
        :'answers_has_case_submit' => :'Boolean',
        :'answers_has_kg_results' => :'Boolean',
        :'answers_has_search_term_cluster' => :'Boolean',
        :'answers_has_voice_search' => :'Boolean',
        :'answers_query_source' => :'Array<String>',
        :'answers_raw_search_term' => :'String',
        :'answers_referrer_domain' => :'String',
        :'answers_referrer_page_url' => :'String',
        :'answers_result_entity_position' => :'Integer',
        :'answers_result_title' => :'String',
        :'answers_result_vertical_position' => :'Integer',
        :'answers_search_id' => :'String',
        :'answers_search_term' => :'String',
        :'answers_search_term_cluster_performance' => :'Array<Integer>',
        :'answers_search_term_intent' => :'String',
        :'answers_search_vertical' => :'Array<String>',
        :'answers_session_id' => :'String',
        :'answers_traffic_type' => :'Array<String>',
        :'answers_user_browser' => :'Array<String>',
        :'answers_user_city' => :'String',
        :'answers_user_country' => :'String',
        :'answers_user_device_class' => :'String',
        :'answers_user_lat_long' => :'String',
        :'answers_user_location_accuracy' => :'String',
        :'answers_user_postal_code' => :'Array<String>',
        :'answers_user_region' => :'Array<String>',
        :'answers_vertical_returned' => :'Array<String>',
        :'click_type' => :'Array<String>',
        :'configuration_version_label' => :'Array<String>',
        :'conversion_type' => :'Array<String>',
        :'medium' => :'String',
        :'product' => :'Array<String>',
        :'traffic_source' => :'Array<String>',
        :'value_proposition' => :'Array<String>',
        :'vertical_config_id' => :'String',
        :'age' => :'Array<String>',
        :'visitor_email' => :'Array<String>',
        :'visitor_id' => :'Array<String>',
        :'visitor_id_method' => :'Array<String>',
        :'visitor_name' => :'Array<String>',
        :'competitor' => :'Array<String>',
        :'countries' => :'Array<String>',
        :'customer_action_type' => :'Array<String>',
        :'end_date' => :'Date',
        :'entity_group' => :'Array<String>',
        :'entity_ids' => :'Array<String>',
        :'entity_type' => :'Array<String>',
        :'event_search_condition' => :'Array<String>',
        :'facebook_impression_type' => :'Array<String>',
        :'facebook_rsvp_type' => :'Array<String>',
        :'facebook_story_type' => :'Array<String>',
        :'folder_ids' => :'Array<Integer>',
        :'foursquare_checkin_age' => :'Array<String>',
        :'foursquare_checkin_gender' => :'String',
        :'foursquare_checkin_time_of_day' => :'Array<String>',
        :'foursquare_checkin_type' => :'String',
        :'frequent_words' => :'Array<String>',
        :'gender' => :'String',
        :'google_action_type' => :'Array<String>',
        :'google_query_type' => :'Array<String>',
        :'hours' => :'Array<Float>',
        :'instagram_content_type' => :'String',
        :'keyword' => :'Array<String>',
        :'listings_live_type' => :'String',
        :'location_ids' => :'Array<String>',
        :'location_labels' => :'Array<String>',
        :'match_position' => :'Array<String>',
        :'match_type' => :'Array<String>',
        :'max_search_frequency' => :'Float',
        :'min_search_frequency' => :'Float',
        :'page_types' => :'Array<String>',
        :'partners' => :'Array<Float>',
        :'platform_type' => :'Array<String>',
        :'publisher_suggestion_type' => :'Array<String>',
        :'query_template' => :'Array<String>',
        :'ratings' => :'Array<Integer>',
        :'review_labels' => :'Array<Float>',
        :'search_engine' => :'Array<String>',
        :'search_result_type' => :'Array<String>',
        :'search_terms' => :'String',
        :'sentiment_collection' => :'Array<Float>',
        :'start_date' => :'Date'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `Yext::AnalyticsFilter` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `Yext::AnalyticsFilter`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'answers_backend')
        if (value = attributes[:'answers_backend']).is_a?(Array)
          self.answers_backend = value
        end
      end

      if attributes.key?(:'answers_blank_search_term')
        self.answers_blank_search_term = attributes[:'answers_blank_search_term']
      end

      if attributes.key?(:'answers_click_label')
        self.answers_click_label = attributes[:'answers_click_label']
      end

      if attributes.key?(:'answers_click_type')
        self.answers_click_type = attributes[:'answers_click_type']
      end

      if attributes.key?(:'answers_click_url')
        self.answers_click_url = attributes[:'answers_click_url']
      end

      if attributes.key?(:'answers_cluster')
        self.answers_cluster = attributes[:'answers_cluster']
      end

      if attributes.key?(:'answers_configuration_version')
        if (value = attributes[:'answers_configuration_version']).is_a?(Array)
          self.answers_configuration_version = value
        end
      end

      if attributes.key?(:'answers_configuration_version_label')
        if (value = attributes[:'answers_configuration_version_label']).is_a?(Array)
          self.answers_configuration_version_label = value
        end
      end

      if attributes.key?(:'answers_direct_answer_click')
        self.answers_direct_answer_click = attributes[:'answers_direct_answer_click']
      end

      if attributes.key?(:'answers_direct_answer_field')
        self.answers_direct_answer_field = attributes[:'answers_direct_answer_field']
      end

      if attributes.key?(:'answers_direct_answer_field_type')
        if (value = attributes[:'answers_direct_answer_field_type']).is_a?(Array)
          self.answers_direct_answer_field_type = value
        end
      end

      if attributes.key?(:'answers_direct_answer_field_value')
        self.answers_direct_answer_field_value = attributes[:'answers_direct_answer_field_value']
      end

      if attributes.key?(:'answers_direct_answer_type')
        if (value = attributes[:'answers_direct_answer_type']).is_a?(Array)
          self.answers_direct_answer_type = value
        end
      end

      if attributes.key?(:'answers_experience')
        if (value = attributes[:'answers_experience']).is_a?(Array)
          self.answers_experience = value
        end
      end

      if attributes.key?(:'answers_filter_key')
        if (value = attributes[:'answers_filter_key']).is_a?(Array)
          self.answers_filter_key = value
        end
      end

      if attributes.key?(:'answers_filter_operator')
        if (value = attributes[:'answers_filter_operator']).is_a?(Array)
          self.answers_filter_operator = value
        end
      end

      if attributes.key?(:'answers_filter_source')
        if (value = attributes[:'answers_filter_source']).is_a?(Array)
          self.answers_filter_source = value
        end
      end

      if attributes.key?(:'answers_filter_type')
        if (value = attributes[:'answers_filter_type']).is_a?(Array)
          self.answers_filter_type = value
        end
      end

      if attributes.key?(:'answers_filter_value')
        if (value = attributes[:'answers_filter_value']).is_a?(Array)
          self.answers_filter_value = value
        end
      end

      if attributes.key?(:'answers_has_case_start')
        self.answers_has_case_start = attributes[:'answers_has_case_start']
      end

      if attributes.key?(:'answers_has_case_submit')
        self.answers_has_case_submit = attributes[:'answers_has_case_submit']
      end

      if attributes.key?(:'answers_has_kg_results')
        self.answers_has_kg_results = attributes[:'answers_has_kg_results']
      end

      if attributes.key?(:'answers_has_search_term_cluster')
        self.answers_has_search_term_cluster = attributes[:'answers_has_search_term_cluster']
      end

      if attributes.key?(:'answers_has_voice_search')
        self.answers_has_voice_search = attributes[:'answers_has_voice_search']
      end

      if attributes.key?(:'answers_query_source')
        if (value = attributes[:'answers_query_source']).is_a?(Array)
          self.answers_query_source = value
        end
      end

      if attributes.key?(:'answers_raw_search_term')
        self.answers_raw_search_term = attributes[:'answers_raw_search_term']
      end

      if attributes.key?(:'answers_referrer_domain')
        self.answers_referrer_domain = attributes[:'answers_referrer_domain']
      end

      if attributes.key?(:'answers_referrer_page_url')
        self.answers_referrer_page_url = attributes[:'answers_referrer_page_url']
      end

      if attributes.key?(:'answers_result_entity_position')
        self.answers_result_entity_position = attributes[:'answers_result_entity_position']
      end

      if attributes.key?(:'answers_result_title')
        self.answers_result_title = attributes[:'answers_result_title']
      end

      if attributes.key?(:'answers_result_vertical_position')
        self.answers_result_vertical_position = attributes[:'answers_result_vertical_position']
      end

      if attributes.key?(:'answers_search_id')
        self.answers_search_id = attributes[:'answers_search_id']
      end

      if attributes.key?(:'answers_search_term')
        self.answers_search_term = attributes[:'answers_search_term']
      end

      if attributes.key?(:'answers_search_term_cluster_performance')
        if (value = attributes[:'answers_search_term_cluster_performance']).is_a?(Array)
          self.answers_search_term_cluster_performance = value
        end
      end

      if attributes.key?(:'answers_search_term_intent')
        self.answers_search_term_intent = attributes[:'answers_search_term_intent']
      end

      if attributes.key?(:'answers_search_vertical')
        if (value = attributes[:'answers_search_vertical']).is_a?(Array)
          self.answers_search_vertical = value
        end
      end

      if attributes.key?(:'answers_session_id')
        self.answers_session_id = attributes[:'answers_session_id']
      end

      if attributes.key?(:'answers_traffic_type')
        if (value = attributes[:'answers_traffic_type']).is_a?(Array)
          self.answers_traffic_type = value
        end
      end

      if attributes.key?(:'answers_user_browser')
        if (value = attributes[:'answers_user_browser']).is_a?(Array)
          self.answers_user_browser = value
        end
      end

      if attributes.key?(:'answers_user_city')
        self.answers_user_city = attributes[:'answers_user_city']
      end

      if attributes.key?(:'answers_user_country')
        self.answers_user_country = attributes[:'answers_user_country']
      end

      if attributes.key?(:'answers_user_device_class')
        self.answers_user_device_class = attributes[:'answers_user_device_class']
      end

      if attributes.key?(:'answers_user_lat_long')
        self.answers_user_lat_long = attributes[:'answers_user_lat_long']
      end

      if attributes.key?(:'answers_user_location_accuracy')
        self.answers_user_location_accuracy = attributes[:'answers_user_location_accuracy']
      end

      if attributes.key?(:'answers_user_postal_code')
        if (value = attributes[:'answers_user_postal_code']).is_a?(Array)
          self.answers_user_postal_code = value
        end
      end

      if attributes.key?(:'answers_user_region')
        if (value = attributes[:'answers_user_region']).is_a?(Array)
          self.answers_user_region = value
        end
      end

      if attributes.key?(:'answers_vertical_returned')
        if (value = attributes[:'answers_vertical_returned']).is_a?(Array)
          self.answers_vertical_returned = value
        end
      end

      if attributes.key?(:'click_type')
        if (value = attributes[:'click_type']).is_a?(Array)
          self.click_type = value
        end
      end

      if attributes.key?(:'configuration_version_label')
        if (value = attributes[:'configuration_version_label']).is_a?(Array)
          self.configuration_version_label = value
        end
      end

      if attributes.key?(:'conversion_type')
        if (value = attributes[:'conversion_type']).is_a?(Array)
          self.conversion_type = value
        end
      end

      if attributes.key?(:'medium')
        self.medium = attributes[:'medium']
      end

      if attributes.key?(:'product')
        if (value = attributes[:'product']).is_a?(Array)
          self.product = value
        end
      end

      if attributes.key?(:'traffic_source')
        if (value = attributes[:'traffic_source']).is_a?(Array)
          self.traffic_source = value
        end
      end

      if attributes.key?(:'value_proposition')
        if (value = attributes[:'value_proposition']).is_a?(Array)
          self.value_proposition = value
        end
      end

      if attributes.key?(:'vertical_config_id')
        self.vertical_config_id = attributes[:'vertical_config_id']
      end

      if attributes.key?(:'age')
        if (value = attributes[:'age']).is_a?(Array)
          self.age = value
        end
      end

      if attributes.key?(:'visitor_email')
        if (value = attributes[:'visitor_email']).is_a?(Array)
          self.visitor_email = value
        end
      end

      if attributes.key?(:'visitor_id')
        if (value = attributes[:'visitor_id']).is_a?(Array)
          self.visitor_id = value
        end
      end

      if attributes.key?(:'visitor_id_method')
        if (value = attributes[:'visitor_id_method']).is_a?(Array)
          self.visitor_id_method = value
        end
      end

      if attributes.key?(:'visitor_name')
        if (value = attributes[:'visitor_name']).is_a?(Array)
          self.visitor_name = value
        end
      end

      if attributes.key?(:'competitor')
        if (value = attributes[:'competitor']).is_a?(Array)
          self.competitor = value
        end
      end

      if attributes.key?(:'countries')
        if (value = attributes[:'countries']).is_a?(Array)
          self.countries = value
        end
      end

      if attributes.key?(:'customer_action_type')
        if (value = attributes[:'customer_action_type']).is_a?(Array)
          self.customer_action_type = value
        end
      end

      if attributes.key?(:'end_date')
        self.end_date = attributes[:'end_date']
      end

      if attributes.key?(:'entity_group')
        if (value = attributes[:'entity_group']).is_a?(Array)
          self.entity_group = value
        end
      end

      if attributes.key?(:'entity_ids')
        if (value = attributes[:'entity_ids']).is_a?(Array)
          self.entity_ids = value
        end
      end

      if attributes.key?(:'entity_type')
        if (value = attributes[:'entity_type']).is_a?(Array)
          self.entity_type = value
        end
      end

      if attributes.key?(:'event_search_condition')
        if (value = attributes[:'event_search_condition']).is_a?(Array)
          self.event_search_condition = value
        end
      end

      if attributes.key?(:'facebook_impression_type')
        if (value = attributes[:'facebook_impression_type']).is_a?(Array)
          self.facebook_impression_type = value
        end
      end

      if attributes.key?(:'facebook_rsvp_type')
        if (value = attributes[:'facebook_rsvp_type']).is_a?(Array)
          self.facebook_rsvp_type = value
        end
      end

      if attributes.key?(:'facebook_story_type')
        if (value = attributes[:'facebook_story_type']).is_a?(Array)
          self.facebook_story_type = value
        end
      end

      if attributes.key?(:'folder_ids')
        if (value = attributes[:'folder_ids']).is_a?(Array)
          self.folder_ids = value
        end
      end

      if attributes.key?(:'foursquare_checkin_age')
        if (value = attributes[:'foursquare_checkin_age']).is_a?(Array)
          self.foursquare_checkin_age = value
        end
      end

      if attributes.key?(:'foursquare_checkin_gender')
        self.foursquare_checkin_gender = attributes[:'foursquare_checkin_gender']
      end

      if attributes.key?(:'foursquare_checkin_time_of_day')
        if (value = attributes[:'foursquare_checkin_time_of_day']).is_a?(Array)
          self.foursquare_checkin_time_of_day = value
        end
      end

      if attributes.key?(:'foursquare_checkin_type')
        self.foursquare_checkin_type = attributes[:'foursquare_checkin_type']
      end

      if attributes.key?(:'frequent_words')
        if (value = attributes[:'frequent_words']).is_a?(Array)
          self.frequent_words = value
        end
      end

      if attributes.key?(:'gender')
        self.gender = attributes[:'gender']
      end

      if attributes.key?(:'google_action_type')
        if (value = attributes[:'google_action_type']).is_a?(Array)
          self.google_action_type = value
        end
      end

      if attributes.key?(:'google_query_type')
        if (value = attributes[:'google_query_type']).is_a?(Array)
          self.google_query_type = value
        end
      end

      if attributes.key?(:'hours')
        if (value = attributes[:'hours']).is_a?(Array)
          self.hours = value
        end
      end

      if attributes.key?(:'instagram_content_type')
        self.instagram_content_type = attributes[:'instagram_content_type']
      end

      if attributes.key?(:'keyword')
        if (value = attributes[:'keyword']).is_a?(Array)
          self.keyword = value
        end
      end

      if attributes.key?(:'listings_live_type')
        self.listings_live_type = attributes[:'listings_live_type']
      end

      if attributes.key?(:'location_ids')
        if (value = attributes[:'location_ids']).is_a?(Array)
          self.location_ids = value
        end
      end

      if attributes.key?(:'location_labels')
        if (value = attributes[:'location_labels']).is_a?(Array)
          self.location_labels = value
        end
      end

      if attributes.key?(:'match_position')
        if (value = attributes[:'match_position']).is_a?(Array)
          self.match_position = value
        end
      end

      if attributes.key?(:'match_type')
        if (value = attributes[:'match_type']).is_a?(Array)
          self.match_type = value
        end
      end

      if attributes.key?(:'max_search_frequency')
        self.max_search_frequency = attributes[:'max_search_frequency']
      end

      if attributes.key?(:'min_search_frequency')
        self.min_search_frequency = attributes[:'min_search_frequency']
      end

      if attributes.key?(:'page_types')
        if (value = attributes[:'page_types']).is_a?(Array)
          self.page_types = value
        end
      end

      if attributes.key?(:'partners')
        if (value = attributes[:'partners']).is_a?(Array)
          self.partners = value
        end
      end

      if attributes.key?(:'platform_type')
        if (value = attributes[:'platform_type']).is_a?(Array)
          self.platform_type = value
        end
      end

      if attributes.key?(:'publisher_suggestion_type')
        if (value = attributes[:'publisher_suggestion_type']).is_a?(Array)
          self.publisher_suggestion_type = value
        end
      end

      if attributes.key?(:'query_template')
        if (value = attributes[:'query_template']).is_a?(Array)
          self.query_template = value
        end
      end

      if attributes.key?(:'ratings')
        if (value = attributes[:'ratings']).is_a?(Array)
          self.ratings = value
        end
      end

      if attributes.key?(:'review_labels')
        if (value = attributes[:'review_labels']).is_a?(Array)
          self.review_labels = value
        end
      end

      if attributes.key?(:'search_engine')
        if (value = attributes[:'search_engine']).is_a?(Array)
          self.search_engine = value
        end
      end

      if attributes.key?(:'search_result_type')
        if (value = attributes[:'search_result_type']).is_a?(Array)
          self.search_result_type = value
        end
      end

      if attributes.key?(:'search_terms')
        self.search_terms = attributes[:'search_terms']
      end

      if attributes.key?(:'sentiment_collection')
        if (value = attributes[:'sentiment_collection']).is_a?(Array)
          self.sentiment_collection = value
        end
      end

      if attributes.key?(:'start_date')
        self.start_date = attributes[:'start_date']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      foursquare_checkin_gender_validator = EnumAttributeValidator.new('String', ["FEMALE", "MALE"])
      return false unless foursquare_checkin_gender_validator.valid?(@foursquare_checkin_gender)
      foursquare_checkin_type_validator = EnumAttributeValidator.new('String', ["NEW", "REPEAT"])
      return false unless foursquare_checkin_type_validator.valid?(@foursquare_checkin_type)
      gender_validator = EnumAttributeValidator.new('String', ["FEMALE", "MALE", "UNIDENTIFIED"])
      return false unless gender_validator.valid?(@gender)
      instagram_content_type_validator = EnumAttributeValidator.new('String', ["PHOTO", "VIDEO"])
      return false unless instagram_content_type_validator.valid?(@instagram_content_type)
      listings_live_type_validator = EnumAttributeValidator.new('String', ["CLAIMED", "CREATED"])
      return false unless listings_live_type_validator.valid?(@listings_live_type)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] foursquare_checkin_gender Object to be assigned
    def foursquare_checkin_gender=(foursquare_checkin_gender)
      validator = EnumAttributeValidator.new('String', ["FEMALE", "MALE"])
      unless validator.valid?(foursquare_checkin_gender)
        fail ArgumentError, "invalid value for \"foursquare_checkin_gender\", must be one of #{validator.allowable_values}."
      end
      @foursquare_checkin_gender = foursquare_checkin_gender
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] foursquare_checkin_type Object to be assigned
    def foursquare_checkin_type=(foursquare_checkin_type)
      validator = EnumAttributeValidator.new('String', ["NEW", "REPEAT"])
      unless validator.valid?(foursquare_checkin_type)
        fail ArgumentError, "invalid value for \"foursquare_checkin_type\", must be one of #{validator.allowable_values}."
      end
      @foursquare_checkin_type = foursquare_checkin_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] gender Object to be assigned
    def gender=(gender)
      validator = EnumAttributeValidator.new('String', ["FEMALE", "MALE", "UNIDENTIFIED"])
      unless validator.valid?(gender)
        fail ArgumentError, "invalid value for \"gender\", must be one of #{validator.allowable_values}."
      end
      @gender = gender
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] instagram_content_type Object to be assigned
    def instagram_content_type=(instagram_content_type)
      validator = EnumAttributeValidator.new('String', ["PHOTO", "VIDEO"])
      unless validator.valid?(instagram_content_type)
        fail ArgumentError, "invalid value for \"instagram_content_type\", must be one of #{validator.allowable_values}."
      end
      @instagram_content_type = instagram_content_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] listings_live_type Object to be assigned
    def listings_live_type=(listings_live_type)
      validator = EnumAttributeValidator.new('String', ["CLAIMED", "CREATED"])
      unless validator.valid?(listings_live_type)
        fail ArgumentError, "invalid value for \"listings_live_type\", must be one of #{validator.allowable_values}."
      end
      @listings_live_type = listings_live_type
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          answers_backend == o.answers_backend &&
          answers_blank_search_term == o.answers_blank_search_term &&
          answers_click_label == o.answers_click_label &&
          answers_click_type == o.answers_click_type &&
          answers_click_url == o.answers_click_url &&
          answers_cluster == o.answers_cluster &&
          answers_configuration_version == o.answers_configuration_version &&
          answers_configuration_version_label == o.answers_configuration_version_label &&
          answers_direct_answer_click == o.answers_direct_answer_click &&
          answers_direct_answer_field == o.answers_direct_answer_field &&
          answers_direct_answer_field_type == o.answers_direct_answer_field_type &&
          answers_direct_answer_field_value == o.answers_direct_answer_field_value &&
          answers_direct_answer_type == o.answers_direct_answer_type &&
          answers_experience == o.answers_experience &&
          answers_filter_key == o.answers_filter_key &&
          answers_filter_operator == o.answers_filter_operator &&
          answers_filter_source == o.answers_filter_source &&
          answers_filter_type == o.answers_filter_type &&
          answers_filter_value == o.answers_filter_value &&
          answers_has_case_start == o.answers_has_case_start &&
          answers_has_case_submit == o.answers_has_case_submit &&
          answers_has_kg_results == o.answers_has_kg_results &&
          answers_has_search_term_cluster == o.answers_has_search_term_cluster &&
          answers_has_voice_search == o.answers_has_voice_search &&
          answers_query_source == o.answers_query_source &&
          answers_raw_search_term == o.answers_raw_search_term &&
          answers_referrer_domain == o.answers_referrer_domain &&
          answers_referrer_page_url == o.answers_referrer_page_url &&
          answers_result_entity_position == o.answers_result_entity_position &&
          answers_result_title == o.answers_result_title &&
          answers_result_vertical_position == o.answers_result_vertical_position &&
          answers_search_id == o.answers_search_id &&
          answers_search_term == o.answers_search_term &&
          answers_search_term_cluster_performance == o.answers_search_term_cluster_performance &&
          answers_search_term_intent == o.answers_search_term_intent &&
          answers_search_vertical == o.answers_search_vertical &&
          answers_session_id == o.answers_session_id &&
          answers_traffic_type == o.answers_traffic_type &&
          answers_user_browser == o.answers_user_browser &&
          answers_user_city == o.answers_user_city &&
          answers_user_country == o.answers_user_country &&
          answers_user_device_class == o.answers_user_device_class &&
          answers_user_lat_long == o.answers_user_lat_long &&
          answers_user_location_accuracy == o.answers_user_location_accuracy &&
          answers_user_postal_code == o.answers_user_postal_code &&
          answers_user_region == o.answers_user_region &&
          answers_vertical_returned == o.answers_vertical_returned &&
          click_type == o.click_type &&
          configuration_version_label == o.configuration_version_label &&
          conversion_type == o.conversion_type &&
          medium == o.medium &&
          product == o.product &&
          traffic_source == o.traffic_source &&
          value_proposition == o.value_proposition &&
          vertical_config_id == o.vertical_config_id &&
          age == o.age &&
          visitor_email == o.visitor_email &&
          visitor_id == o.visitor_id &&
          visitor_id_method == o.visitor_id_method &&
          visitor_name == o.visitor_name &&
          competitor == o.competitor &&
          countries == o.countries &&
          customer_action_type == o.customer_action_type &&
          end_date == o.end_date &&
          entity_group == o.entity_group &&
          entity_ids == o.entity_ids &&
          entity_type == o.entity_type &&
          event_search_condition == o.event_search_condition &&
          facebook_impression_type == o.facebook_impression_type &&
          facebook_rsvp_type == o.facebook_rsvp_type &&
          facebook_story_type == o.facebook_story_type &&
          folder_ids == o.folder_ids &&
          foursquare_checkin_age == o.foursquare_checkin_age &&
          foursquare_checkin_gender == o.foursquare_checkin_gender &&
          foursquare_checkin_time_of_day == o.foursquare_checkin_time_of_day &&
          foursquare_checkin_type == o.foursquare_checkin_type &&
          frequent_words == o.frequent_words &&
          gender == o.gender &&
          google_action_type == o.google_action_type &&
          google_query_type == o.google_query_type &&
          hours == o.hours &&
          instagram_content_type == o.instagram_content_type &&
          keyword == o.keyword &&
          listings_live_type == o.listings_live_type &&
          location_ids == o.location_ids &&
          location_labels == o.location_labels &&
          match_position == o.match_position &&
          match_type == o.match_type &&
          max_search_frequency == o.max_search_frequency &&
          min_search_frequency == o.min_search_frequency &&
          page_types == o.page_types &&
          partners == o.partners &&
          platform_type == o.platform_type &&
          publisher_suggestion_type == o.publisher_suggestion_type &&
          query_template == o.query_template &&
          ratings == o.ratings &&
          review_labels == o.review_labels &&
          search_engine == o.search_engine &&
          search_result_type == o.search_result_type &&
          search_terms == o.search_terms &&
          sentiment_collection == o.sentiment_collection &&
          start_date == o.start_date
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [answers_backend, answers_blank_search_term, answers_click_label, answers_click_type, answers_click_url, answers_cluster, answers_configuration_version, answers_configuration_version_label, answers_direct_answer_click, answers_direct_answer_field, answers_direct_answer_field_type, answers_direct_answer_field_value, answers_direct_answer_type, answers_experience, answers_filter_key, answers_filter_operator, answers_filter_source, answers_filter_type, answers_filter_value, answers_has_case_start, answers_has_case_submit, answers_has_kg_results, answers_has_search_term_cluster, answers_has_voice_search, answers_query_source, answers_raw_search_term, answers_referrer_domain, answers_referrer_page_url, answers_result_entity_position, answers_result_title, answers_result_vertical_position, answers_search_id, answers_search_term, answers_search_term_cluster_performance, answers_search_term_intent, answers_search_vertical, answers_session_id, answers_traffic_type, answers_user_browser, answers_user_city, answers_user_country, answers_user_device_class, answers_user_lat_long, answers_user_location_accuracy, answers_user_postal_code, answers_user_region, answers_vertical_returned, click_type, configuration_version_label, conversion_type, medium, product, traffic_source, value_proposition, vertical_config_id, age, visitor_email, visitor_id, visitor_id_method, visitor_name, competitor, countries, customer_action_type, end_date, entity_group, entity_ids, entity_type, event_search_condition, facebook_impression_type, facebook_rsvp_type, facebook_story_type, folder_ids, foursquare_checkin_age, foursquare_checkin_gender, foursquare_checkin_time_of_day, foursquare_checkin_type, frequent_words, gender, google_action_type, google_query_type, hours, instagram_content_type, keyword, listings_live_type, location_ids, location_labels, match_position, match_type, max_search_frequency, min_search_frequency, page_types, partners, platform_type, publisher_suggestion_type, query_template, ratings, review_labels, search_engine, search_result_type, search_terms, sentiment_collection, start_date].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          self.send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = Yext.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
