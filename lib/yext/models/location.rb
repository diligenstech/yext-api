=begin
#Yext Admin API

#No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 2.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.0.0

=end

require 'date'
require 'time'

module Yext
  class Location
    # Primary key. Unique alphanumeric (Latin-1) ID assigned by the Customer.
    attr_accessor :id

    # A static globally unique id for the location. Note that this field cannot be used in place of the location id in API calls to get or update location information.
    attr_accessor :uid

    # Must refer to an **account.id** that already exists.
    attr_accessor :account_id

    # The timestamp of the most recent change to this location record.  Will be ignored when the client is saving location data to Yext.  **NOTE:** The timestamp may change even if observable fields stay the same. 
    attr_accessor :timestamp

    # The timezone of the location 
    attr_accessor :timezone

    attr_accessor :location_type

    # Cannot include: * inappropriate language * HTML markup or entities * a URL or domain name * a phone number * control characters ([\\x00-\\x1F\\x7F])  Should be in appropriate letter case (e.g., not in all capital letters) 
    attr_accessor :location_name

    # The first name of the healthcare professional  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :first_name

    # The middle name of the healthcare professional  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :middle_name

    # The last name of the healthcare professional  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :last_name

    # The name of the office where the healthcare professional works, if different from **locationName**  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :office_name

    # The gender of the healthcare professional  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :gender

    # The National Provider Identifier (NPI) of the healthcare provider  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL` or `HEALTHCARE_FACILITY`. 
    attr_accessor :npi

    # Must be a valid address  Cannot be a P.O. Box 
    attr_accessor :address

    # Cannot be a P.O. Box
    attr_accessor :address2

    # If true, do not show street address on listings. Defaults to false.
    attr_accessor :suppress_address

    # Provides additional information to help consumers get to the location. This string appears along with the location's address (e.g., In Menlo Mall, 3rd Floor).  It may also be used in conjunction with a hidden address (i.e., when **suppressAddress** is true) to give consumers information about where the location is found (e.g., Servicing the New York area).  Cannot be a P.O. Box 
    attr_accessor :display_address

    attr_accessor :city

    # For US locations, the two-character code of the location’s state, or DC for the District of Columbia For non-US locations, the name of the location’s province / region / state 
    attr_accessor :state

    # The name of the location's sublocality.
    attr_accessor :sublocality

    # The location's postal code. For US locations, this field contains the five- or nine-digit ZIP code (the hyphen is optional). Validations are only done on `zip` if `countryCode` is US.
    attr_accessor :zip

    # The two-character ISO 3166-1 code of the location's country or region. If omitted, US is used.
    attr_accessor :country_code

    attr_accessor :service_area

    # Must be a valid phone number.
    attr_accessor :phone

    # Set to true if the number listed in **phone** is a tracked phone number.  **NOTE:** When updating **isPhoneTracked**, you must provide a value for **phone** in the same request. 
    attr_accessor :is_phone_tracked

    # Must be a valid, non-toll-free phone number.  Required if: * **isPhoneTracked** is true and the non-tracked number is a toll-free number, **OR** * **isPhoneTracked** is false and **phone** is a toll-free number 
    attr_accessor :local_phone

    # Must be a valid phone number, based on the country specified in `countryCode`. Phone numbers for US locations must contain 10 digits.
    attr_accessor :alternate_phone

    # Must be a valid phone number, based on the country specified in `countryCode`. Phone numbers for US locations must contain 10 digits.
    attr_accessor :fax_phone

    # Must be a valid phone number, based on the country specified in `countryCode`. Phone numbers for US locations must contain 10 digits.
    attr_accessor :mobile_phone

    # Must be a valid phone number, based on the country specified in `countryCode`. Phone numbers for US locations must contain 10 digits.
    attr_accessor :toll_free_phone

    # Must be a valid phone number, based on the country specified in `countryCode`. Phone numbers for US locations must contain 10 digits.
    attr_accessor :tty_phone

    # Yext Category IDs. A Location must have at least one and at most 10 Categories.  IDs must be valid and selectable (i.e., cannot be parent categories).  **NOTE:** The list of category IDs that you send us must be comprehensive. For example, if you send us a list of IDs that does not include IDs that you sent in your last update, Yext considers the missing categories to be deleted, and we remove them from your listings. 
    attr_accessor :category_ids

    # The Featured Message. Default: Call today!  Cannot include: * inappropriate language * HTML markup * a URL or domain name * a phone number * control characters ([\\x00-\\x1F\\x7F]) * insufficient spacing  If you submit a Featured Message that contains profanity or more than 50 characters, it will be ignored. The success response will contain a warning message explaining why your Featured Message wasn't stored in the system. 
    attr_accessor :featured_message

    # Valid URL to which the Featured Message is linked
    attr_accessor :featured_message_url

    # The URL of the location's website. This URL will be shown on your listings unless you specify a value for `displayWebsiteUrl`.  Must be a valid URL and is required whenever `displayWebsiteUrl` is specified. 
    attr_accessor :website_url

    # The URL that is shown on your listings in place of `websiteUrl`. You can use `displayWebsiteUrl` to display a short, memorable web address that redirects consumers to the URL given in `websiteUrl`.  Must be a valid URL and be specified along with `websiteUrl`. 
    attr_accessor :display_website_url

    # A valid URL used for reservations at this location.
    attr_accessor :reservation_url

    # The URL that is shown on your listings in place of `reservationUrl`. You can use `displayReservationUrl` to display a short, memorable web address that redirects consumers to the URL given in `reservationUrl`.  Must be a valid URL and be specified along with `reservationUrl`. 
    attr_accessor :display_reservation_url

    # The URL of the location's menu.
    attr_accessor :menu_url

    # The URL that is shown on your listings in place of `menuUrl`. You can use `displayMenuUrl` to display a short, memorable web address that redirects consumers to the URL given in `menuUrl`.  Must be a valid URL and be specified along with `menuUrl`. 
    attr_accessor :display_menu_url

    # The URL used to place orders that will be fulfilled at the location.
    attr_accessor :order_url

    # The URL that is shown on your listings in place of `orderUrl`. You can use `displayOrderUrl` to display a short, memorable web address that redirects consumers to the URL given in `orderUrl`.  Must be a valid URL and be specified along with `orderUrl`. 
    attr_accessor :display_order_url

    # Hours should be submitted as a comma-separated list of days, where each day's hours are specified as follows:  d:oh:om:ch:cm * d = day of the week –   * 1 – Sunday   * 2 – Monday   * 3 – Tuesday   * 4 – Wednesday   * 5 – Thursday   * 6 – Friday   * 7 – Saturday * oh:om = opening time in 24-hour format * ch:cm = closing time in 24-hour format  Times with single-digit hours (e.g., 9 AM) can be submitted with or without a leading zero (9:00 or 09:00).  **Example:** open 9 AM to 5 PM Monday and Tuesday, open 10 AM to 4 PM on Saturday – 2:9:00:17:00,3:9:00:17:00,7:10:00:16:00  SPECIAL CASES: * To indicate that a location is open 24 hours on a specific day, set 00:00 as both the opening and closing time for that day.   * **Example:** open all day on Saturdays – 7:00:00:00:00 * To indicate that a location is closed on a specific day, omit that day from the list or set it as closed (\"closed\" is not case sensitive).   * **Example:** closed on Sundays – 1:closed   * **NOTE:** If a location is closed seven days a week, set at least one day to closed. Otherwise, **hours** is an empty string, and we assume you are not submitting hours information for that location. * To indicate that a location has split hours on a specific day, submit a set of hours for each block of time the location is open.   * **Example:** open from 9:00 AM to 12:00 PM and again from 1:00 PM to 5:00 PM on Mondays – 2:9:00:12:00,2:13:00:17:00  **NOTE:** To set hours for specific days of the year rather than days of the week, use **holidayHours**. 
    attr_accessor :hours

    # Additional information about business hours that does not fit in **hours** (e.g., Closed during the winter)
    attr_accessor :additional_hours_text

    # Holiday hours for this location.  **NOTE:** hours must be set in order for holidayHours to appear on your listings) 
    attr_accessor :holiday_hours

    attr_accessor :description

    # A list of the conditions treated by the healthcare provider  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL` or `HEALTHCARE_FACILITY`. 
    attr_accessor :conditions_treated

    # A list of the certifications held by the healthcare professional  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :certifications

    # A list of the types of education and training completed by the healthcare professional  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :education_list

    # A list of the degrees earned by the healthcare professional  **NOTE:**  This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`.  Valid values:  * `ANP` (Adult Nurse Practitioner) * `APN` (Advanced Practice Nurse) * `APRN` (Advanced Practice Registered Nurse) * `ARNP` (Advanced Registered Nurse Practitioner) * `CNM` (Certified Nurse Midwife) * `CNP` (Certified Nurse Practitioner) * `CNS` (Clinical Nurse Specialist) * `CPNP` (Certified Pediatric Nurse Practitioner) * `CRNA` (Certified Registered Nurse Anesthetist) * `CRNP` (Certified Registered Nurse Practitioner) * `DC` (Doctor of Chiropractic) * `DDS` (Doctor of Dental Surgery) * `DMD` (Doctor of Dental Medicine) * `DO` (Doctor of Osteopathy) * `DPM` (Doctor of Podiatric Medicine) * `DVM` (Doctor of Veterinary Medicine) * `FNP` (Family Nurse Practitioner) * `GNP` (Geriatric Nurse Practitioner) * `LAC` (Licensed Acupuncturist) * `LPN` (Licensed Practical Nurse) * `MD` (Medical Doctor) * `ND` (Naturopathic Doctor) * `NP` (Nurse Practitioner) * `OD` (Doctor of Optometry) * `PA` (Physician Assistant) * `PAC` (Physician Assistant Certified) * `PHARMD` (Doctor of Pharmacy) * `PHD` (Doctor of Philosophy) * `PNP` (Pediatric Nurse Practitioner) * `VMD` (Veterinary Medical Doctor) * `WHNP` (Womens Health Nurse Practitioner) 
    attr_accessor :degrees

    # A list of hospitals where the healthcare professional admits patients  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :admitting_hospitals

    # Indicates whether the healthcare provider is accepting new patients  Default is true  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL` or `HEALTHCARE_FACILITY`. 
    attr_accessor :accepting_new_patients

    attr_accessor :closed

    # The payment methods accepted at this location  Valid elements depend on the location's country. For US locations, valid elements are: * AMERICANEXPRESS * CASH * CHECK * DINERSCLUB * DISCOVER * FINANCING * INVOICE * MASTERCARD * TRAVELERSCHECK * VISA * ANDROIDPAY * APPLEPAY * SAMSUNGPAY * BITCOIN * PAYPAL 
    attr_accessor :payment_options

    # A list of insurance policies accepted by the healthcare provider  **NOTE:** This field is only available to locations whose **`locationType`** is `HEALTHCARE_PROFESSIONAL`. 
    attr_accessor :insurance_accepted

    attr_accessor :logo

    # Up to 50 Photos.  **NOTE:** The list of photos that you send us must be comprehensive. For example, if you send us a list of photos that does not include photos that you sent in your last update, Yext considers the missing photos to be deleted, and we remove them from your listings. 
    attr_accessor :photos

    attr_accessor :headshot

    # Valid YouTube URLs for embedding a video on some publisher sites.  **NOTE:** Currently, only the first URL in the Array appears in your listings. 
    attr_accessor :video_urls

    # Valid Instagram username for the location (e.g., NewCityFiat (without the leading \"@\"))
    attr_accessor :instagram_handle

    # Valid Twitter handle for the location (e.g., JohnSmith (without the leading '@')). If you submit an invalid Twitter handle, it will be ignored. The success response will contain a warning message explaining why your Twitter handle wasn't stored in the system.
    attr_accessor :twitter_handle

    # The URL you would like to submit to Google Business Profile in place of the one given in **websiteUrl** (if applicable).  For example, if you want to analyze the traffic driven by your Google listings separately from other traffic, enter the alternate URL that you will use for tracking in this field. 
    attr_accessor :google_website_override

    attr_accessor :google_cover_photo

    attr_accessor :google_profile_photo

    # The Google Business Profile attributes for this location. 
    attr_accessor :google_attributes

    # URL for the location's Facebook Page.  Valid formats: * facebook.com/profile.php?id=[numId] * facebook.com/group.php?gid=[numId] * facebook.com/groups/[numId] * facebook.com/[Name] * facebook.com/pages/[Name]/[numId]  where [Name] is a String and [numId] is an Integer  If you submit a URL that is not in one of the valid formats, it will be ignored. The success response will contain a warning message explaining why the URL wasn't stored in the system.  **NOTE:** This value is automatically set to the location's Facebook Page URL. You can only manually set **facebookPageUrl** if the location meets one of the following criteria: * It is not subscribed to a Listings package that contains Facebook. * It is opted out of Facebook. 
    attr_accessor :facebook_page_url

    attr_accessor :facebook_call_to_action

    attr_accessor :facebook_cover_photo

    attr_accessor :facebook_profile_picture

    # Indicates whether the embedded Uber link for this location appears as text or a button  When consumers click on this link on a mobile device, the Uber app (if installed) will open with your location set as the trip destination. If the Uber app is not installed, the consumer will be prompted to download it. 
    attr_accessor :uber_link_type

    # The text of the embedded Uber link  Default is \"Ride there with Uber\".  **NOTE:** This field is only available if **uberLinkType** is LINK. 
    attr_accessor :uber_link_text

    # The text of the call-to-action that will appear in the Uber app during a trip to your location (e.g., Check out our menu!)  **NOTE:** If a value for **uberTripBrandingText** is provided, values must also be provided for **uberTripBrandingUrl** and **uberTripBrandingDescription**. 
    attr_accessor :uber_trip_branding_text

    # The URL that the consumer will be redirected to when tapping on the call-to-action in the Uber app during a trip to your location.  **NOTE:** If a value for **uberTripBrandingUrl** is provided, values must also be provided for **uberTripBrandingText** and **uberTripBrandingDescription**. 
    attr_accessor :uber_trip_branding_url

    # A longer description that will appear near the call-to-action in the Uber app during a trip to your location.  **NOTE:** If a value for **uberTripBrandingDescription** is provided, values must also be provided for **uberTripBrandingText** and **uberTripBrandingUrl**. 
    attr_accessor :uber_trip_branding_description

    # The Yext-powered code that can be copied and pasted into the markup of emails or web pages where the embedded Uber link should appear
    attr_accessor :uber_embed_code

    # The Yext-powered link that can be copied and pasted into the markup of Yext Pages where the embedded Uber link should appear
    attr_accessor :uber_link

    # The Uber universal link for the location.  For more information on universal links, see Uber's developer documentation.  **NOTE**: This field is only available in the LiveAPI and only for US locations. 
    attr_accessor :uber_link_raw

    # The year that this location was opened, not the number of years it was open  Minimum of 1000, maximum of current year + 10. 
    attr_accessor :year_established

    # Latitude where the map pin should be displayed, as provided by you  Between -90.0 and 90.0, inclusive 
    attr_accessor :display_lat

    # Longitude where the map pin should be displayed, as provided by you  Between -180.0 and 180.0, inclusive 
    attr_accessor :display_lng

    # Latitude to use for driving directions to the location, as provided by you  Between -90.0 and 90.0, inclusive 
    attr_accessor :routable_lat

    # Longitude to use for driving directions to the location, as provided by you  Between -180.0 and 180.0, inclusive 
    attr_accessor :routable_lng

    # Latitude to use for walking directions to the location, as provided by you  Between -90.0 and 90.0, inclusive 
    attr_accessor :walkable_lat

    # Longitude to use for walking directions to the location, as provided by you  Between -180.0 and 180.0, inclusive 
    attr_accessor :walkable_lng

    # Latitude to use for pickup spot for the location, as provided by you  Between -90.0 and 90.0, inclusive 
    attr_accessor :pickup_lat

    # Longitude to use for pickup spot for the location, as provided by you  Between -180.0 and 180.0, inclusive 
    attr_accessor :pickup_lng

    # Latitude to use for drop off spot for the location, as provided by you  Between -90.0 and 90.0, inclusive 
    attr_accessor :dropoff_lat

    # Longitude to use for drop off spot for the location, as provided by you  Between -180.0 and 180.0, inclusive 
    attr_accessor :dropoff_lng

    # Latitude where the map pin should be displayed, as calculated by Yext  Between -90.0 and 90.0, inclusive 
    attr_accessor :yext_display_lat

    # Longitude where the map pin should be displayed, as calculated by Yext  Between -180.0 and 180.0, inclusive 
    attr_accessor :yext_display_lng

    # Latitude to use for driving directions to the location, as calculated by Yext  Between -90.0 and 90.0, inclusive 
    attr_accessor :yext_routable_lat

    # Longitude to use for driving directions to the location, as calculated by Yext  Between -180.0 and 180.0, inclusive 
    attr_accessor :yext_routable_lng

    # Latitude to use for walking directions to the location, as calculated by Yext  Between -90.0 and 90.0, inclusive 
    attr_accessor :yext_walkable_lat

    # Longitude to use for walking directions to the location, as calculated by Yext  Between -180.0 and 180.0, inclusive 
    attr_accessor :yext_walkable_lng

    # Latitude to use for pickup spot for the location, as calculated by Yext  Between -90.0 and 90.0, inclusive 
    attr_accessor :yext_pickup_lat

    # Longitude to use for pickup spot for the location, as calculated by Yext  Between -180.0 and 180.0, inclusive 
    attr_accessor :yext_pickup_lng

    # Latitude to use for drop off spot for the location, as calculated by Yext  Between -90.0 and 90.0, inclusive 
    attr_accessor :yext_dropoff_lat

    # Longitude to use for drop off spot for the location, as calculated by Yext  Between -180.0 and 180.0, inclusive 
    attr_accessor :yext_dropoff_lng

    # Up to five emails addresses for reaching this location  Must be valid email addresses 
    attr_accessor :emails

    # Up to 100 specialities (e.g., for food and dining: Chicago style)  All strings must be non-empty when trimmed of whitespace. 
    attr_accessor :specialities

    # Up to 100 association memberships relevant to the location (e.g., New York Doctors Association)  All strings must be non-empty when trimmed of whitespace. 
    attr_accessor :associations

    # Up to 100 products sold at this location  All strings must be non-empty when trimmed of whitespace. 
    attr_accessor :products

    # Up to 100 services offered at this location  All strings must be non-empty when trimmed of whitespace. 
    attr_accessor :services

    # Up to 100 brands sold by this location  All strings must be non-empty when trimmed of whitespace. 
    attr_accessor :brands

    # Language code of the language in which this location's information is provided. This language is considered the Location's primary language in our system.   If you would like to provide your Location data in more than one language, you can create a Language Profile for each of these additional (alternate) languages. 
    attr_accessor :language

    # Up to 100 languages spoken at this location.  All strings must be non-empty when trimmed of whitespace. 
    attr_accessor :languages

    # Up to 100 keywords may be provided  All strings must be non-empty when trimmed of whitespace. 
    attr_accessor :keywords

    # Label to be used for this location’s Menus. This label will appear on your location's listings.
    attr_accessor :menus_label

    # IDs of Menus associated with this location.
    attr_accessor :menu_ids

    # Label to be used for this location’s Bio lists. This label will appear on your location's listings.
    attr_accessor :bio_lists_label

    # IDs of Bio lists associated with this location.
    attr_accessor :bio_list_ids

    # Label to be used for this location’s Product & Services lists. This label will appear on your location's listings.
    attr_accessor :product_lists_label

    # IDs of Product lists associated with this location.
    attr_accessor :product_list_ids

    # Label to be used for this location’s Event lists. This label will appear on your location's listings.
    attr_accessor :event_lists_label

    # IDs of Event lists associated with this location.
    attr_accessor :event_list_ids

    # The folder that this location is in. Must be a valid, existing Yext Folder ID
    attr_accessor :folder_id

    # The IDs of the location labels that have been added to this location. Location labels help you identify locations that share a certain characteristic; they do not appear on your location's listings.  **NOTE:** You can only add labels that have already been created via our web interface. Currently, it is not possible to create new labels via the API.  In Locations: Update requests: * If the **`v`** parameter is before `20180223`: setting the value of **`labelIds`** to an empty array has no effect on the current value * If the **`v`** parameter is `20180223` or after: setting the value of **`labelIds`** to an empty array deletes the current value 
    attr_accessor :label_ids

    # A set of key-value pairs indicating the location's custom fields and their values. The keys are the **`ids`** of the custom fields, and the values are the fields' contents for this location.  To retrieve a list of custom fields for your account, use the Custom Fields: List endpoint.  If a field's **`type`** is `SINGLE_OPTION` or `MULTI_OPTION`, the option or options that apply to this location must be represented by their **`key`**s.  Examples of each type of custom field:  * BOOLEAN:     * `{ \"9662\": \"true\" }` * DAILY_TIMES:     * `{ \"10012\": { \"dailyTimes\": \"2:7:00,3:7:00,4:7:00,5:7:00,6:7:00,7:7:00,1:7:00\" } }` * DATE:     * `{ \"7066\": \"2016-10-12\" }` * GALLERY:     * `{ \"7070\": [ { \"url\": \"http://a.mktgcdn.com/p/ounkg7aq6Oy029-sRf4CIH64/128x128.jpg\" }, { \"url\": \"http://a.mktgcdn.com/p/YkQGqxK8jFBqOlailQ9QIBsgs/1.0000/316x316.png\" } ] }` * HOURS:     * `{ \"10011\": { \"hours\": \"1:7:00:20:00,2:7:00:20:00,3:7:00:20:00,4:7:00:20:00,5:7:00:20:00,6:7:00:20:00,7:7:00:20:00\", \"additionalHoursText\": \"Also by appointment\" }` * LOCATION_LIST:     * `{ \"8098\" : [ \"locationId1\", \"locationId2\" ] }` * MULTILINE_TEXT (up to 4,000 characters):     * `{ \"1592\": \"Take Route 13 south. Pass Riverrun Reservoir. At the traffic light before the post office, turn right off of Route 13. Pass the library and community center on your right and then pass a diner on your left. Cross over the bridge and at the third intersection, turn left onto Jones Street. We are located on the right side in the middle of the block.\" }` * MULTI_OPTION:     * `{ \"7068\": [\"2614\", \"2615\"] }` (`\"2614\"` and `\"2615\"` are the options' **`key`**s) * NUMBER:     * `{ \"7078\": \"123\" }` * PHOTO:     * `{ \"7071\": { \"url\": \"http://a.mktgcdn.com/p/bRtQXQZP2kEzgy2C8/800x800.jpg\", \"description\": \"New storefront\", \"details\": \"A picture of the new storefront\" } }`     * `{ \"7071\": null }` (This setting will clear the existing value of the Photo custom field.) * SINGLE_OPTION:     * `{ \"7069\": \"2617\" }` (`\"2617\"` is the option's **`key`**) * TEXT (up to 255 characters):     * `{ \"6157\": \"Buy One, Get One 50% Off\" }` * TEXT_LIST:     * `{ \"7072\": [ \"Item 1\", \"Item 2\", \"Item 3\" ] }` * URL:     * `{ \"9381\": \"http://www.location.example.com\" }` * VIDEO:     * `{ \"7077\": { \"url\": \"http://www.youtube.com/watch?v=6KQPho\" } }` * VIDEO_GALLERY:     * `{ \"8452\": [ { \"url\": \"http://www.youtube.com/watch?v=B1EC1U\" }, { \"url\": \"http://www.youtube.com/watch?v=SkEtnN\" } ] }` 
    attr_accessor :custom_fields

    # Indicates whether Intelligent Search Tracker is enabled.  The Intelligent Search Tracker allows you to understand your performance in local search. 
    attr_accessor :intelligent_search_tracking_enabled

    # How often we send search queries to track your search performance. 
    attr_accessor :intelligent_search_tracking_frequency

    # Keywords that we will use to track your search performance. These keywords are based on the location information you've stored in our system. 
    attr_accessor :location_keywords

    # Additional keywords you would like us to use when tracking your search performance 
    attr_accessor :custom_keywords

    # The ways in which your keywords will be arranged in the search queries we use to track your performance 
    attr_accessor :query_templates

    # Other names for your business that you would like us to use when tracking your search performance 
    attr_accessor :alternate_names

    # Other websites for your business that we should look for when tracking your search performance 
    attr_accessor :alternate_websites

    # The names and websites of the competitors whose search performance you would like to compare to your own 
    attr_accessor :competitors

    # The search engines that we will use to track your performance 
    attr_accessor :tracking_sites

    # The ISO 3166-2 region code for the location.  Yext will determine the location’s code and update isoRegionCode with that value. If Yext is unable to determine the code for the location, the location’s ISO 3166-1 alpha-2 country code will be used. 
    attr_accessor :iso_region_code

    # Link to the balancing URL that will auto-direct consumers to certain sites to leave reviews, based on review-generation settings 
    attr_accessor :review_balancing_url

    # Link to the review-collection page, where consumers can leave first-party reviews 
    attr_accessor :first_party_review_page

    # Indicates whether the location is the primary location in its group 
    attr_accessor :is_cluster_primary

    # List of Schema Types for this location, based on its categories 
    attr_accessor :schema_types

    # The formality of clothing typically worn at this location  **NOTE:** This field is only available to locations whose **`locationType`** is `RESTAURANT`. 
    attr_accessor :attire

    # The typical price of products sold at this location, on a scale of 1 (low) to 4 (high)  **NOTE:** This field is only available to locations whose **`locationType`** is `RESTAURANT`. 
    attr_accessor :price_range

    # Types of meals served at this location  **NOTE:** This field is only available to locations whose **`locationType`** is `RESTAURANT`.  Valid values:  * `BREAKFAST` * `LUNCH` * `BRUNCH` * `HAPPY_HOUR` * `LATE_NIGHT` 
    attr_accessor :meals_served

    # For ATMs, the external ID of the location that the ATM is installed in. The location must be in the same business account as the ATM.  **NOTE:** This field is only available to locations whose **`locationType`** is `ATM`. 
    attr_accessor :located_in

    # ID of the user who is the primary Knowledge Assistant contact for the entity 
    attr_accessor :primary_contact

    # Indicates whether or not review response conversations are enabled for the Yext Knowledge Assistant 
    attr_accessor :review_response_conversation_enabled

    # Indicates whether or not holiday hour confirmation alerts are enabled for the Yext Knowledge Assistant 
    attr_accessor :holiday_hours_confirmation_enabled

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'id' => :'id',
        :'uid' => :'uid',
        :'account_id' => :'accountId',
        :'timestamp' => :'timestamp',
        :'timezone' => :'timezone',
        :'location_type' => :'locationType',
        :'location_name' => :'locationName',
        :'first_name' => :'firstName',
        :'middle_name' => :'middleName',
        :'last_name' => :'lastName',
        :'office_name' => :'officeName',
        :'gender' => :'gender',
        :'npi' => :'npi',
        :'address' => :'address',
        :'address2' => :'address2',
        :'suppress_address' => :'suppressAddress',
        :'display_address' => :'displayAddress',
        :'city' => :'city',
        :'state' => :'state',
        :'sublocality' => :'sublocality',
        :'zip' => :'zip',
        :'country_code' => :'countryCode',
        :'service_area' => :'serviceArea',
        :'phone' => :'phone',
        :'is_phone_tracked' => :'isPhoneTracked',
        :'local_phone' => :'localPhone',
        :'alternate_phone' => :'alternatePhone',
        :'fax_phone' => :'faxPhone',
        :'mobile_phone' => :'mobilePhone',
        :'toll_free_phone' => :'tollFreePhone',
        :'tty_phone' => :'ttyPhone',
        :'category_ids' => :'categoryIds',
        :'featured_message' => :'featuredMessage',
        :'featured_message_url' => :'featuredMessageUrl',
        :'website_url' => :'websiteUrl',
        :'display_website_url' => :'displayWebsiteUrl',
        :'reservation_url' => :'reservationUrl',
        :'display_reservation_url' => :'displayReservationUrl',
        :'menu_url' => :'menuUrl',
        :'display_menu_url' => :'displayMenuUrl',
        :'order_url' => :'orderUrl',
        :'display_order_url' => :'displayOrderUrl',
        :'hours' => :'hours',
        :'additional_hours_text' => :'additionalHoursText',
        :'holiday_hours' => :'holidayHours',
        :'description' => :'description',
        :'conditions_treated' => :'conditionsTreated',
        :'certifications' => :'certifications',
        :'education_list' => :'educationList',
        :'degrees' => :'degrees',
        :'admitting_hospitals' => :'admittingHospitals',
        :'accepting_new_patients' => :'acceptingNewPatients',
        :'closed' => :'closed',
        :'payment_options' => :'paymentOptions',
        :'insurance_accepted' => :'insuranceAccepted',
        :'logo' => :'logo',
        :'photos' => :'photos',
        :'headshot' => :'headshot',
        :'video_urls' => :'videoUrls',
        :'instagram_handle' => :'instagramHandle',
        :'twitter_handle' => :'twitterHandle',
        :'google_website_override' => :'googleWebsiteOverride',
        :'google_cover_photo' => :'googleCoverPhoto',
        :'google_profile_photo' => :'googleProfilePhoto',
        :'google_attributes' => :'googleAttributes',
        :'facebook_page_url' => :'facebookPageUrl',
        :'facebook_call_to_action' => :'facebookCallToAction',
        :'facebook_cover_photo' => :'facebookCoverPhoto',
        :'facebook_profile_picture' => :'facebookProfilePicture',
        :'uber_link_type' => :'uberLinkType',
        :'uber_link_text' => :'uberLinkText',
        :'uber_trip_branding_text' => :'uberTripBrandingText',
        :'uber_trip_branding_url' => :'uberTripBrandingUrl',
        :'uber_trip_branding_description' => :'uberTripBrandingDescription',
        :'uber_embed_code' => :'uberEmbedCode',
        :'uber_link' => :'uberLink',
        :'uber_link_raw' => :'uberLinkRaw',
        :'year_established' => :'yearEstablished',
        :'display_lat' => :'displayLat',
        :'display_lng' => :'displayLng',
        :'routable_lat' => :'routableLat',
        :'routable_lng' => :'routableLng',
        :'walkable_lat' => :'walkableLat',
        :'walkable_lng' => :'walkableLng',
        :'pickup_lat' => :'pickupLat',
        :'pickup_lng' => :'pickupLng',
        :'dropoff_lat' => :'dropoffLat',
        :'dropoff_lng' => :'dropoffLng',
        :'yext_display_lat' => :'yextDisplayLat',
        :'yext_display_lng' => :'yextDisplayLng',
        :'yext_routable_lat' => :'yextRoutableLat',
        :'yext_routable_lng' => :'yextRoutableLng',
        :'yext_walkable_lat' => :'yextWalkableLat',
        :'yext_walkable_lng' => :'yextWalkableLng',
        :'yext_pickup_lat' => :'yextPickupLat',
        :'yext_pickup_lng' => :'yextPickupLng',
        :'yext_dropoff_lat' => :'yextDropoffLat',
        :'yext_dropoff_lng' => :'yextDropoffLng',
        :'emails' => :'emails',
        :'specialities' => :'specialities',
        :'associations' => :'associations',
        :'products' => :'products',
        :'services' => :'services',
        :'brands' => :'brands',
        :'language' => :'language',
        :'languages' => :'languages',
        :'keywords' => :'keywords',
        :'menus_label' => :'menusLabel',
        :'menu_ids' => :'menuIds',
        :'bio_lists_label' => :'bioListsLabel',
        :'bio_list_ids' => :'bioListIds',
        :'product_lists_label' => :'productListsLabel',
        :'product_list_ids' => :'productListIds',
        :'event_lists_label' => :'eventListsLabel',
        :'event_list_ids' => :'eventListIds',
        :'folder_id' => :'folderId',
        :'label_ids' => :'labelIds',
        :'custom_fields' => :'customFields',
        :'intelligent_search_tracking_enabled' => :'intelligentSearchTrackingEnabled',
        :'intelligent_search_tracking_frequency' => :'intelligentSearchTrackingFrequency',
        :'location_keywords' => :'locationKeywords',
        :'custom_keywords' => :'customKeywords',
        :'query_templates' => :'queryTemplates',
        :'alternate_names' => :'alternateNames',
        :'alternate_websites' => :'alternateWebsites',
        :'competitors' => :'competitors',
        :'tracking_sites' => :'trackingSites',
        :'iso_region_code' => :'isoRegionCode',
        :'review_balancing_url' => :'reviewBalancingURL',
        :'first_party_review_page' => :'firstPartyReviewPage',
        :'is_cluster_primary' => :'isClusterPrimary',
        :'schema_types' => :'schemaTypes',
        :'attire' => :'attire',
        :'price_range' => :'priceRange',
        :'meals_served' => :'mealsServed',
        :'located_in' => :'locatedIn',
        :'primary_contact' => :'primaryContact',
        :'review_response_conversation_enabled' => :'reviewResponseConversationEnabled',
        :'holiday_hours_confirmation_enabled' => :'holidayHoursConfirmationEnabled'
      }
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'id' => :'String',
        :'uid' => :'String',
        :'account_id' => :'String',
        :'timestamp' => :'Integer',
        :'timezone' => :'String',
        :'location_type' => :'LocationType',
        :'location_name' => :'String',
        :'first_name' => :'String',
        :'middle_name' => :'String',
        :'last_name' => :'String',
        :'office_name' => :'String',
        :'gender' => :'String',
        :'npi' => :'String',
        :'address' => :'String',
        :'address2' => :'String',
        :'suppress_address' => :'Boolean',
        :'display_address' => :'String',
        :'city' => :'String',
        :'state' => :'String',
        :'sublocality' => :'String',
        :'zip' => :'String',
        :'country_code' => :'String',
        :'service_area' => :'LocationServiceArea',
        :'phone' => :'String',
        :'is_phone_tracked' => :'Boolean',
        :'local_phone' => :'String',
        :'alternate_phone' => :'String',
        :'fax_phone' => :'String',
        :'mobile_phone' => :'String',
        :'toll_free_phone' => :'String',
        :'tty_phone' => :'String',
        :'category_ids' => :'Array<String>',
        :'featured_message' => :'String',
        :'featured_message_url' => :'String',
        :'website_url' => :'String',
        :'display_website_url' => :'String',
        :'reservation_url' => :'String',
        :'display_reservation_url' => :'String',
        :'menu_url' => :'String',
        :'display_menu_url' => :'String',
        :'order_url' => :'String',
        :'display_order_url' => :'String',
        :'hours' => :'String',
        :'additional_hours_text' => :'String',
        :'holiday_hours' => :'Array<LocationHolidayHoursInner>',
        :'description' => :'String',
        :'conditions_treated' => :'Array<String>',
        :'certifications' => :'Array<String>',
        :'education_list' => :'Array<LocationEducationListInner>',
        :'degrees' => :'Array<String>',
        :'admitting_hospitals' => :'Array<String>',
        :'accepting_new_patients' => :'Boolean',
        :'closed' => :'LocationClosed',
        :'payment_options' => :'Array<String>',
        :'insurance_accepted' => :'Array<String>',
        :'logo' => :'Photo',
        :'photos' => :'Array<Photo>',
        :'headshot' => :'LocationHeadshot',
        :'video_urls' => :'Array<String>',
        :'instagram_handle' => :'String',
        :'twitter_handle' => :'String',
        :'google_website_override' => :'String',
        :'google_cover_photo' => :'LocationGoogleCoverPhoto',
        :'google_profile_photo' => :'LocationGoogleProfilePhoto',
        :'google_attributes' => :'Array<LocationGoogleAttributesInner>',
        :'facebook_page_url' => :'String',
        :'facebook_call_to_action' => :'LocationFacebookCallToAction',
        :'facebook_cover_photo' => :'LocationFacebookCoverPhoto',
        :'facebook_profile_picture' => :'LocationFacebookProfilePicture',
        :'uber_link_type' => :'String',
        :'uber_link_text' => :'String',
        :'uber_trip_branding_text' => :'String',
        :'uber_trip_branding_url' => :'String',
        :'uber_trip_branding_description' => :'String',
        :'uber_embed_code' => :'String',
        :'uber_link' => :'String',
        :'uber_link_raw' => :'String',
        :'year_established' => :'String',
        :'display_lat' => :'Float',
        :'display_lng' => :'Float',
        :'routable_lat' => :'Float',
        :'routable_lng' => :'Float',
        :'walkable_lat' => :'Float',
        :'walkable_lng' => :'Float',
        :'pickup_lat' => :'Float',
        :'pickup_lng' => :'Float',
        :'dropoff_lat' => :'Float',
        :'dropoff_lng' => :'Float',
        :'yext_display_lat' => :'Float',
        :'yext_display_lng' => :'Float',
        :'yext_routable_lat' => :'Float',
        :'yext_routable_lng' => :'Float',
        :'yext_walkable_lat' => :'Float',
        :'yext_walkable_lng' => :'Float',
        :'yext_pickup_lat' => :'Float',
        :'yext_pickup_lng' => :'Float',
        :'yext_dropoff_lat' => :'Float',
        :'yext_dropoff_lng' => :'Float',
        :'emails' => :'Array<String>',
        :'specialities' => :'Array<String>',
        :'associations' => :'Array<String>',
        :'products' => :'Array<String>',
        :'services' => :'Array<String>',
        :'brands' => :'Array<String>',
        :'language' => :'String',
        :'languages' => :'Array<String>',
        :'keywords' => :'Array<String>',
        :'menus_label' => :'String',
        :'menu_ids' => :'Array<String>',
        :'bio_lists_label' => :'String',
        :'bio_list_ids' => :'Array<String>',
        :'product_lists_label' => :'String',
        :'product_list_ids' => :'Array<String>',
        :'event_lists_label' => :'String',
        :'event_list_ids' => :'Array<String>',
        :'folder_id' => :'String',
        :'label_ids' => :'Array<String>',
        :'custom_fields' => :'Hash<String, Object>',
        :'intelligent_search_tracking_enabled' => :'Boolean',
        :'intelligent_search_tracking_frequency' => :'String',
        :'location_keywords' => :'Array<String>',
        :'custom_keywords' => :'Array<String>',
        :'query_templates' => :'Array<String>',
        :'alternate_names' => :'Array<String>',
        :'alternate_websites' => :'Array<String>',
        :'competitors' => :'Array<LocationCompetitorsInner>',
        :'tracking_sites' => :'Array<String>',
        :'iso_region_code' => :'String',
        :'review_balancing_url' => :'String',
        :'first_party_review_page' => :'String',
        :'is_cluster_primary' => :'Boolean',
        :'schema_types' => :'Array<String>',
        :'attire' => :'String',
        :'price_range' => :'String',
        :'meals_served' => :'Array<String>',
        :'located_in' => :'String',
        :'primary_contact' => :'String',
        :'review_response_conversation_enabled' => :'Boolean',
        :'holiday_hours_confirmation_enabled' => :'Boolean'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `Yext::Location` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `Yext::Location`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.key?(:'uid')
        self.uid = attributes[:'uid']
      end

      if attributes.key?(:'account_id')
        self.account_id = attributes[:'account_id']
      end

      if attributes.key?(:'timestamp')
        self.timestamp = attributes[:'timestamp']
      end

      if attributes.key?(:'timezone')
        self.timezone = attributes[:'timezone']
      end

      if attributes.key?(:'location_type')
        self.location_type = attributes[:'location_type']
      end

      if attributes.key?(:'location_name')
        self.location_name = attributes[:'location_name']
      end

      if attributes.key?(:'first_name')
        self.first_name = attributes[:'first_name']
      end

      if attributes.key?(:'middle_name')
        self.middle_name = attributes[:'middle_name']
      end

      if attributes.key?(:'last_name')
        self.last_name = attributes[:'last_name']
      end

      if attributes.key?(:'office_name')
        self.office_name = attributes[:'office_name']
      end

      if attributes.key?(:'gender')
        self.gender = attributes[:'gender']
      end

      if attributes.key?(:'npi')
        self.npi = attributes[:'npi']
      end

      if attributes.key?(:'address')
        self.address = attributes[:'address']
      end

      if attributes.key?(:'address2')
        self.address2 = attributes[:'address2']
      end

      if attributes.key?(:'suppress_address')
        self.suppress_address = attributes[:'suppress_address']
      end

      if attributes.key?(:'display_address')
        self.display_address = attributes[:'display_address']
      end

      if attributes.key?(:'city')
        self.city = attributes[:'city']
      end

      if attributes.key?(:'state')
        self.state = attributes[:'state']
      end

      if attributes.key?(:'sublocality')
        self.sublocality = attributes[:'sublocality']
      end

      if attributes.key?(:'zip')
        self.zip = attributes[:'zip']
      end

      if attributes.key?(:'country_code')
        self.country_code = attributes[:'country_code']
      end

      if attributes.key?(:'service_area')
        self.service_area = attributes[:'service_area']
      end

      if attributes.key?(:'phone')
        self.phone = attributes[:'phone']
      end

      if attributes.key?(:'is_phone_tracked')
        self.is_phone_tracked = attributes[:'is_phone_tracked']
      end

      if attributes.key?(:'local_phone')
        self.local_phone = attributes[:'local_phone']
      end

      if attributes.key?(:'alternate_phone')
        self.alternate_phone = attributes[:'alternate_phone']
      end

      if attributes.key?(:'fax_phone')
        self.fax_phone = attributes[:'fax_phone']
      end

      if attributes.key?(:'mobile_phone')
        self.mobile_phone = attributes[:'mobile_phone']
      end

      if attributes.key?(:'toll_free_phone')
        self.toll_free_phone = attributes[:'toll_free_phone']
      end

      if attributes.key?(:'tty_phone')
        self.tty_phone = attributes[:'tty_phone']
      end

      if attributes.key?(:'category_ids')
        if (value = attributes[:'category_ids']).is_a?(Array)
          self.category_ids = value
        end
      end

      if attributes.key?(:'featured_message')
        self.featured_message = attributes[:'featured_message']
      end

      if attributes.key?(:'featured_message_url')
        self.featured_message_url = attributes[:'featured_message_url']
      end

      if attributes.key?(:'website_url')
        self.website_url = attributes[:'website_url']
      end

      if attributes.key?(:'display_website_url')
        self.display_website_url = attributes[:'display_website_url']
      end

      if attributes.key?(:'reservation_url')
        self.reservation_url = attributes[:'reservation_url']
      end

      if attributes.key?(:'display_reservation_url')
        self.display_reservation_url = attributes[:'display_reservation_url']
      end

      if attributes.key?(:'menu_url')
        self.menu_url = attributes[:'menu_url']
      end

      if attributes.key?(:'display_menu_url')
        self.display_menu_url = attributes[:'display_menu_url']
      end

      if attributes.key?(:'order_url')
        self.order_url = attributes[:'order_url']
      end

      if attributes.key?(:'display_order_url')
        self.display_order_url = attributes[:'display_order_url']
      end

      if attributes.key?(:'hours')
        self.hours = attributes[:'hours']
      end

      if attributes.key?(:'additional_hours_text')
        self.additional_hours_text = attributes[:'additional_hours_text']
      end

      if attributes.key?(:'holiday_hours')
        if (value = attributes[:'holiday_hours']).is_a?(Array)
          self.holiday_hours = value
        end
      end

      if attributes.key?(:'description')
        self.description = attributes[:'description']
      end

      if attributes.key?(:'conditions_treated')
        if (value = attributes[:'conditions_treated']).is_a?(Array)
          self.conditions_treated = value
        end
      end

      if attributes.key?(:'certifications')
        if (value = attributes[:'certifications']).is_a?(Array)
          self.certifications = value
        end
      end

      if attributes.key?(:'education_list')
        if (value = attributes[:'education_list']).is_a?(Array)
          self.education_list = value
        end
      end

      if attributes.key?(:'degrees')
        if (value = attributes[:'degrees']).is_a?(Array)
          self.degrees = value
        end
      end

      if attributes.key?(:'admitting_hospitals')
        if (value = attributes[:'admitting_hospitals']).is_a?(Array)
          self.admitting_hospitals = value
        end
      end

      if attributes.key?(:'accepting_new_patients')
        self.accepting_new_patients = attributes[:'accepting_new_patients']
      end

      if attributes.key?(:'closed')
        self.closed = attributes[:'closed']
      end

      if attributes.key?(:'payment_options')
        if (value = attributes[:'payment_options']).is_a?(Array)
          self.payment_options = value
        end
      end

      if attributes.key?(:'insurance_accepted')
        if (value = attributes[:'insurance_accepted']).is_a?(Array)
          self.insurance_accepted = value
        end
      end

      if attributes.key?(:'logo')
        self.logo = attributes[:'logo']
      end

      if attributes.key?(:'photos')
        if (value = attributes[:'photos']).is_a?(Array)
          self.photos = value
        end
      end

      if attributes.key?(:'headshot')
        self.headshot = attributes[:'headshot']
      end

      if attributes.key?(:'video_urls')
        if (value = attributes[:'video_urls']).is_a?(Array)
          self.video_urls = value
        end
      end

      if attributes.key?(:'instagram_handle')
        self.instagram_handle = attributes[:'instagram_handle']
      end

      if attributes.key?(:'twitter_handle')
        self.twitter_handle = attributes[:'twitter_handle']
      end

      if attributes.key?(:'google_website_override')
        self.google_website_override = attributes[:'google_website_override']
      end

      if attributes.key?(:'google_cover_photo')
        self.google_cover_photo = attributes[:'google_cover_photo']
      end

      if attributes.key?(:'google_profile_photo')
        self.google_profile_photo = attributes[:'google_profile_photo']
      end

      if attributes.key?(:'google_attributes')
        if (value = attributes[:'google_attributes']).is_a?(Array)
          self.google_attributes = value
        end
      end

      if attributes.key?(:'facebook_page_url')
        self.facebook_page_url = attributes[:'facebook_page_url']
      end

      if attributes.key?(:'facebook_call_to_action')
        self.facebook_call_to_action = attributes[:'facebook_call_to_action']
      end

      if attributes.key?(:'facebook_cover_photo')
        self.facebook_cover_photo = attributes[:'facebook_cover_photo']
      end

      if attributes.key?(:'facebook_profile_picture')
        self.facebook_profile_picture = attributes[:'facebook_profile_picture']
      end

      if attributes.key?(:'uber_link_type')
        self.uber_link_type = attributes[:'uber_link_type']
      end

      if attributes.key?(:'uber_link_text')
        self.uber_link_text = attributes[:'uber_link_text']
      end

      if attributes.key?(:'uber_trip_branding_text')
        self.uber_trip_branding_text = attributes[:'uber_trip_branding_text']
      end

      if attributes.key?(:'uber_trip_branding_url')
        self.uber_trip_branding_url = attributes[:'uber_trip_branding_url']
      end

      if attributes.key?(:'uber_trip_branding_description')
        self.uber_trip_branding_description = attributes[:'uber_trip_branding_description']
      end

      if attributes.key?(:'uber_embed_code')
        self.uber_embed_code = attributes[:'uber_embed_code']
      end

      if attributes.key?(:'uber_link')
        self.uber_link = attributes[:'uber_link']
      end

      if attributes.key?(:'uber_link_raw')
        self.uber_link_raw = attributes[:'uber_link_raw']
      end

      if attributes.key?(:'year_established')
        self.year_established = attributes[:'year_established']
      end

      if attributes.key?(:'display_lat')
        self.display_lat = attributes[:'display_lat']
      end

      if attributes.key?(:'display_lng')
        self.display_lng = attributes[:'display_lng']
      end

      if attributes.key?(:'routable_lat')
        self.routable_lat = attributes[:'routable_lat']
      end

      if attributes.key?(:'routable_lng')
        self.routable_lng = attributes[:'routable_lng']
      end

      if attributes.key?(:'walkable_lat')
        self.walkable_lat = attributes[:'walkable_lat']
      end

      if attributes.key?(:'walkable_lng')
        self.walkable_lng = attributes[:'walkable_lng']
      end

      if attributes.key?(:'pickup_lat')
        self.pickup_lat = attributes[:'pickup_lat']
      end

      if attributes.key?(:'pickup_lng')
        self.pickup_lng = attributes[:'pickup_lng']
      end

      if attributes.key?(:'dropoff_lat')
        self.dropoff_lat = attributes[:'dropoff_lat']
      end

      if attributes.key?(:'dropoff_lng')
        self.dropoff_lng = attributes[:'dropoff_lng']
      end

      if attributes.key?(:'yext_display_lat')
        self.yext_display_lat = attributes[:'yext_display_lat']
      end

      if attributes.key?(:'yext_display_lng')
        self.yext_display_lng = attributes[:'yext_display_lng']
      end

      if attributes.key?(:'yext_routable_lat')
        self.yext_routable_lat = attributes[:'yext_routable_lat']
      end

      if attributes.key?(:'yext_routable_lng')
        self.yext_routable_lng = attributes[:'yext_routable_lng']
      end

      if attributes.key?(:'yext_walkable_lat')
        self.yext_walkable_lat = attributes[:'yext_walkable_lat']
      end

      if attributes.key?(:'yext_walkable_lng')
        self.yext_walkable_lng = attributes[:'yext_walkable_lng']
      end

      if attributes.key?(:'yext_pickup_lat')
        self.yext_pickup_lat = attributes[:'yext_pickup_lat']
      end

      if attributes.key?(:'yext_pickup_lng')
        self.yext_pickup_lng = attributes[:'yext_pickup_lng']
      end

      if attributes.key?(:'yext_dropoff_lat')
        self.yext_dropoff_lat = attributes[:'yext_dropoff_lat']
      end

      if attributes.key?(:'yext_dropoff_lng')
        self.yext_dropoff_lng = attributes[:'yext_dropoff_lng']
      end

      if attributes.key?(:'emails')
        if (value = attributes[:'emails']).is_a?(Array)
          self.emails = value
        end
      end

      if attributes.key?(:'specialities')
        if (value = attributes[:'specialities']).is_a?(Array)
          self.specialities = value
        end
      end

      if attributes.key?(:'associations')
        if (value = attributes[:'associations']).is_a?(Array)
          self.associations = value
        end
      end

      if attributes.key?(:'products')
        if (value = attributes[:'products']).is_a?(Array)
          self.products = value
        end
      end

      if attributes.key?(:'services')
        if (value = attributes[:'services']).is_a?(Array)
          self.services = value
        end
      end

      if attributes.key?(:'brands')
        if (value = attributes[:'brands']).is_a?(Array)
          self.brands = value
        end
      end

      if attributes.key?(:'language')
        self.language = attributes[:'language']
      end

      if attributes.key?(:'languages')
        if (value = attributes[:'languages']).is_a?(Array)
          self.languages = value
        end
      end

      if attributes.key?(:'keywords')
        if (value = attributes[:'keywords']).is_a?(Array)
          self.keywords = value
        end
      end

      if attributes.key?(:'menus_label')
        self.menus_label = attributes[:'menus_label']
      end

      if attributes.key?(:'menu_ids')
        if (value = attributes[:'menu_ids']).is_a?(Array)
          self.menu_ids = value
        end
      end

      if attributes.key?(:'bio_lists_label')
        self.bio_lists_label = attributes[:'bio_lists_label']
      end

      if attributes.key?(:'bio_list_ids')
        if (value = attributes[:'bio_list_ids']).is_a?(Array)
          self.bio_list_ids = value
        end
      end

      if attributes.key?(:'product_lists_label')
        self.product_lists_label = attributes[:'product_lists_label']
      end

      if attributes.key?(:'product_list_ids')
        if (value = attributes[:'product_list_ids']).is_a?(Array)
          self.product_list_ids = value
        end
      end

      if attributes.key?(:'event_lists_label')
        self.event_lists_label = attributes[:'event_lists_label']
      end

      if attributes.key?(:'event_list_ids')
        if (value = attributes[:'event_list_ids']).is_a?(Array)
          self.event_list_ids = value
        end
      end

      if attributes.key?(:'folder_id')
        self.folder_id = attributes[:'folder_id']
      end

      if attributes.key?(:'label_ids')
        if (value = attributes[:'label_ids']).is_a?(Array)
          self.label_ids = value
        end
      end

      if attributes.key?(:'custom_fields')
        if (value = attributes[:'custom_fields']).is_a?(Hash)
          self.custom_fields = value
        end
      end

      if attributes.key?(:'intelligent_search_tracking_enabled')
        self.intelligent_search_tracking_enabled = attributes[:'intelligent_search_tracking_enabled']
      end

      if attributes.key?(:'intelligent_search_tracking_frequency')
        self.intelligent_search_tracking_frequency = attributes[:'intelligent_search_tracking_frequency']
      end

      if attributes.key?(:'location_keywords')
        if (value = attributes[:'location_keywords']).is_a?(Array)
          self.location_keywords = value
        end
      end

      if attributes.key?(:'custom_keywords')
        if (value = attributes[:'custom_keywords']).is_a?(Array)
          self.custom_keywords = value
        end
      end

      if attributes.key?(:'query_templates')
        if (value = attributes[:'query_templates']).is_a?(Array)
          self.query_templates = value
        end
      end

      if attributes.key?(:'alternate_names')
        if (value = attributes[:'alternate_names']).is_a?(Array)
          self.alternate_names = value
        end
      end

      if attributes.key?(:'alternate_websites')
        if (value = attributes[:'alternate_websites']).is_a?(Array)
          self.alternate_websites = value
        end
      end

      if attributes.key?(:'competitors')
        if (value = attributes[:'competitors']).is_a?(Array)
          self.competitors = value
        end
      end

      if attributes.key?(:'tracking_sites')
        if (value = attributes[:'tracking_sites']).is_a?(Array)
          self.tracking_sites = value
        end
      end

      if attributes.key?(:'iso_region_code')
        self.iso_region_code = attributes[:'iso_region_code']
      end

      if attributes.key?(:'review_balancing_url')
        self.review_balancing_url = attributes[:'review_balancing_url']
      end

      if attributes.key?(:'first_party_review_page')
        self.first_party_review_page = attributes[:'first_party_review_page']
      end

      if attributes.key?(:'is_cluster_primary')
        self.is_cluster_primary = attributes[:'is_cluster_primary']
      end

      if attributes.key?(:'schema_types')
        if (value = attributes[:'schema_types']).is_a?(Array)
          self.schema_types = value
        end
      end

      if attributes.key?(:'attire')
        self.attire = attributes[:'attire']
      end

      if attributes.key?(:'price_range')
        self.price_range = attributes[:'price_range']
      end

      if attributes.key?(:'meals_served')
        if (value = attributes[:'meals_served']).is_a?(Array)
          self.meals_served = value
        end
      end

      if attributes.key?(:'located_in')
        self.located_in = attributes[:'located_in']
      end

      if attributes.key?(:'primary_contact')
        self.primary_contact = attributes[:'primary_contact']
      end

      if attributes.key?(:'review_response_conversation_enabled')
        self.review_response_conversation_enabled = attributes[:'review_response_conversation_enabled']
      end

      if attributes.key?(:'holiday_hours_confirmation_enabled')
        self.holiday_hours_confirmation_enabled = attributes[:'holiday_hours_confirmation_enabled']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if !@id.nil? && @id.to_s.length > 50
        invalid_properties.push('invalid value for "id", the character length must be smaller than or equal to 50.')
      end

      if !@account_id.nil? && @account_id.to_s.length > 50
        invalid_properties.push('invalid value for "account_id", the character length must be smaller than or equal to 50.')
      end

      if !@timezone.nil? && @timezone.to_s.length < 0
        invalid_properties.push('invalid value for "timezone", the character length must be great than or equal to 0.')
      end

      if !@location_name.nil? && @location_name.to_s.length > 100
        invalid_properties.push('invalid value for "location_name", the character length must be smaller than or equal to 100.')
      end

      if !@address.nil? && @address.to_s.length > 255
        invalid_properties.push('invalid value for "address", the character length must be smaller than or equal to 255.')
      end

      if !@address2.nil? && @address2.to_s.length > 255
        invalid_properties.push('invalid value for "address2", the character length must be smaller than or equal to 255.')
      end

      if !@display_address.nil? && @display_address.to_s.length > 255
        invalid_properties.push('invalid value for "display_address", the character length must be smaller than or equal to 255.')
      end

      if !@city.nil? && @city.to_s.length > 80
        invalid_properties.push('invalid value for "city", the character length must be smaller than or equal to 80.')
      end

      if !@state.nil? && @state.to_s.length > 80
        invalid_properties.push('invalid value for "state", the character length must be smaller than or equal to 80.')
      end

      if !@sublocality.nil? && @sublocality.to_s.length > 255
        invalid_properties.push('invalid value for "sublocality", the character length must be smaller than or equal to 255.')
      end

      if !@zip.nil? && @zip.to_s.length > 10
        invalid_properties.push('invalid value for "zip", the character length must be smaller than or equal to 10.')
      end

      if !@country_code.nil? && @country_code.to_s.length > 2
        invalid_properties.push('invalid value for "country_code", the character length must be smaller than or equal to 2.')
      end

      if !@featured_message.nil? && @featured_message.to_s.length > 50
        invalid_properties.push('invalid value for "featured_message", the character length must be smaller than or equal to 50.')
      end

      if !@featured_message_url.nil? && @featured_message_url.to_s.length > 255
        invalid_properties.push('invalid value for "featured_message_url", the character length must be smaller than or equal to 255.')
      end

      if !@website_url.nil? && @website_url.to_s.length > 255
        invalid_properties.push('invalid value for "website_url", the character length must be smaller than or equal to 255.')
      end

      if !@display_website_url.nil? && @display_website_url.to_s.length > 255
        invalid_properties.push('invalid value for "display_website_url", the character length must be smaller than or equal to 255.')
      end

      if !@reservation_url.nil? && @reservation_url.to_s.length > 255
        invalid_properties.push('invalid value for "reservation_url", the character length must be smaller than or equal to 255.')
      end

      if !@display_reservation_url.nil? && @display_reservation_url.to_s.length > 255
        invalid_properties.push('invalid value for "display_reservation_url", the character length must be smaller than or equal to 255.')
      end

      if !@menu_url.nil? && @menu_url.to_s.length > 255
        invalid_properties.push('invalid value for "menu_url", the character length must be smaller than or equal to 255.')
      end

      if !@display_menu_url.nil? && @display_menu_url.to_s.length > 255
        invalid_properties.push('invalid value for "display_menu_url", the character length must be smaller than or equal to 255.')
      end

      if !@order_url.nil? && @order_url.to_s.length > 255
        invalid_properties.push('invalid value for "order_url", the character length must be smaller than or equal to 255.')
      end

      if !@display_order_url.nil? && @display_order_url.to_s.length > 255
        invalid_properties.push('invalid value for "display_order_url", the character length must be smaller than or equal to 255.')
      end

      if !@hours.nil? && @hours.to_s.length > 255
        invalid_properties.push('invalid value for "hours", the character length must be smaller than or equal to 255.')
      end

      if !@additional_hours_text.nil? && @additional_hours_text.to_s.length > 255
        invalid_properties.push('invalid value for "additional_hours_text", the character length must be smaller than or equal to 255.')
      end

      if !@description.nil? && @description.to_s.length > 5000
        invalid_properties.push('invalid value for "description", the character length must be smaller than or equal to 5000.')
      end

      if !@description.nil? && @description.to_s.length < 10
        invalid_properties.push('invalid value for "description", the character length must be great than or equal to 10.')
      end

      if !@twitter_handle.nil? && @twitter_handle.to_s.length > 15
        invalid_properties.push('invalid value for "twitter_handle", the character length must be smaller than or equal to 15.')
      end

      if !@google_website_override.nil? && @google_website_override.to_s.length > 255
        invalid_properties.push('invalid value for "google_website_override", the character length must be smaller than or equal to 255.')
      end

      if !@facebook_page_url.nil? && @facebook_page_url.to_s.length > 255
        invalid_properties.push('invalid value for "facebook_page_url", the character length must be smaller than or equal to 255.')
      end

      if !@uber_link_text.nil? && @uber_link_text.to_s.length > 100
        invalid_properties.push('invalid value for "uber_link_text", the character length must be smaller than or equal to 100.')
      end

      if !@uber_trip_branding_text.nil? && @uber_trip_branding_text.to_s.length > 28
        invalid_properties.push('invalid value for "uber_trip_branding_text", the character length must be smaller than or equal to 28.')
      end

      if !@uber_trip_branding_description.nil? && @uber_trip_branding_description.to_s.length > 150
        invalid_properties.push('invalid value for "uber_trip_branding_description", the character length must be smaller than or equal to 150.')
      end

      if !@year_established.nil? && @year_established.to_s.length > 4
        invalid_properties.push('invalid value for "year_established", the character length must be smaller than or equal to 4.')
      end

      if !@language.nil? && @language.to_s.length > 10
        invalid_properties.push('invalid value for "language", the character length must be smaller than or equal to 10.')
      end

      if !@review_balancing_url.nil? && @review_balancing_url.to_s.length > 255
        invalid_properties.push('invalid value for "review_balancing_url", the character length must be smaller than or equal to 255.')
      end

      if !@first_party_review_page.nil? && @first_party_review_page.to_s.length > 255
        invalid_properties.push('invalid value for "first_party_review_page", the character length must be smaller than or equal to 255.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if !@id.nil? && @id.to_s.length > 50
      return false if !@account_id.nil? && @account_id.to_s.length > 50
      return false if !@timezone.nil? && @timezone.to_s.length < 0
      return false if !@location_name.nil? && @location_name.to_s.length > 100
      gender_validator = EnumAttributeValidator.new('String', ["FEMALE", "F", "MALE", "M", "UNSPECIFIED"])
      return false unless gender_validator.valid?(@gender)
      return false if !@address.nil? && @address.to_s.length > 255
      return false if !@address2.nil? && @address2.to_s.length > 255
      return false if !@display_address.nil? && @display_address.to_s.length > 255
      return false if !@city.nil? && @city.to_s.length > 80
      return false if !@state.nil? && @state.to_s.length > 80
      return false if !@sublocality.nil? && @sublocality.to_s.length > 255
      return false if !@zip.nil? && @zip.to_s.length > 10
      return false if !@country_code.nil? && @country_code.to_s.length > 2
      return false if !@featured_message.nil? && @featured_message.to_s.length > 50
      return false if !@featured_message_url.nil? && @featured_message_url.to_s.length > 255
      return false if !@website_url.nil? && @website_url.to_s.length > 255
      return false if !@display_website_url.nil? && @display_website_url.to_s.length > 255
      return false if !@reservation_url.nil? && @reservation_url.to_s.length > 255
      return false if !@display_reservation_url.nil? && @display_reservation_url.to_s.length > 255
      return false if !@menu_url.nil? && @menu_url.to_s.length > 255
      return false if !@display_menu_url.nil? && @display_menu_url.to_s.length > 255
      return false if !@order_url.nil? && @order_url.to_s.length > 255
      return false if !@display_order_url.nil? && @display_order_url.to_s.length > 255
      return false if !@hours.nil? && @hours.to_s.length > 255
      return false if !@additional_hours_text.nil? && @additional_hours_text.to_s.length > 255
      return false if !@description.nil? && @description.to_s.length > 5000
      return false if !@description.nil? && @description.to_s.length < 10
      return false if !@twitter_handle.nil? && @twitter_handle.to_s.length > 15
      return false if !@google_website_override.nil? && @google_website_override.to_s.length > 255
      return false if !@facebook_page_url.nil? && @facebook_page_url.to_s.length > 255
      uber_link_type_validator = EnumAttributeValidator.new('String', ["LINK", "BUTTON"])
      return false unless uber_link_type_validator.valid?(@uber_link_type)
      return false if !@uber_link_text.nil? && @uber_link_text.to_s.length > 100
      return false if !@uber_trip_branding_text.nil? && @uber_trip_branding_text.to_s.length > 28
      return false if !@uber_trip_branding_description.nil? && @uber_trip_branding_description.to_s.length > 150
      return false if !@year_established.nil? && @year_established.to_s.length > 4
      return false if !@language.nil? && @language.to_s.length > 10
      intelligent_search_tracking_frequency_validator = EnumAttributeValidator.new('String', ["WEEKLY", "MONTHLY", "QUARTERLY"])
      return false unless intelligent_search_tracking_frequency_validator.valid?(@intelligent_search_tracking_frequency)
      return false if !@review_balancing_url.nil? && @review_balancing_url.to_s.length > 255
      return false if !@first_party_review_page.nil? && @first_party_review_page.to_s.length > 255
      attire_validator = EnumAttributeValidator.new('String', ["UNSPECIFIED", "DRESSY", "CASUAL", "FORMAL"])
      return false unless attire_validator.valid?(@attire)
      price_range_validator = EnumAttributeValidator.new('String', ["UNSPECIFIED", "ONE", "TWO", "THREE", "FOUR"])
      return false unless price_range_validator.valid?(@price_range)
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if !id.nil? && id.to_s.length > 50
        fail ArgumentError, 'invalid value for "id", the character length must be smaller than or equal to 50.'
      end

      @id = id
    end

    # Custom attribute writer method with validation
    # @param [Object] account_id Value to be assigned
    def account_id=(account_id)
      if !account_id.nil? && account_id.to_s.length > 50
        fail ArgumentError, 'invalid value for "account_id", the character length must be smaller than or equal to 50.'
      end

      @account_id = account_id
    end

    # Custom attribute writer method with validation
    # @param [Object] timezone Value to be assigned
    def timezone=(timezone)
      if !timezone.nil? && timezone.to_s.length < 0
        fail ArgumentError, 'invalid value for "timezone", the character length must be great than or equal to 0.'
      end

      @timezone = timezone
    end

    # Custom attribute writer method with validation
    # @param [Object] location_name Value to be assigned
    def location_name=(location_name)
      if !location_name.nil? && location_name.to_s.length > 100
        fail ArgumentError, 'invalid value for "location_name", the character length must be smaller than or equal to 100.'
      end

      @location_name = location_name
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] gender Object to be assigned
    def gender=(gender)
      validator = EnumAttributeValidator.new('String', ["FEMALE", "F", "MALE", "M", "UNSPECIFIED"])
      unless validator.valid?(gender)
        fail ArgumentError, "invalid value for \"gender\", must be one of #{validator.allowable_values}."
      end
      @gender = gender
    end

    # Custom attribute writer method with validation
    # @param [Object] address Value to be assigned
    def address=(address)
      if !address.nil? && address.to_s.length > 255
        fail ArgumentError, 'invalid value for "address", the character length must be smaller than or equal to 255.'
      end

      @address = address
    end

    # Custom attribute writer method with validation
    # @param [Object] address2 Value to be assigned
    def address2=(address2)
      if !address2.nil? && address2.to_s.length > 255
        fail ArgumentError, 'invalid value for "address2", the character length must be smaller than or equal to 255.'
      end

      @address2 = address2
    end

    # Custom attribute writer method with validation
    # @param [Object] display_address Value to be assigned
    def display_address=(display_address)
      if !display_address.nil? && display_address.to_s.length > 255
        fail ArgumentError, 'invalid value for "display_address", the character length must be smaller than or equal to 255.'
      end

      @display_address = display_address
    end

    # Custom attribute writer method with validation
    # @param [Object] city Value to be assigned
    def city=(city)
      if !city.nil? && city.to_s.length > 80
        fail ArgumentError, 'invalid value for "city", the character length must be smaller than or equal to 80.'
      end

      @city = city
    end

    # Custom attribute writer method with validation
    # @param [Object] state Value to be assigned
    def state=(state)
      if !state.nil? && state.to_s.length > 80
        fail ArgumentError, 'invalid value for "state", the character length must be smaller than or equal to 80.'
      end

      @state = state
    end

    # Custom attribute writer method with validation
    # @param [Object] sublocality Value to be assigned
    def sublocality=(sublocality)
      if !sublocality.nil? && sublocality.to_s.length > 255
        fail ArgumentError, 'invalid value for "sublocality", the character length must be smaller than or equal to 255.'
      end

      @sublocality = sublocality
    end

    # Custom attribute writer method with validation
    # @param [Object] zip Value to be assigned
    def zip=(zip)
      if !zip.nil? && zip.to_s.length > 10
        fail ArgumentError, 'invalid value for "zip", the character length must be smaller than or equal to 10.'
      end

      @zip = zip
    end

    # Custom attribute writer method with validation
    # @param [Object] country_code Value to be assigned
    def country_code=(country_code)
      if !country_code.nil? && country_code.to_s.length > 2
        fail ArgumentError, 'invalid value for "country_code", the character length must be smaller than or equal to 2.'
      end

      @country_code = country_code
    end

    # Custom attribute writer method with validation
    # @param [Object] featured_message Value to be assigned
    def featured_message=(featured_message)
      if !featured_message.nil? && featured_message.to_s.length > 50
        fail ArgumentError, 'invalid value for "featured_message", the character length must be smaller than or equal to 50.'
      end

      @featured_message = featured_message
    end

    # Custom attribute writer method with validation
    # @param [Object] featured_message_url Value to be assigned
    def featured_message_url=(featured_message_url)
      if !featured_message_url.nil? && featured_message_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "featured_message_url", the character length must be smaller than or equal to 255.'
      end

      @featured_message_url = featured_message_url
    end

    # Custom attribute writer method with validation
    # @param [Object] website_url Value to be assigned
    def website_url=(website_url)
      if !website_url.nil? && website_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "website_url", the character length must be smaller than or equal to 255.'
      end

      @website_url = website_url
    end

    # Custom attribute writer method with validation
    # @param [Object] display_website_url Value to be assigned
    def display_website_url=(display_website_url)
      if !display_website_url.nil? && display_website_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "display_website_url", the character length must be smaller than or equal to 255.'
      end

      @display_website_url = display_website_url
    end

    # Custom attribute writer method with validation
    # @param [Object] reservation_url Value to be assigned
    def reservation_url=(reservation_url)
      if !reservation_url.nil? && reservation_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "reservation_url", the character length must be smaller than or equal to 255.'
      end

      @reservation_url = reservation_url
    end

    # Custom attribute writer method with validation
    # @param [Object] display_reservation_url Value to be assigned
    def display_reservation_url=(display_reservation_url)
      if !display_reservation_url.nil? && display_reservation_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "display_reservation_url", the character length must be smaller than or equal to 255.'
      end

      @display_reservation_url = display_reservation_url
    end

    # Custom attribute writer method with validation
    # @param [Object] menu_url Value to be assigned
    def menu_url=(menu_url)
      if !menu_url.nil? && menu_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "menu_url", the character length must be smaller than or equal to 255.'
      end

      @menu_url = menu_url
    end

    # Custom attribute writer method with validation
    # @param [Object] display_menu_url Value to be assigned
    def display_menu_url=(display_menu_url)
      if !display_menu_url.nil? && display_menu_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "display_menu_url", the character length must be smaller than or equal to 255.'
      end

      @display_menu_url = display_menu_url
    end

    # Custom attribute writer method with validation
    # @param [Object] order_url Value to be assigned
    def order_url=(order_url)
      if !order_url.nil? && order_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "order_url", the character length must be smaller than or equal to 255.'
      end

      @order_url = order_url
    end

    # Custom attribute writer method with validation
    # @param [Object] display_order_url Value to be assigned
    def display_order_url=(display_order_url)
      if !display_order_url.nil? && display_order_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "display_order_url", the character length must be smaller than or equal to 255.'
      end

      @display_order_url = display_order_url
    end

    # Custom attribute writer method with validation
    # @param [Object] hours Value to be assigned
    def hours=(hours)
      if !hours.nil? && hours.to_s.length > 255
        fail ArgumentError, 'invalid value for "hours", the character length must be smaller than or equal to 255.'
      end

      @hours = hours
    end

    # Custom attribute writer method with validation
    # @param [Object] additional_hours_text Value to be assigned
    def additional_hours_text=(additional_hours_text)
      if !additional_hours_text.nil? && additional_hours_text.to_s.length > 255
        fail ArgumentError, 'invalid value for "additional_hours_text", the character length must be smaller than or equal to 255.'
      end

      @additional_hours_text = additional_hours_text
    end

    # Custom attribute writer method with validation
    # @param [Object] description Value to be assigned
    def description=(description)
      if !description.nil? && description.to_s.length > 5000
        fail ArgumentError, 'invalid value for "description", the character length must be smaller than or equal to 5000.'
      end

      if !description.nil? && description.to_s.length < 10
        fail ArgumentError, 'invalid value for "description", the character length must be great than or equal to 10.'
      end

      @description = description
    end

    # Custom attribute writer method with validation
    # @param [Object] twitter_handle Value to be assigned
    def twitter_handle=(twitter_handle)
      if !twitter_handle.nil? && twitter_handle.to_s.length > 15
        fail ArgumentError, 'invalid value for "twitter_handle", the character length must be smaller than or equal to 15.'
      end

      @twitter_handle = twitter_handle
    end

    # Custom attribute writer method with validation
    # @param [Object] google_website_override Value to be assigned
    def google_website_override=(google_website_override)
      if !google_website_override.nil? && google_website_override.to_s.length > 255
        fail ArgumentError, 'invalid value for "google_website_override", the character length must be smaller than or equal to 255.'
      end

      @google_website_override = google_website_override
    end

    # Custom attribute writer method with validation
    # @param [Object] facebook_page_url Value to be assigned
    def facebook_page_url=(facebook_page_url)
      if !facebook_page_url.nil? && facebook_page_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "facebook_page_url", the character length must be smaller than or equal to 255.'
      end

      @facebook_page_url = facebook_page_url
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] uber_link_type Object to be assigned
    def uber_link_type=(uber_link_type)
      validator = EnumAttributeValidator.new('String', ["LINK", "BUTTON"])
      unless validator.valid?(uber_link_type)
        fail ArgumentError, "invalid value for \"uber_link_type\", must be one of #{validator.allowable_values}."
      end
      @uber_link_type = uber_link_type
    end

    # Custom attribute writer method with validation
    # @param [Object] uber_link_text Value to be assigned
    def uber_link_text=(uber_link_text)
      if !uber_link_text.nil? && uber_link_text.to_s.length > 100
        fail ArgumentError, 'invalid value for "uber_link_text", the character length must be smaller than or equal to 100.'
      end

      @uber_link_text = uber_link_text
    end

    # Custom attribute writer method with validation
    # @param [Object] uber_trip_branding_text Value to be assigned
    def uber_trip_branding_text=(uber_trip_branding_text)
      if !uber_trip_branding_text.nil? && uber_trip_branding_text.to_s.length > 28
        fail ArgumentError, 'invalid value for "uber_trip_branding_text", the character length must be smaller than or equal to 28.'
      end

      @uber_trip_branding_text = uber_trip_branding_text
    end

    # Custom attribute writer method with validation
    # @param [Object] uber_trip_branding_description Value to be assigned
    def uber_trip_branding_description=(uber_trip_branding_description)
      if !uber_trip_branding_description.nil? && uber_trip_branding_description.to_s.length > 150
        fail ArgumentError, 'invalid value for "uber_trip_branding_description", the character length must be smaller than or equal to 150.'
      end

      @uber_trip_branding_description = uber_trip_branding_description
    end

    # Custom attribute writer method with validation
    # @param [Object] year_established Value to be assigned
    def year_established=(year_established)
      if !year_established.nil? && year_established.to_s.length > 4
        fail ArgumentError, 'invalid value for "year_established", the character length must be smaller than or equal to 4.'
      end

      @year_established = year_established
    end

    # Custom attribute writer method with validation
    # @param [Object] language Value to be assigned
    def language=(language)
      if !language.nil? && language.to_s.length > 10
        fail ArgumentError, 'invalid value for "language", the character length must be smaller than or equal to 10.'
      end

      @language = language
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] intelligent_search_tracking_frequency Object to be assigned
    def intelligent_search_tracking_frequency=(intelligent_search_tracking_frequency)
      validator = EnumAttributeValidator.new('String', ["WEEKLY", "MONTHLY", "QUARTERLY"])
      unless validator.valid?(intelligent_search_tracking_frequency)
        fail ArgumentError, "invalid value for \"intelligent_search_tracking_frequency\", must be one of #{validator.allowable_values}."
      end
      @intelligent_search_tracking_frequency = intelligent_search_tracking_frequency
    end

    # Custom attribute writer method with validation
    # @param [Object] review_balancing_url Value to be assigned
    def review_balancing_url=(review_balancing_url)
      if !review_balancing_url.nil? && review_balancing_url.to_s.length > 255
        fail ArgumentError, 'invalid value for "review_balancing_url", the character length must be smaller than or equal to 255.'
      end

      @review_balancing_url = review_balancing_url
    end

    # Custom attribute writer method with validation
    # @param [Object] first_party_review_page Value to be assigned
    def first_party_review_page=(first_party_review_page)
      if !first_party_review_page.nil? && first_party_review_page.to_s.length > 255
        fail ArgumentError, 'invalid value for "first_party_review_page", the character length must be smaller than or equal to 255.'
      end

      @first_party_review_page = first_party_review_page
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] attire Object to be assigned
    def attire=(attire)
      validator = EnumAttributeValidator.new('String', ["UNSPECIFIED", "DRESSY", "CASUAL", "FORMAL"])
      unless validator.valid?(attire)
        fail ArgumentError, "invalid value for \"attire\", must be one of #{validator.allowable_values}."
      end
      @attire = attire
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] price_range Object to be assigned
    def price_range=(price_range)
      validator = EnumAttributeValidator.new('String', ["UNSPECIFIED", "ONE", "TWO", "THREE", "FOUR"])
      unless validator.valid?(price_range)
        fail ArgumentError, "invalid value for \"price_range\", must be one of #{validator.allowable_values}."
      end
      @price_range = price_range
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          id == o.id &&
          uid == o.uid &&
          account_id == o.account_id &&
          timestamp == o.timestamp &&
          timezone == o.timezone &&
          location_type == o.location_type &&
          location_name == o.location_name &&
          first_name == o.first_name &&
          middle_name == o.middle_name &&
          last_name == o.last_name &&
          office_name == o.office_name &&
          gender == o.gender &&
          npi == o.npi &&
          address == o.address &&
          address2 == o.address2 &&
          suppress_address == o.suppress_address &&
          display_address == o.display_address &&
          city == o.city &&
          state == o.state &&
          sublocality == o.sublocality &&
          zip == o.zip &&
          country_code == o.country_code &&
          service_area == o.service_area &&
          phone == o.phone &&
          is_phone_tracked == o.is_phone_tracked &&
          local_phone == o.local_phone &&
          alternate_phone == o.alternate_phone &&
          fax_phone == o.fax_phone &&
          mobile_phone == o.mobile_phone &&
          toll_free_phone == o.toll_free_phone &&
          tty_phone == o.tty_phone &&
          category_ids == o.category_ids &&
          featured_message == o.featured_message &&
          featured_message_url == o.featured_message_url &&
          website_url == o.website_url &&
          display_website_url == o.display_website_url &&
          reservation_url == o.reservation_url &&
          display_reservation_url == o.display_reservation_url &&
          menu_url == o.menu_url &&
          display_menu_url == o.display_menu_url &&
          order_url == o.order_url &&
          display_order_url == o.display_order_url &&
          hours == o.hours &&
          additional_hours_text == o.additional_hours_text &&
          holiday_hours == o.holiday_hours &&
          description == o.description &&
          conditions_treated == o.conditions_treated &&
          certifications == o.certifications &&
          education_list == o.education_list &&
          degrees == o.degrees &&
          admitting_hospitals == o.admitting_hospitals &&
          accepting_new_patients == o.accepting_new_patients &&
          closed == o.closed &&
          payment_options == o.payment_options &&
          insurance_accepted == o.insurance_accepted &&
          logo == o.logo &&
          photos == o.photos &&
          headshot == o.headshot &&
          video_urls == o.video_urls &&
          instagram_handle == o.instagram_handle &&
          twitter_handle == o.twitter_handle &&
          google_website_override == o.google_website_override &&
          google_cover_photo == o.google_cover_photo &&
          google_profile_photo == o.google_profile_photo &&
          google_attributes == o.google_attributes &&
          facebook_page_url == o.facebook_page_url &&
          facebook_call_to_action == o.facebook_call_to_action &&
          facebook_cover_photo == o.facebook_cover_photo &&
          facebook_profile_picture == o.facebook_profile_picture &&
          uber_link_type == o.uber_link_type &&
          uber_link_text == o.uber_link_text &&
          uber_trip_branding_text == o.uber_trip_branding_text &&
          uber_trip_branding_url == o.uber_trip_branding_url &&
          uber_trip_branding_description == o.uber_trip_branding_description &&
          uber_embed_code == o.uber_embed_code &&
          uber_link == o.uber_link &&
          uber_link_raw == o.uber_link_raw &&
          year_established == o.year_established &&
          display_lat == o.display_lat &&
          display_lng == o.display_lng &&
          routable_lat == o.routable_lat &&
          routable_lng == o.routable_lng &&
          walkable_lat == o.walkable_lat &&
          walkable_lng == o.walkable_lng &&
          pickup_lat == o.pickup_lat &&
          pickup_lng == o.pickup_lng &&
          dropoff_lat == o.dropoff_lat &&
          dropoff_lng == o.dropoff_lng &&
          yext_display_lat == o.yext_display_lat &&
          yext_display_lng == o.yext_display_lng &&
          yext_routable_lat == o.yext_routable_lat &&
          yext_routable_lng == o.yext_routable_lng &&
          yext_walkable_lat == o.yext_walkable_lat &&
          yext_walkable_lng == o.yext_walkable_lng &&
          yext_pickup_lat == o.yext_pickup_lat &&
          yext_pickup_lng == o.yext_pickup_lng &&
          yext_dropoff_lat == o.yext_dropoff_lat &&
          yext_dropoff_lng == o.yext_dropoff_lng &&
          emails == o.emails &&
          specialities == o.specialities &&
          associations == o.associations &&
          products == o.products &&
          services == o.services &&
          brands == o.brands &&
          language == o.language &&
          languages == o.languages &&
          keywords == o.keywords &&
          menus_label == o.menus_label &&
          menu_ids == o.menu_ids &&
          bio_lists_label == o.bio_lists_label &&
          bio_list_ids == o.bio_list_ids &&
          product_lists_label == o.product_lists_label &&
          product_list_ids == o.product_list_ids &&
          event_lists_label == o.event_lists_label &&
          event_list_ids == o.event_list_ids &&
          folder_id == o.folder_id &&
          label_ids == o.label_ids &&
          custom_fields == o.custom_fields &&
          intelligent_search_tracking_enabled == o.intelligent_search_tracking_enabled &&
          intelligent_search_tracking_frequency == o.intelligent_search_tracking_frequency &&
          location_keywords == o.location_keywords &&
          custom_keywords == o.custom_keywords &&
          query_templates == o.query_templates &&
          alternate_names == o.alternate_names &&
          alternate_websites == o.alternate_websites &&
          competitors == o.competitors &&
          tracking_sites == o.tracking_sites &&
          iso_region_code == o.iso_region_code &&
          review_balancing_url == o.review_balancing_url &&
          first_party_review_page == o.first_party_review_page &&
          is_cluster_primary == o.is_cluster_primary &&
          schema_types == o.schema_types &&
          attire == o.attire &&
          price_range == o.price_range &&
          meals_served == o.meals_served &&
          located_in == o.located_in &&
          primary_contact == o.primary_contact &&
          review_response_conversation_enabled == o.review_response_conversation_enabled &&
          holiday_hours_confirmation_enabled == o.holiday_hours_confirmation_enabled
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [id, uid, account_id, timestamp, timezone, location_type, location_name, first_name, middle_name, last_name, office_name, gender, npi, address, address2, suppress_address, display_address, city, state, sublocality, zip, country_code, service_area, phone, is_phone_tracked, local_phone, alternate_phone, fax_phone, mobile_phone, toll_free_phone, tty_phone, category_ids, featured_message, featured_message_url, website_url, display_website_url, reservation_url, display_reservation_url, menu_url, display_menu_url, order_url, display_order_url, hours, additional_hours_text, holiday_hours, description, conditions_treated, certifications, education_list, degrees, admitting_hospitals, accepting_new_patients, closed, payment_options, insurance_accepted, logo, photos, headshot, video_urls, instagram_handle, twitter_handle, google_website_override, google_cover_photo, google_profile_photo, google_attributes, facebook_page_url, facebook_call_to_action, facebook_cover_photo, facebook_profile_picture, uber_link_type, uber_link_text, uber_trip_branding_text, uber_trip_branding_url, uber_trip_branding_description, uber_embed_code, uber_link, uber_link_raw, year_established, display_lat, display_lng, routable_lat, routable_lng, walkable_lat, walkable_lng, pickup_lat, pickup_lng, dropoff_lat, dropoff_lng, yext_display_lat, yext_display_lng, yext_routable_lat, yext_routable_lng, yext_walkable_lat, yext_walkable_lng, yext_pickup_lat, yext_pickup_lng, yext_dropoff_lat, yext_dropoff_lng, emails, specialities, associations, products, services, brands, language, languages, keywords, menus_label, menu_ids, bio_lists_label, bio_list_ids, product_lists_label, product_list_ids, event_lists_label, event_list_ids, folder_id, label_ids, custom_fields, intelligent_search_tracking_enabled, intelligent_search_tracking_frequency, location_keywords, custom_keywords, query_templates, alternate_names, alternate_websites, competitors, tracking_sites, iso_region_code, review_balancing_url, first_party_review_page, is_cluster_primary, schema_types, attire, price_range, meals_served, located_in, primary_contact, review_response_conversation_enabled, holiday_hours_confirmation_enabled].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      attributes = attributes.transform_keys(&:to_sym)
      self.class.openapi_types.each_pair do |key, type|
        if attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          self.send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = Yext.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
