=begin
#Yext API

#No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 2.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.4.0

=end

require 'spec_helper'
require 'json'

# Unit tests for Yext::KnowledgeManagerApi
# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate
describe 'KnowledgeManagerApi' do
  before do
    # run before each test
    @api_instance = Yext::KnowledgeManagerApi.new
  end

  after do
    # run after each test
  end

  describe 'test an instance of KnowledgeManagerApi' do
    it 'should create an instance of KnowledgeManagerApi' do
      expect(@api_instance).to be_instance_of(Yext::KnowledgeManagerApi)
    end
  end

  # unit tests for create_asset
  # Assets: Create
  # Creates a new asset in an account.  **NOTE:** * If the **&#x60;v&#x60;** parameter is on or before &#x60;20190624&#x60;: only the first folder the Asset is available for will be returned in the legacy **&#x60;folderId&#x60;** field. * If the **&#x60;v&#x60;** parameter is after &#x60;20190624&#x60;: the complete list of folders the Asset is available to will be returned in the new **&#x60;folderIds&#x60;** field. **&#x60;folderId&#x60;** will not be returned. 
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param format The formatting langauge used to parse rich text field values. Present if and only if type of field is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60; 
  # @param asset 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'create_asset test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for create_bio
  # Bios: Create
  # Create new Bio List.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param bio 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'create_bio test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for create_custom_field
  # Custom Fields: Create
  # Creates a new Custom Field in an Account. 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param account_id 
  # @param field 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'create_custom_field test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for create_entity
  # Entities: Create
  # Create a new Entity  **NOTE:**   * If the **&#x60;v&#x60;** parameter is before &#x60;20181129&#x60;: the 201 response contains the created Entity&#39;s **&#x60;id&#x60;**   * If the **&#x60;v&#x60;** parameter is on or after &#x60;20181129&#x60;: the 201 response contains the created Entity in its entirety 
  # @param account_id 
  # @param entity_type The type of entity to be created. Should be one of the following:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param entity_write The entity to be created
  # @param [Hash] opts the optional parameters
  # @option opts [String] :format The formatting language used to parse rich text field values. Present and **required** if an only if the request contains a field with type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60; 
  # @option opts [Boolean] :strip_unsupported_formats Optional parameter to strip unsupported formats in rich text fields. When this parameter is included, the unsupported formats in rich text fields will be stripped and saved as plain text; otherwise if this parameter is not included, unsupported formats will return an error. 
  # @option opts [String] :template_fields Comma-separated list of top-level fields to apply from the template. If provided, only the fields specified will be applied to the entity.  Ignored if **&#x60;templateId&#x60;** is not provided. 
  # @option opts [String] :template_id The ID of the template to apply to the entity  **NOTE:** Some fields that are part of the provided template but not present in the API will be applied - e.g. Linked Accounts 
  # @return [InlineResponse201]
  describe 'create_entity test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for create_event
  # Events (Legacy): Create
  # Create a new Event List.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param event 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'create_event test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for create_location
  # Locations (Legacy): Create
  # Create a new Location.   ## Required fields * **&#x60;locationName&#x60;** * **&#x60;address&#x60;** * **&#x60;city&#x60;** * **&#x60;state&#x60;** * **&#x60;zip&#x60;**   ## Optional fields that trigger warnings Submitting invalid values for certain optional fields will not trigger an error response. Instead, the success response will contain warning messages explaining why the invalid optional values were not stored in the system. The fields that generate warning messages are: &lt;br&gt;&lt;br&gt; * **&#x60;logo&#x60;** * **&#x60;photos&#x60;** * **&#x60;twitterHandle&#x60;** * **&#x60;facebookPageUrl&#x60;** * **&#x60;languages&#x60;** 
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param location 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'create_location test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for create_menu
  # Menus: Create
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param menu 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'create_menu test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for create_product
  # Products: Create
  # Create a new Product List.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param product 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'create_product test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_asset
  # Assets: Delete
  # Delete a specific asset.
  # @param account_id 
  # @param asset_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [EmptyResponse]
  describe 'delete_asset test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_bio_list
  # Bios: Delete
  # Delete an existing Bios List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [EmptyResponse]
  describe 'delete_bio_list test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_custom_field
  # Custom Fields: Delete
  # Deletes a Custom Field in an Account.  The Custom Field will be removed from all locations, and all content entered in the Custom Field will be deleted permanently. 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param account_id 
  # @param custom_field_id ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
  # @param [Hash] opts the optional parameters
  # @return [EmptyResponse]
  describe 'delete_custom_field test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_entity
  # Entities: Delete
  # Delete the Entity with the given ID
  # @param account_id 
  # @param entity_id The external ID of the requested Entity
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [InlineResponse2001]
  describe 'delete_entity test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_event_list
  # Events (Legacy): Delete
  # Delete an existing Event List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [EmptyResponse]
  describe 'delete_event_list test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_language_profile
  # Entity Language Profiles: Delete
  # Delete a language profile
  # @param account_id 
  # @param entity_id The external ID of the requested Entity
  # @param language_code The language code corresponding to the language of the profile that the user wishes to delete
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [InlineResponse2004]
  describe 'delete_language_profile test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_location_language_profile
  # Language Profiles (Legacy): Delete
  # Remove a Language Profile from a location.
  # @param account_id 
  # @param location_id 
  # @param language_code Locale code.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [EmptyResponse]
  describe 'delete_location_language_profile test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_menu_list
  # Menus: Delete
  # Delete an existing Menu.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [EmptyResponse]
  describe 'delete_menu_list test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for delete_product_list
  # Products: Delete
  # Delete an existing Products List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [EmptyResponse]
  describe 'delete_product_list test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_asset
  # Assets: Get
  # Get a specific asset.
  # @param account_id 
  # @param asset_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param format Present if and only if type of subfield is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
  # @param [Hash] opts the optional parameters
  # @return [AssetResponse]
  describe 'get_asset test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_bio
  # Bios: Get
  # Retrieve a specific Bios List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [BioListResponse]
  describe 'get_bio test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_bios
  # Bios: List
  # Retrieve all Bio Lists for an account.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :limit Number of results to return.
  # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**. 
  # @return [BioListsResponse]
  describe 'get_bios test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_business_categories
  # Categories: List
  # Get available Categories.  All Locations are required to have an associated Category to assist with organization and search. Yext provides a hierarchy of business categories for this purpose, exposed by this API. 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :language Only categories that apply to this language will be returned.  Valid values: ISO 639-1 language codes  **Example:** en 
  # @option opts [String] :country Only categories that apply in this country will be returned.  Valid values: ISO 3166-1 alpha-2 country codes  **Example:** US 
  # @option opts [String] :entity_type Only categories that apply to the specified entity type will be returned. 
  # @return [BusinessCategoriesResponse]
  describe 'get_business_categories test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_custom_field
  # Custom Fields: Get
  # Gets a specific Custom Field in an Account.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param account_id 
  # @param custom_field_id ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
  # @param [Hash] opts the optional parameters
  # @return [CustomFieldResponse]
  describe 'get_custom_field test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_custom_fields
  # Custom Fields: List
  # Returns a list of Custom Fields in an Account.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param account_id 
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**. 
  # @option opts [Integer] :limit Number of results to return.
  # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data. 
  # @return [CustomFieldsResponse]
  describe 'get_custom_fields test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_entity
  # Entities: Get
  # Retrieve information for an Entity with a given ID
  # @param account_id 
  # @param entity_id The external ID of the requested Entity
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
  # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
  # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response.   - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot;   - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot; 
  # @return [InlineResponse201]
  describe 'get_entity test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_event
  # Events (Legacy): Get
  # Retrieve a specific Event List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [EventListResponse]
  describe 'get_event test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_events
  # Events (Legacy): List
  # Retrieve all Event Lists for an account.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :limit Number of results to return.
  # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**. 
  # @return [EventListsResponse]
  describe 'get_events test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_google_keywords
  # Google Fields: List
  #  Use the Google Fields endpoint to retrieve a complete list of Google&#39;s location attributes for each business category. This list includes attributes that may not apply to all Locations in an account. The set of attributes available to a Location depends on its primary business category. You can view and edit the attributes of Locations in the **&#x60;googleAttributes&#x60;** Location field.  **NOTE:** Google Attributes are managed by Google and are subject to change without notice. To prevent errors, make sure your API implementation is not dependent on the presence of specific attributes. 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :language The language code corresponding to the language in which the user would like to retrieve the Google Fields. Only categories that apply to this language will be returned. 
  # @option opts [String] :client_category_id A category id for the business that, if specified, will filter the result to only include any Google Fields that the provided id maps to. 
  # @option opts [String] :country_code The two-character ISO 3166-1 country code, if specified, will filter the result to only include any Google Fields that are eligible for that country. 
  # @return [GoogleFieldsResponse]
  describe 'get_google_keywords test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_language_profile
  # Entity Language Profiles: Get
  # Retrieve a Language Profile for an Entity  **NOTE**:  * If the **&#x60;v&#x60;** parameter is before &#x60;20190103&#x60;: by default, returned alternate Language Profiles include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields * If the **&#x60;v&#x60;** parameter is &#x60;20190103&#x60; or later: by default, returned alternate Language Profiles do not include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields. However, these fields can still be retrieved if the **&#x60;rendered&#x60;** parameter in the request is set to &#x60;true&#x60;. 
  # @param account_id 
  # @param entity_id The external ID of the requested Entity
  # @param language_code The language code corresponding to the language of the profiles that the user wishes to retrieve
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
  # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
  # @option opts [Boolean] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages. 
  # @return [InlineResponse201]
  describe 'get_language_profile test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_language_profiles
  # Language Profiles (Legacy): List
  # Get Language Profiles for a Location.
  # @param account_id 
  # @param location_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot; 
  # @return [LanguageProfilesResponse]
  describe 'get_language_profiles test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_location
  # Locations (Legacy): Get
  # Gets the primary profile for a single Location.
  # @param account_id 
  # @param location_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot; 
  # @return [LocationResponse]
  describe 'get_location test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_location_folders
  # Folders: List
  # Returns a list of Location Folders in an Account.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**. 
  # @option opts [Integer] :limit Number of results to return.
  # @return [FoldersResponse]
  describe 'get_location_folders test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_location_language_profile
  # Language Profiles (Legacy): Get
  # Gets the the requested Language Profile for a given Location.
  # @param account_id 
  # @param location_id 
  # @param language_code Locale code.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot; 
  # @return [LanguageProfileResponse]
  describe 'get_location_language_profile test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_locations
  # Locations (Legacy): List
  # Get multiple Locations (primary profiles only).
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :limit Number of results to return.
  # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**. 
  # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response. - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot; - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot; 
  # @option opts [String] :page_token If a response to a previous request contained the **&#x60;nextPageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data. 
  # @return [LocationsResponse]
  describe 'get_locations test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_menu
  # Menus: Get
  # Retrieve a specific Menu.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [MenuListResponse]
  describe 'get_menu test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_menus
  # Menus: List
  # Retrieve all Menus for an account.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :limit Number of results to return.
  # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**. 
  # @return [MenuListsResponse]
  describe 'get_menus test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_product
  # Products: Get
  # Retrieve a specific Product List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @return [ProductListResponse]
  describe 'get_product test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for get_products
  # Products: List
  # Retrieve all Product Lists for an account.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :limit Number of results to return.
  # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**. 
  # @return [ProductListsResponse]
  describe 'get_products test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for list_all_language_profiles
  # Entity Language Profiles: List All
  # Retrieve a list of Language Profiles for Entities within an account  **NOTE:**  * If the **&#x60;v&#x60;** parameter is before &#x60;20190103&#x60;: by default, returned alternate Language Profiles include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields * If the **&#x60;v&#x60;** parameter is &#x60;20190103&#x60; or later: by default, returned alternate Language Profiles do not include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields. However, these fields can still be retrieved if the **&#x60;rendered&#x60;** parameter in the request is set to &#x60;true&#x60;. 
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
  # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
  # @option opts [String] :filter This parameter represents one or more filtering conditions that are applied to the set of entities that would otherwise be returned. This parameter should be provided as a URL-encoded string containing a JSON object.  For example, if the filter JSON is &#x60;{\&quot;name\&quot;:{\&quot;$eq\&quot;:\&quot;John\&quot;}}&#x60;, then the filter param after URL-encoding will be: &#x60;filter&#x3D;%7B%22name%22%3A%7B%22%24eq%22%3A%22John%22%7D%7D&#x60;  **Basic Filter Structure**  The filter object at its core consists of a *matcher*, a *field*, and an *argument*.  For example, in the following filter JSON:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  &#x60;$eq&#x60; is the *matcher*, or filtering operation (equals, in this example),  &#x60;name&#x60; is the *field* being filtered by, and  &#x60;John&#x60; is *value* to be matched against.  **Combining Multiple Filters**  Multiple filters can be combined into one object using *combinators*. For example, the following filter JSON combines multiple filters using the combinator &#x60;$and&#x60;. &#x60;$or&#x60; is also supported. &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;firstName\&quot;:{         \&quot;$eq\&quot;:\&quot;John\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;$in\&quot;:[           \&quot;US\&quot;,           \&quot;GB\&quot;         ]       }     }   ] } &#x60;&#x60;&#x60;  **Filter Negation**  Certain filter types may be negated. For example:  &#x60;&#x60;&#x60; {   \&quot;$not\&quot; {     \&quot;name\&quot;:{       \&quot;$eq\&quot;:\&quot;John\&quot;     }   } } &#x60;&#x60;&#x60;  This can also be written more simply with a &#x60;!&#x60; in the &#x60;$eq&#x60; parameter. The following filter would have the same effect:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  **Filter Complement**  You can also search for the complement of a filter. This filter would match entities that do not contain \&quot;hello\&quot; in their descriptions, or do not have a description set. This is different from negation which can only match entities who have the negated field set to something.  &#x60;&#x60;&#x60; {   \&quot;$complement\&quot;:{     \&quot;description\&quot;:{       \&quot;$contains\&quot;:\&quot;hello\&quot;     }   } } &#x60;&#x60;&#x60;  **Addressing Subfields**  Subfields of fields can be addressed using the \&quot;dot\&quot; notation while filtering. For example, if you have a custom field called **&#x60;c_myCustomField&#x60;**:  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField\&quot;:{     \&quot;age\&quot;: 30,     \&quot;name\&quot;: \&quot;Jim\&quot;,   } } &#x60;&#x60;&#x60;  While filtering, subfields may be addressed using the \&quot;dot\&quot; notation.  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField.name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  Fields that are nested deeper may be addressed using dot notation, as well. For example, if **&#x60;name&#x60;** in the above example was a compound field with two subfields **&#x60;first&#x60;** and **&#x60;last&#x60;**, **&#x60;first&#x60;** may be addressed as **&#x60;c_myCustomField.name.first&#x60;**.  **Field Support**  Entity fields correspond to certain filter types, which support matchers. Going by the example above, the field **&#x60;name&#x60;** supports the &#x60;TEXT&#x60; filter type, which supports &#x60;$eq&#x60; (equals) and &#x60;$startsWith&#x60; (starts with).  **TEXT**  The &#x60;TEXT&#x60; filter type is supported for text fields. (e.g., **&#x60;name&#x60;**, **&#x60;countryCode&#x60;**)  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq (equals)&lt;/th&gt;     &lt;th&gt;      {       \&quot;countryCode\&quot;:{         \&quot;$eq\&quot;:\&quot;US\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;!$eq\&quot;:\&quot;US\&quot;       }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;Amazing\&quot; starts with \&quot;amaz\&quot;      {        \&quot;address.line1\&quot;:{           \&quot;$startsWith\&quot;: \&quot;Jo\&quot;        }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;firstName\&quot;:{         \&quot;$in\&quot;: [\&quot;John\&quot;, \&quot;Jimmy\&quot;]       }     }    Does not support negation. Negation can be mimicked by using an \&quot;OR\&quot; matcher, for example:      {       \&quot;$and\&quot;:[         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;John\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;Jimmy\&quot;           }         }       ]     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myString&#x60;**.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAny\&quot;:[           \&quot;sample1\&quot;, \&quot;sample2\&quot;         ]       }     }    This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAll\&quot;:[           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **BOOLEAN**   The BOOLEAN filter type is supported for boolean fields and Yes / No custom fields. &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;isFreeEvent\&quot;: {         \&quot;$eq\&quot;: true       }     }    For booleans, the filter takes a boolean value, not a string.   Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **STRUCT**  The STRUCT filter type is supported for compound fields with subfields.  *e.g., **&#x60;address&#x60;**, **&#x60;featuredMessage&#x60;**, fields of custom types*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$hasProperty&lt;/th&gt;     &lt;th&gt;    Matches if argument is a key (subfield) of field being filtered by. This filter type is useful for filtering by compound fields or to check if certain fields have a value set.      {       \&quot;address\&quot;: {         \&quot;$hasProperty\&quot;: \&quot;line1\&quot;       }     }    Note that if a given property of a compound field is not set, the filter will not match. For example, if &#x60;line1&#x60; of **&#x60;address&#x60;** is not set for an entity, then the above matcher will not match the entity.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **OPTION**  The OPTION filter type is supported for options custom fields and fields that have a predetermined list of valid values.   *e.g., **&#x60;eventStatus&#x60;**, **&#x60;gender&#x60;**, &#x60;SINGLE_OPTION&#x60; and &#x60;MULTI_OPTION&#x60; types of custom fields.*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Matching is case insensitive and insensitive to consecutive whitespace.    e.g., \&quot;XYZ 123\&quot; matches \&quot;xyz       123\&quot;      {       \&quot;eventStatus\&quot;: {         \&quot;$eq\&quot;: \&quot;SCHEDULED\&quot;       }     }    Supports negation. Negating &#x60;$eq&#x60; on the list will match any field that does not hold any of the provided values.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;      {       \&quot;eventStatus\&quot;: {         \&quot;$in\&quot;: [           \&quot;SCHEDULED\&quot;,           \&quot;POSTPONED\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values. For example:      {       \&quot;$and\&quot;: [         {           \&quot;eventStatus\&quot;:{             \&quot;!$eq\&quot;: \&quot;SCHEDULED\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;POSTPONED\&quot;           }         }       ]     }    &lt;/tr&gt; &lt;/table&gt;  **PHONE**  The PHONE filter type is supported for phone number fields only. PHONE will support the same matchers as TEXT, except that for &#x60;$eq&#x60;, the same phone number with or without calling code will match.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;+18187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;8187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;!$eq\&quot;:\&quot;9177076189\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;8187076189\&quot; starts with \&quot;818\&quot;      {       \&quot;mainPhone\&quot;:{         \&quot;$startsWith\&quot;: \&quot;818\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;mainPhone\&quot;:{         \&quot;$in\&quot;: [           \&quot;8185551616\&quot;,           \&quot;9171112211\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values.    &lt;/tr&gt; &lt;/table&gt;  **INTEGER, FLOAT, DATE, DATETIME, and TIME**  These filter types are strictly ordered -- therefore, they support the following matchers: - Equals - Less Than / Less Than or Equal To - Greater Than / Greater Than or Equal To  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Equals      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$eq\&quot;: \&quot;80\&quot;       }     }    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$lt&lt;/th&gt;     &lt;th&gt;    Less than      {       \&quot;time.start\&quot;: {         \&quot;$lt\&quot;: \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$gt&lt;/th&gt;     &lt;th&gt;    Greater than      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$gt\&quot;: \&quot;50\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$le&lt;/th&gt;     &lt;th&gt;    Less than or equal to      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$le\&quot;: \&quot;40\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$ge&lt;/th&gt;     &lt;th&gt;    Greater than or equal to      {       \&quot;time.end\&quot;: {         \&quot;$ge\&quot;:  \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;Combinations&lt;/th&gt;     &lt;th&gt;    While we do not support \&quot;between\&quot; in our filtering syntax, it is possible to combine multiple matchers for a result similar to an \&quot;and\&quot; operation:      {       \&quot;ageRange.maxValue : {         \&quot;$gt\&quot; : 10,         \&quot;$lt\&quot;: 20       }     }    &lt;/tr&gt; &lt;/table&gt;  **LIST OF TEXT**  Any field that has a list of valid values and supports any of the previously mentioned filter types will also support the &#x60;$contains&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eq\&quot;: \&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; EXACTLY matches any string within **&#x60;c_myStringList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if any one of \&quot;sample1\&quot; or \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;** . The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; AND \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;**. The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**.    Note that this matching is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }     This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAny&#x60; is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if BOTH \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in strings within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAll&#x60; is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$startsWith\&quot;:\&quot;sample\&quot;       }     }    This filter will match if any string within **&#x60;c_myStringList&#x60;** starts with \&quot;sample\&quot;.    Does not supports negation. Case Insensitive.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF BOOLEAN, OPTION, PHONE, INTEGER, FLOAT, DATE, DATETIME, OR TIME**  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myDateList\&quot;: {         \&quot;$eq\&quot;: \&quot;2019-01-01\&quot;       }     }     This filter will match if \&quot;2019-01-01\&quot; EXACTLY matches any date within **&#x60;c_myDateList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myIntegerList\&quot;: {         \&quot;$eqAny\&quot;: [1, 2]       }     }    This filter will match if 1 or 2 EXACTLY match any integer within **&#x60;c_myIntegerList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;2019-01-01\&quot; AND \&quot;2019-01-02\&quot; EXACTLY match a date within **&#x60;c_myDateList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF STRUCT**  Filtering on lists of struct types is a bit nuanced. Filtering can only be done on lists of structs of the SAME type. For example, if **&#x60;c_myStructList&#x60;** is a list of compound fields with the subfields **&#x60;age&#x60;** and **&#x60;name&#x60;**, then one can address the **&#x60;age&#x60;** properties of each field in **&#x60;c_myStructList&#x60;** as a flattened list of integers and filtering upon them. For example, the following filter:  &#x60;&#x60;&#x60; {   \&quot;c_myStructList.age\&quot;:{     \&quot;$eq\&quot;: 20   } } &#x60;&#x60;&#x60;  will match if any field in the list has an **&#x60;age&#x60;** property equal to 20. Similarly, any filter that can be applied to lists of integers could be applied to **&#x60;age&#x60;** in this case (&#x60;$eq&#x60;, &#x60;$eqAll&#x60;, &#x60;$eqAny&#x60;).   **HOURS**  By filtering on an hours field, you can find which entities are open or closed at a specified time or during a certain time range. All of these filters also take an entity’s holiday hours and reopen date into account.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openAt\&quot;:           \&quot;2019-01-06T13:45\&quot;       }     }     This filter would match entities open at the specified time.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedAt:           \&quot;2019-01-06T13:45\&quot;       }     }    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$openForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }     This filter would match only those entities that are open for the entire range between 2019-01-06T13:45 and 2019-01-06T15:00.      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;:           \&quot;2019-05-10\&quot;       }     }    This filter would match entities open for the entire 24 hour period on 2019-05-10.    You can also supply a year, a month, or an hour to filter for entities open for the entire year, month, or hour, respectively.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAnyOf\&quot;: {           \&quot;start\&quot;: \&quot;now\&quot;,           \&quot;end\&quot;: \&quot;now+2h\&quot;         }       }     }    This filter will match any entities that are open for at least a portion of the time range between now and two hours from now.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match only those entities that are closed for the entire given time range.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAnyOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match any entities that are closed for at least a portion of the given time range.   &lt;/tr&gt; &lt;/table&gt;   **Filtering by Dates and Times**  **Time zones**  The filtering language supports searching both in local time and within a certain time zone. Searching in local time will simply ignore the time zone on the target entities, while providing one will convert the zone of your queried time to the zone of the target entities.  To search in local time, simply provide the date or time without any zone: &#x60;2019-06-07T15:30&#x60; or &#x60;2019-06-07&#x60;.  To conduct a zoned search, provide the name of the time zone in brackets after the time, as it is shown in the tz database: &#x60;2019-06-07T15:30[America/New_York]&#x60; or &#x60;2019-06-06[America/Phoenix]&#x60;.   **Date and time types**  In addition to searching with dates and datetimes, you can also query with years, months, and hours. For example, the filter:  &#x60;&#x60;&#x60; {   \&quot;time.start\&quot;: {     \&quot;$eq\&quot;: \&quot;2018\&quot;   } } &#x60;&#x60;&#x60;  would match all start times in the year 2018. The same logic would apply for a month (&#x60;2019-05&#x60;), a date (&#x60;2019-05-01&#x60;), or an hour (&#x60;2019-05-01T06&#x60;).  These types also work with ordered searches. For example:  &#x60;&#x60;&#x60; {  \&quot;time.start\&quot;: {     \&quot;$lt\&quot;: \&quot;2018\&quot;  } } &#x60;&#x60;&#x60;  would match start times before 2018 (i.e., anything in 2017 or before). On the other hand, the same query with a &#x60;$le&#x60; matcher would include anything in or before 2018.  **\&quot;Now\&quot; and Date Math**  Instead of providing a static date or time, you can also use &#x60;now&#x60; in place of any date time. When you do so, the system will calculate the time when the query is made and conduct a zoned search.  In order to search for a future or past time relative to &#x60;now&#x60;, you can use date math. For example, you can enter &#x60;now+3h&#x60; or &#x60;now-1d&#x60;, which would mean 3 hours from now and 1 day ago, respectively. You can also add and subtract minutes (&#x60;m&#x60;), months (&#x60;M&#x60;), and years (&#x60;y&#x60;).  It is also possible to add or subtract time from a static date or datetime. Simply add &#x60;||&#x60; between the static value and any addition or subtraction. For example, &#x60;2019-02-03||+1d&#x60; would be the same as &#x60;2019-02-04&#x60;.  You can also convert date and time types to other types. For example, to convert the datetime &#x60;2019-05-06T22:15&#x60; to a date, use &#x60;2019-05-06T22:15||/d&#x60;. Doing so would yield the same result as using &#x60;2019-05-06&#x60;. This method also works with &#x60;now&#x60;: &#x60;now/d&#x60; will give you today’s date without the time.  **Filtering Across an Entity**  It is possible to search for a specific text string across all fields of an entity by using the &#x60;$anywhere&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$anywhere&lt;/th&gt;     &lt;th&gt;    Matches if the argument text appears anywhere in the entity (including subfields, structs, and lists)      {       \&quot;$anywhere\&quot;: \&quot;hello\&quot;     }    This filter will match all entities that contain the string \&quot;hello\&quot; or strings that begin with \&quot;hello\&quot;.    &lt;/tr&gt; &lt;/table&gt;  **Examples**  The following filter will match against entities that: - Are of type &#x60;event&#x60; (note that entity types can also be filtered by the **&#x60;entityTypes&#x60;** query parameter) - Have a name that starts with the text \&quot;Century\&quot; - Have a maximum age between 10 and 20 - Have a minimum age between 5 and 7 - Start after 7 PM (19:00) on August 28, 2018  &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;entityType\&quot;:{         \&quot;$eq\&quot;:\&quot;event\&quot;       }     },     {       \&quot;name\&quot;:{         \&quot;$startsWith\&quot;:\&quot;Century\&quot;       }     },     {       \&quot;ageRange.maxValue\&quot;:{         \&quot;$gt\&quot;:10,         \&quot;$lt\&quot;:20       }     },     {       \&quot;ageRange.minValue\&quot;:{         \&quot;$gt\&quot;:5,         \&quot;$lt\&quot;:7       }     },     {       \&quot;time.start\&quot;:{         \&quot;$ge\&quot;:\&quot;2018-08-28T19:00\&quot;       }     }   ] } &#x60;&#x60;&#x60; 
  # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
  # @option opts [String] :language_codes The comma-separated language codes corresponding to the languages of the profile that the user wishes to retrieve
  # @option opts [Float] :limit Number of results to return.
  # @option opts [Float] :offset Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  For Live API requests, the offset cannot be higher than 9,950. For Knowledge API the maximum limit is only enforced if a filter and/or sortBy parameter are given. 
  # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
  # @option opts [String] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages. 
  # @option opts [String] :sort_by A list of fields and sort directions to order results by. Each ordering in the list should be in the format &#x60;{\&quot;field_name\&quot;, \&quot;sort_direction\&quot;}&#x60;, where &#x60;sort_direction&#x60; is either &#x60;ASCENDING&#x60; or &#x60;DESCENDING&#x60;.  For example, to order by &#x60;name&#x60; the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. To order by &#x60;name&#x60; and then &#x60;description&#x60;, the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;},{\&quot;description\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. 
  # @return [InlineResponse2003]
  describe 'list_all_language_profiles test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for list_assets
  # Assets: List
  # List assets in an account.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param format Present if and only if type of subfield is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :offset  Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**. 
  # @option opts [Integer] :limit Number of results to return.
  # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
  # @return [AssetsResponse]
  describe 'list_assets test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for list_entities
  # Entities: List
  # Retrieve a list of Entities within an account
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
  # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
  # @option opts [String] :filter This parameter represents one or more filtering conditions that are applied to the set of entities that would otherwise be returned. This parameter should be provided as a URL-encoded string containing a JSON object.  For example, if the filter JSON is &#x60;{\&quot;name\&quot;:{\&quot;$eq\&quot;:\&quot;John\&quot;}}&#x60;, then the filter param after URL-encoding will be: &#x60;filter&#x3D;%7B%22name%22%3A%7B%22%24eq%22%3A%22John%22%7D%7D&#x60;  **Basic Filter Structure**  The filter object at its core consists of a *matcher*, a *field*, and an *argument*.  For example, in the following filter JSON:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  &#x60;$eq&#x60; is the *matcher*, or filtering operation (equals, in this example),  &#x60;name&#x60; is the *field* being filtered by, and  &#x60;John&#x60; is *value* to be matched against.  **Combining Multiple Filters**  Multiple filters can be combined into one object using *combinators*. For example, the following filter JSON combines multiple filters using the combinator &#x60;$and&#x60;. &#x60;$or&#x60; is also supported. &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;firstName\&quot;:{         \&quot;$eq\&quot;:\&quot;John\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;$in\&quot;:[           \&quot;US\&quot;,           \&quot;GB\&quot;         ]       }     }   ] } &#x60;&#x60;&#x60;  **Filter Negation**  Certain filter types may be negated. For example:  &#x60;&#x60;&#x60; {   \&quot;$not\&quot; {     \&quot;name\&quot;:{       \&quot;$eq\&quot;:\&quot;John\&quot;     }   } } &#x60;&#x60;&#x60;  This can also be written more simply with a &#x60;!&#x60; in the &#x60;$eq&#x60; parameter. The following filter would have the same effect:  &#x60;&#x60;&#x60; {   \&quot;name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  **Filter Complement**  You can also search for the complement of a filter. This filter would match entities that do not contain \&quot;hello\&quot; in their descriptions, or do not have a description set. This is different from negation which can only match entities who have the negated field set to something.  &#x60;&#x60;&#x60; {   \&quot;$complement\&quot;:{     \&quot;description\&quot;:{       \&quot;$contains\&quot;:\&quot;hello\&quot;     }   } } &#x60;&#x60;&#x60;  **Addressing Subfields**  Subfields of fields can be addressed using the \&quot;dot\&quot; notation while filtering. For example, if you have a custom field called **&#x60;c_myCustomField&#x60;**:  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField\&quot;:{     \&quot;age\&quot;: 30,     \&quot;name\&quot;: \&quot;Jim\&quot;,   } } &#x60;&#x60;&#x60;  While filtering, subfields may be addressed using the \&quot;dot\&quot; notation.  &#x60;&#x60;&#x60; {   \&quot;c_myCustomField.name\&quot;:{     \&quot;!$eq\&quot;:\&quot;John\&quot;   } } &#x60;&#x60;&#x60;  Fields that are nested deeper may be addressed using dot notation, as well. For example, if **&#x60;name&#x60;** in the above example was a compound field with two subfields **&#x60;first&#x60;** and **&#x60;last&#x60;**, **&#x60;first&#x60;** may be addressed as **&#x60;c_myCustomField.name.first&#x60;**.  **Field Support**  Entity fields correspond to certain filter types, which support matchers. Going by the example above, the field **&#x60;name&#x60;** supports the &#x60;TEXT&#x60; filter type, which supports &#x60;$eq&#x60; (equals) and &#x60;$startsWith&#x60; (starts with).  **TEXT**  The &#x60;TEXT&#x60; filter type is supported for text fields. (e.g., **&#x60;name&#x60;**, **&#x60;countryCode&#x60;**)  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq (equals)&lt;/th&gt;     &lt;th&gt;      {       \&quot;countryCode\&quot;:{         \&quot;$eq\&quot;:\&quot;US\&quot;       }     },     {       \&quot;countryCode\&quot;:{         \&quot;!$eq\&quot;:\&quot;US\&quot;       }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;Amazing\&quot; starts with \&quot;amaz\&quot;      {        \&quot;address.line1\&quot;:{           \&quot;$startsWith\&quot;: \&quot;Jo\&quot;        }     }    Supports negation. Case insensitive.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;firstName\&quot;:{         \&quot;$in\&quot;: [\&quot;John\&quot;, \&quot;Jimmy\&quot;]       }     }    Does not support negation. Negation can be mimicked by using an \&quot;OR\&quot; matcher, for example:      {       \&quot;$and\&quot;:[         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;John\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;Jimmy\&quot;           }         }       ]     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myString&#x60;**.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAny\&quot;:[           \&quot;sample1\&quot;, \&quot;sample2\&quot;         ]       }     }    This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myString\&quot;:{         \&quot;$containsAll\&quot;:[           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in any string within **&#x60;c_myString&#x60;**. The argument list can contain more than two strings.    Note that this matching is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **BOOLEAN**   The BOOLEAN filter type is supported for boolean fields and Yes / No custom fields. &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;isFreeEvent\&quot;: {         \&quot;$eq\&quot;: true       }     }    For booleans, the filter takes a boolean value, not a string.   Supports negation.   &lt;/tr&gt; &lt;/table&gt;  **STRUCT**  The STRUCT filter type is supported for compound fields with subfields.  *e.g., **&#x60;address&#x60;**, **&#x60;featuredMessage&#x60;**, fields of custom types*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$hasProperty&lt;/th&gt;     &lt;th&gt;    Matches if argument is a key (subfield) of field being filtered by. This filter type is useful for filtering by compound fields or to check if certain fields have a value set.      {       \&quot;address\&quot;: {         \&quot;$hasProperty\&quot;: \&quot;line1\&quot;       }     }    Note that if a given property of a compound field is not set, the filter will not match. For example, if &#x60;line1&#x60; of **&#x60;address&#x60;** is not set for an entity, then the above matcher will not match the entity.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **OPTION**  The OPTION filter type is supported for options custom fields and fields that have a predetermined list of valid values.   *e.g., **&#x60;eventStatus&#x60;**, **&#x60;gender&#x60;**, &#x60;SINGLE_OPTION&#x60; and &#x60;MULTI_OPTION&#x60; types of custom fields.*  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Matching is case insensitive and insensitive to consecutive whitespace.    e.g., \&quot;XYZ 123\&quot; matches \&quot;xyz       123\&quot;      {       \&quot;eventStatus\&quot;: {         \&quot;$eq\&quot;: \&quot;SCHEDULED\&quot;       }     }    Supports negation. Negating &#x60;$eq&#x60; on the list will match any field that does not hold any of the provided values.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;      {       \&quot;eventStatus\&quot;: {         \&quot;$in\&quot;: [           \&quot;SCHEDULED\&quot;,           \&quot;POSTPONED\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values. For example:      {       \&quot;$and\&quot;: [         {           \&quot;eventStatus\&quot;:{             \&quot;!$eq\&quot;: \&quot;SCHEDULED\&quot;           }         },         {           \&quot;firstName\&quot;:{             \&quot;!$eq\&quot;: \&quot;POSTPONED\&quot;           }         }       ]     }    &lt;/tr&gt; &lt;/table&gt;  **PHONE**  The PHONE filter type is supported for phone number fields only. PHONE will support the same matchers as TEXT, except that for &#x60;$eq&#x60;, the same phone number with or without calling code will match.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;+18187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;$eq\&quot;:\&quot;8187076189\&quot;       }     },     {       \&quot;mainPhone\&quot;:{         \&quot;!$eq\&quot;:\&quot;9177076189\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;    Matches if the field starts with the argument value.    e.g., \&quot;8187076189\&quot; starts with \&quot;818\&quot;      {       \&quot;mainPhone\&quot;:{         \&quot;$startsWith\&quot;: \&quot;818\&quot;       }     }    Supports negation. Case insensitive.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$in&lt;/th&gt;     &lt;th&gt;    Matches if field value is a member of the argument list.      {       \&quot;mainPhone\&quot;:{         \&quot;$in\&quot;: [           \&quot;8185551616\&quot;,           \&quot;9171112211\&quot;         ]       }     }    Does not support negation. However, negation can be mimicked by using an &#x60;$and&#x60; matcher to negate individually over the desired values.    &lt;/tr&gt; &lt;/table&gt;  **INTEGER, FLOAT, DATE, DATETIME, and TIME**  These filter types are strictly ordered -- therefore, they support the following matchers: - Equals - Less Than / Less Than or Equal To - Greater Than / Greater Than or Equal To  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;    Equals      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$eq\&quot;: \&quot;80\&quot;       }     }    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$lt&lt;/th&gt;     &lt;th&gt;    Less than      {       \&quot;time.start\&quot;: {         \&quot;$lt\&quot;: \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$gt&lt;/th&gt;     &lt;th&gt;    Greater than      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$gt\&quot;: \&quot;50\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$le&lt;/th&gt;     &lt;th&gt;    Less than or equal to      {       \&quot;ageRange.maxValue\&quot;: {         \&quot;$le\&quot;: \&quot;40\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$ge&lt;/th&gt;     &lt;th&gt;    Greater than or equal to      {       \&quot;time.end\&quot;: {         \&quot;$ge\&quot;:  \&quot;2018-08-28T05:56\&quot;       }     }    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;Combinations&lt;/th&gt;     &lt;th&gt;    While we do not support \&quot;between\&quot; in our filtering syntax, it is possible to combine multiple matchers for a result similar to an \&quot;and\&quot; operation:      {       \&quot;ageRange.maxValue : {         \&quot;$gt\&quot; : 10,         \&quot;$lt\&quot;: 20       }     }    &lt;/tr&gt; &lt;/table&gt;  **LIST OF TEXT**  Any field that has a list of valid values and supports any of the previously mentioned filter types will also support the &#x60;$contains&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eq\&quot;: \&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; EXACTLY matches any string within **&#x60;c_myStringList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if any one of \&quot;sample1\&quot; or \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;** . The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;sample1\&quot; AND \&quot;sample2\&quot; EXACTLY match a string within **&#x60;c_myStringList&#x60;**. The argument can have more than two strings.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$contains&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;:{         \&quot;$contains\&quot;:\&quot;sample\&quot;       }     }    This filter will match if \&quot;sample\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**.    Note that this matching is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAny\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }     This filter will match if either \&quot;sample1\&quot; or \&quot;sample2\&quot; is contained in any string within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAny&#x60; is \&quot;left edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This is a sample\&quot;, \&quot;Sample one\&quot;, \&quot;Sample 2\&quot; but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$containsAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$containsAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if BOTH \&quot;sample1\&quot; and \&quot;sample2\&quot; are contained in strings within **&#x60;c_myStringList&#x60;**. The argument list can have more than two strings.    Note that similar to &#x60;$contains&#x60;, the matching for &#x60;$containsAll&#x60; is \&quot;left-edge n-gram\&quot;, meaning the argument string must be the beginning of a token. The string \&quot;sample\&quot; will match strings like \&quot;This a sample\&quot;, \&quot;Sample one\&quot;, and \&quot;Sample 2\&quot;, but not strings like \&quot;thisisasamplewithoutspaces\&quot;.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$startsWith&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$startsWith\&quot;:\&quot;sample\&quot;       }     }    This filter will match if any string within **&#x60;c_myStringList&#x60;** starts with \&quot;sample\&quot;.    Does not supports negation. Case Insensitive.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF BOOLEAN, OPTION, PHONE, INTEGER, FLOAT, DATE, DATETIME, OR TIME**  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eq&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myDateList\&quot;: {         \&quot;$eq\&quot;: \&quot;2019-01-01\&quot;       }     }     This filter will match if \&quot;2019-01-01\&quot; EXACTLY matches any date within **&#x60;c_myDateList&#x60;**.    Supports negation.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$eqAny&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myIntegerList\&quot;: {         \&quot;$eqAny\&quot;: [1, 2]       }     }    This filter will match if 1 or 2 EXACTLY match any integer within **&#x60;c_myIntegerList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$eqAll&lt;/th&gt;     &lt;th&gt;      {       \&quot;c_myStringList\&quot;: {         \&quot;$eqAll\&quot;: [           \&quot;sample1\&quot;,           \&quot;sample2\&quot;         ]       }     }    This filter will match if both \&quot;2019-01-01\&quot; AND \&quot;2019-01-02\&quot; EXACTLY match a date within **&#x60;c_myDateList&#x60;**. The argument list can have more than two elements.    Supports negation.    &lt;/tr&gt; &lt;/table&gt;  **LIST OF STRUCT**  Filtering on lists of struct types is a bit nuanced. Filtering can only be done on lists of structs of the SAME type. For example, if **&#x60;c_myStructList&#x60;** is a list of compound fields with the subfields **&#x60;age&#x60;** and **&#x60;name&#x60;**, then one can address the **&#x60;age&#x60;** properties of each field in **&#x60;c_myStructList&#x60;** as a flattened list of integers and filtering upon them. For example, the following filter:  &#x60;&#x60;&#x60; {   \&quot;c_myStructList.age\&quot;:{     \&quot;$eq\&quot;: 20   } } &#x60;&#x60;&#x60;  will match if any field in the list has an **&#x60;age&#x60;** property equal to 20. Similarly, any filter that can be applied to lists of integers could be applied to **&#x60;age&#x60;** in this case (&#x60;$eq&#x60;, &#x60;$eqAll&#x60;, &#x60;$eqAny&#x60;).   **HOURS**  By filtering on an hours field, you can find which entities are open or closed at a specified time or during a certain time range. All of these filters also take an entity’s holiday hours and reopen date into account.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openAt\&quot;:           \&quot;2019-01-06T13:45\&quot;       }     }     This filter would match entities open at the specified time.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedAt&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedAt:           \&quot;2019-01-06T13:45\&quot;       }     }    &lt;/tr&gt;    &lt;tr&gt;     &lt;th&gt;$openForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }     This filter would match only those entities that are open for the entire range between 2019-01-06T13:45 and 2019-01-06T15:00.      {       \&quot;hours\&quot;: {         \&quot;$openForAllOf\&quot;:           \&quot;2019-05-10\&quot;       }     }    This filter would match entities open for the entire 24 hour period on 2019-05-10.    You can also supply a year, a month, or an hour to filter for entities open for the entire year, month, or hour, respectively.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$openForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$openForAnyOf\&quot;: {           \&quot;start\&quot;: \&quot;now\&quot;,           \&quot;end\&quot;: \&quot;now+2h\&quot;         }       }     }    This filter will match any entities that are open for at least a portion of the time range between now and two hours from now.    &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAllOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAllOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match only those entities that are closed for the entire given time range.   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$closedForAnyOf&lt;/th&gt;     &lt;th&gt;      {       \&quot;hours\&quot;: {         \&quot;$closedForAnyOf\&quot;: {           \&quot;start\&quot;:             \&quot;2019-01-06T13:45\&quot;,           \&quot;end\&quot;:             \&quot;2019-01-06T15:00\&quot;         }       }     }    This filter will match any entities that are closed for at least a portion of the given time range.   &lt;/tr&gt; &lt;/table&gt;   **Filtering by Dates and Times**  **Time zones**  The filtering language supports searching both in local time and within a certain time zone. Searching in local time will simply ignore the time zone on the target entities, while providing one will convert the zone of your queried time to the zone of the target entities.  To search in local time, simply provide the date or time without any zone: &#x60;2019-06-07T15:30&#x60; or &#x60;2019-06-07&#x60;.  To conduct a zoned search, provide the name of the time zone in brackets after the time, as it is shown in the tz database: &#x60;2019-06-07T15:30[America/New_York]&#x60; or &#x60;2019-06-06[America/Phoenix]&#x60;.   **Date and time types**  In addition to searching with dates and datetimes, you can also query with years, months, and hours. For example, the filter:  &#x60;&#x60;&#x60; {   \&quot;time.start\&quot;: {     \&quot;$eq\&quot;: \&quot;2018\&quot;   } } &#x60;&#x60;&#x60;  would match all start times in the year 2018. The same logic would apply for a month (&#x60;2019-05&#x60;), a date (&#x60;2019-05-01&#x60;), or an hour (&#x60;2019-05-01T06&#x60;).  These types also work with ordered searches. For example:  &#x60;&#x60;&#x60; {  \&quot;time.start\&quot;: {     \&quot;$lt\&quot;: \&quot;2018\&quot;  } } &#x60;&#x60;&#x60;  would match start times before 2018 (i.e., anything in 2017 or before). On the other hand, the same query with a &#x60;$le&#x60; matcher would include anything in or before 2018.  **\&quot;Now\&quot; and Date Math**  Instead of providing a static date or time, you can also use &#x60;now&#x60; in place of any date time. When you do so, the system will calculate the time when the query is made and conduct a zoned search.  In order to search for a future or past time relative to &#x60;now&#x60;, you can use date math. For example, you can enter &#x60;now+3h&#x60; or &#x60;now-1d&#x60;, which would mean 3 hours from now and 1 day ago, respectively. You can also add and subtract minutes (&#x60;m&#x60;), months (&#x60;M&#x60;), and years (&#x60;y&#x60;).  It is also possible to add or subtract time from a static date or datetime. Simply add &#x60;||&#x60; between the static value and any addition or subtraction. For example, &#x60;2019-02-03||+1d&#x60; would be the same as &#x60;2019-02-04&#x60;.  You can also convert date and time types to other types. For example, to convert the datetime &#x60;2019-05-06T22:15&#x60; to a date, use &#x60;2019-05-06T22:15||/d&#x60;. Doing so would yield the same result as using &#x60;2019-05-06&#x60;. This method also works with &#x60;now&#x60;: &#x60;now/d&#x60; will give you today’s date without the time.  **Filtering Across an Entity**  It is possible to search for a specific text string across all fields of an entity by using the &#x60;$anywhere&#x60; matcher.  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Matcher&lt;/th&gt;     &lt;th&gt;Details&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;$anywhere&lt;/th&gt;     &lt;th&gt;    Matches if the argument text appears anywhere in the entity (including subfields, structs, and lists)      {       \&quot;$anywhere\&quot;: \&quot;hello\&quot;     }    This filter will match all entities that contain the string \&quot;hello\&quot; or strings that begin with \&quot;hello\&quot;.    &lt;/tr&gt; &lt;/table&gt;  **Examples**  The following filter will match against entities that: - Are of type &#x60;event&#x60; (note that entity types can also be filtered by the **&#x60;entityTypes&#x60;** query parameter) - Have a name that starts with the text \&quot;Century\&quot; - Have a maximum age between 10 and 20 - Have a minimum age between 5 and 7 - Start after 7 PM (19:00) on August 28, 2018  &#x60;&#x60;&#x60; {   \&quot;$and\&quot;:[     {       \&quot;entityType\&quot;:{         \&quot;$eq\&quot;:\&quot;event\&quot;       }     },     {       \&quot;name\&quot;:{         \&quot;$startsWith\&quot;:\&quot;Century\&quot;       }     },     {       \&quot;ageRange.maxValue\&quot;:{         \&quot;$gt\&quot;:10,         \&quot;$lt\&quot;:20       }     },     {       \&quot;ageRange.minValue\&quot;:{         \&quot;$gt\&quot;:5,         \&quot;$lt\&quot;:7       }     },     {       \&quot;time.start\&quot;:{         \&quot;$ge\&quot;:\&quot;2018-08-28T19:00\&quot;       }     }   ] } &#x60;&#x60;&#x60; 
  # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
  # @option opts [String] :languages Comma-separated list of language codes.  When present, the system will return Entities that have profiles in one or more of the provided languages. For each Location, only the first available profile from the provided list of languages will be returned. The keyword &#x60;\&quot;primary\&quot;&#x60; can be used to refer to a Location’s primary profile without providing a specific language code. If an Entity does not have profiles in any of the languages provided, that Entity&#39;s primary profile will be returned. 
  # @option opts [Float] :limit Number of results to return.
  # @option opts [Float] :offset Number of results to skip. Used to page through results. Cannot be used together with **&#x60;pageToken&#x60;**.  For Live API requests, the offset cannot be higher than 9,950. For Knowledge API the maximum limit is only enforced if a filter and/or sortBy parameter are given. 
  # @option opts [String] :page_token If a response to a previous request contained the **&#x60;pageToken&#x60;** field, pass that field&#39;s value as the **&#x60;pageToken&#x60;** parameter to retrieve the next page of data.
  # @option opts [Boolean] :resolve_placeholders Optional parameter to resolve all embedded fields in a Location object response.   - &#x60;false&#x60;: Location object returns placeholder labels, e.g., \&quot;Your [[CITY]] store\&quot;   - &#x60;true&#x60;: Location object returns placeholder values, e.g., \&quot;Your Fairfax store\&quot; 
  # @option opts [String] :sort_by A list of fields and sort directions to order results by. Each ordering in the list should be in the format &#x60;{\&quot;field_name\&quot;, \&quot;sort_direction\&quot;}&#x60;, where &#x60;sort_direction&#x60; is either &#x60;ASCENDING&#x60; or &#x60;DESCENDING&#x60;.  For example, to order by &#x60;name&#x60; the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. To order by &#x60;name&#x60; and then &#x60;description&#x60;, the sort order would be &#x60;[{\&quot;name\&quot;:\&quot;ASCENDING\&quot;},{\&quot;description\&quot;:\&quot;ASCENDING\&quot;}]&#x60;. 
  # @return [InlineResponse200]
  describe 'list_entities test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for list_language_profiles
  # Entity Language Profiles: List
  # Retrieve Language Profiles for an Entity  * If the **&#x60;v&#x60;** parameter is before &#x60;20190103&#x60;: by default, returned alternate Language Profiles include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields * If the **&#x60;v&#x60;** parameter is &#x60;20190103&#x60; or later: by default, returned alternate Language Profiles do not include **&#x60;googleAttributes&#x60;** and **&#x60;categoryIds&#x60;** fields. However, these fields can still be retrieved if the **&#x60;rendered&#x60;** parameter in the request is set to &#x60;true&#x60;. 
  # @param account_id 
  # @param entity_id The external ID of the requested Entity
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :entity_types Comma-separated list of Entity types to filter on. Example: &#x60;\&quot;location,event\&quot;&#x60;  Should be from the following types:   * &#x60;atm&#x60;   * &#x60;event&#x60;   * &#x60;faq&#x60;   * &#x60;financialProfessional&#x60;   * &#x60;healthcareFacility&#x60;   * &#x60;healthcareProfessional&#x60;   * &#x60;hotel&#x60;   * &#x60;hotelRoomType&#x60;   * &#x60;job&#x60;   * &#x60;location&#x60;   * &#x60;organization&#x60;   * &#x60;product&#x60;   * &#x60;restaurant&#x60;  OR the API name of a custom entity type. 
  # @option opts [String] :fields Comma-separated list of field names. When present, only the fields listed will be returned. You can use dot notation to specify substructures (e.g., &#x60;\&quot;address.line1\&quot;&#x60;). Custom fields are specified in the same way, albeit with their &#x60;c_*&#x60; name.
  # @option opts [String] :format Present if and only if at least one field is of type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60;   * &#x60;none&#x60; 
  # @option opts [String] :language_codes The comma-separated language codes corresponding to the languages of the profile that the user wishes to retrieve
  # @option opts [String] :rendered - &#x60;false&#x60;: The response will only contain overridable or language-specific fields for the requested language. - &#x60;true&#x60;:  The response will contain the full location profile in the requested language, including data that remains the same across languages. 
  # @return [InlineResponse2002]
  describe 'list_language_profiles test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for search_locations
  # Locations (Legacy): Search
  # Get multiple Locations (primary profiles only) that match provided filters.
  # @param account_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param [Hash] opts the optional parameters
  # @option opts [Integer] :limit Number of results to return.
  # @option opts [Integer] :offset Number of results to skip. Used to page through results.
  # @option opts [String] :filters A set of filters that is applied to the set of locations that would otherwise be returned. Should be provided as a URL-encoded string containing a JSON array. The array should have one or more filter objects defined. All filter objects will apply as an intersection (i.e., AND). Field names reference Location fields, as well as custom fields using the format &#x60;custom###&#x60;, where \&quot;###\&quot; is the custom field’s **&#x60;id&#x60;**.  For example, to provide a filter that would match location names containing the word \&quot;gourmet\&quot;, the filter parameter would be &#x60;[{\&quot;name\&quot;:{\&quot;contains\&quot;:[\&quot;gourmet\&quot;]}}]&#x60;, which URL-encoded would be &#x60;%5B%7B%22name%22%3A%7B%22contains%22%3A%5B%22gourmet%22%5D%7D%7D%5D&#x60;.  NOTE: \&quot;x\&quot;, \&quot;xx\&quot;, and \&quot;xxx\&quot; are reserved keywords that, when passed in a &#x60;contains&#x60; matcher for a Full or Text filter, will cause that filter to match on all locations.  The filter types are the following. Note there may be multiple available specifications for a given filter type:  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Filter Type&lt;/th&gt;     &lt;th&gt;Syntax&lt;/th&gt;     &lt;th&gt;Description&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Full&lt;/td&gt;     &lt;td&gt;fieldName: {contains: $search}&lt;/td&gt;     &lt;td&gt;$search is the search string&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$search,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [contains,doesNotContain,startsWith,equalTo], $search is an array of search strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [empty,notEmpty]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $value}&lt;/td&gt;     &lt;td&gt;$type is one of [eq,lt,gt,le,ge], $value is the numeric value&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$value1, $value2]}&lt;/td&gt;     &lt;td&gt;$type is one of [between], $value1 and $value2 are numeric values&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $value}&lt;/td&gt;     &lt;td&gt;$type is one of [eq,lt,gt,le,ge], $value is a string of \&quot;YYYY-MM-DD\&quot; formatted date&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [empty,notEmpty]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$value1, $value2]}&lt;/td&gt;     &lt;td&gt;$type is one of [between], $value1 and $value2 are strings of \&quot;YYYY-MM-DD\&quot; formatted date&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of numeric category IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [none]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Assets&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of numeric category IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Assets&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [none]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Country&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$country,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $country is an array of country code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;PrimaryLanguage&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$language,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $language is an array of language code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;AlternateLanguage&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$language,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes, notIncludes], $language is an array of language code strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$string,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $string is an array of strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$string,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $string is an array of strings, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;LocationType&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $id is an array of location type IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;fieldName: $type&lt;/td&gt;     &lt;td&gt;$type is one of [true,false]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Option&lt;/td&gt;     &lt;td&gt;fieldName: {$type: $id}&lt;/td&gt;     &lt;td&gt;$type is one of [is,isNot], $id is an option ID (For single option custom fields)&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Option&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of option IDs, combined with OR (For multi option custom fields)&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: [$id,...]&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: $id&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$id is a numeric folder ID, $type is one of [&#39;isIn&#39;, &#39;isNotIn&#39;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;Labels&lt;/td&gt;     &lt;td&gt;fieldName: {$type: [$id,...]}&lt;/td&gt;     &lt;td&gt;$type is one of [includes,notIncludes], $id is an array of label IDs, combined with OR&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt;  The following fields can be specified in the request (Field name/Filter Type/Example(s)):  &lt;table style&#x3D;\&quot;width:100%\&quot;&gt;   &lt;tr&gt;     &lt;th&gt;Field Name&lt;/th&gt;     &lt;th&gt;Filter Type&lt;/th&gt;     &lt;th&gt;Example(s)&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;location&lt;/td&gt;     &lt;td&gt;Full&lt;/td&gt;     &lt;td&gt;\&quot;location\&quot;: {\&quot;contains\&quot;: \&quot;Atlanta\&quot;}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;name&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;name\&quot;: {\&quot;startsWith\&quot;: [\&quot;Guitar\&quot;]}, \&quot;name\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;address&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;address\&quot;: {\&quot;startsWith\&quot;: [\&quot;South\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;address2&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;address2\&quot;: {\&quot;contains\&quot;: [\&quot;Suite\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;city&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;city\&quot;: {\&quot;contains\&quot;: [\&quot;Atlanta\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;state&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;state\&quot;: {\&quot;contains\&quot;: [\&quot;AK\&quot;,\&quot;VA\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;zip&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;zip\&quot;: {\&quot;contains\&quot;: [\&quot;M5K 7QB\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;phones&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;phones\&quot;: {\&quot;startsWith\&quot;: [\&quot;703\&quot;,\&quot;571\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;specialOffer&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;specialOffer\&quot;: \&quot;notEmpty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;emails&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;emails\&quot;: {\&quot;doesNotContain\&quot;: [\&quot;@yext.com\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;website&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;website\&quot;: {\&quot;equalTo\&quot;: [\&quot;https://www.yext.com/\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;categories&lt;/td&gt;     &lt;td&gt;Categories&lt;/td&gt;     &lt;td&gt;\&quot;categories\&quot;: {\&quot;includes\&quot;: [23,755,34]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;closed&lt;/td&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;\&quot;closed\&quot;: true&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;storeId&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;storeId\&quot;: {\&quot;equalTo\&quot;: [\&quot;MCD0001\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;countryCode&lt;/td&gt;     &lt;td&gt;Country&lt;/td&gt;     &lt;td&gt;\&quot;countryCode\&quot;: {\&quot;notIncludes\&quot;: [\&quot;US\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;products&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;products\&quot;: {\&quot;startsWith\&quot;: [\&quot;Burger\&quot;,\&quot;Fries\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;services&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;services\&quot;: {\&quot;contains\&quot;: [\&quot;Manicures\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;specialities&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;services\&quot;: \&quot;notEmpty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;associations&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;associations\&quot;: \&quot;empty\&quot;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;brands&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;brands\&quot;: {\&quot;equalTo\&quot;: [\&quot;North Face\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;languages&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;languages\&quot;: {\&quot;equalTo\&quot;: [\&quot;English\&quot;,\&quot;Spanish\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;keywords&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;keywords\&quot;: {\&quot;startsWith\&quot;: [\&quot;Franchise\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;menuIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;menuIds\&quot;: {\&quot;includes\&quot;: [\&quot;m-23\&quot;,\&quot;755\&quot;,\&quot;menu34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;productListIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;productListIds\&quot;: {\&quot;notIncludes\&quot;: [\&quot;pl-2\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;calendarIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;calendarIds\&quot;: {\&quot;notIncludes\&quot;: [\&quot;cal34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;bioIds&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;bioIds\&quot;: {\&quot;includes\&quot;: [\&quot;b23\&quot;,\&quot;34\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;custom###&lt;/td&gt;     &lt;td&gt;Text (for Multiline Text, URL, Text List, and Text Custom Fields), Number, Date, Bool, or Option&lt;/td&gt;     &lt;td&gt;\&quot;custom123\&quot;: {\&quot;equalTo\&quot;: [\&quot;asdf\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;folder&lt;/td&gt;     &lt;td&gt;Folder&lt;/td&gt;     &lt;td&gt;\&quot;folder\&quot;: 123, \&quot;folder\&quot;: [123,456]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;primary_language&lt;/td&gt;     &lt;td&gt;PrimaryLanguage&lt;/td&gt;     &lt;td&gt;\&quot;primary_language\&quot;: {\&quot;is\&quot;: \&quot;fr_CA\&quot;}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;alternateProfileLanguage&lt;/td&gt;     &lt;td&gt;AlternateLanguage&lt;/td&gt;     &lt;td&gt;\&quot;alternateProfileLanguage\&quot;: {\&quot;includes\&quot;: [\&quot;en\&quot;, \&quot;fr\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;npi&lt;/td&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;\&quot;npi\&quot;: {\&quot;is\&quot;: [\&quot;1234567890\&quot;, \&quot;1111111111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;conditionsTreated&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;conditionsTreated\&quot;: {\&quot;startsWith\&quot;: [\&quot;Influenza\&quot;]}, \&quot;conditionsTreated\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;lastUpdated&lt;/td&gt;     &lt;td&gt;Date&lt;/td&gt;     &lt;td&gt;\&quot;lastUpdated\&quot;: {\&quot;eq\&quot;: \&quot;2018-01-01\&quot;}, \&quot;lastUpdated\&quot;: {\&quot;between\&quot;: [\&quot;2017-01-01\&quot;, \&quot;2018-01-01\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;fieldsWithData&lt;/td&gt;     &lt;td&gt;Fields&lt;/td&gt;     &lt;td&gt;\&quot;fieldsWithData\&quot;: [\&quot;email\&quot;, \&quot;hours\&quot;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;fieldsWithoutData&lt;/td&gt;     &lt;td&gt;Fields&lt;/td&gt;     &lt;td&gt;\&quot;fieldsWithoutData\&quot;: [\&quot;logo\&quot;, \&quot;video\&quot;]&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;reviewCount&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;review_count\&quot;: {\&quot;gt\&quot;: 1}, \&quot;review_count \&quot;: {\&quot;lt\&quot;: 10}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;averageRating&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;averageRating\&quot;: {\&quot;lt\&quot;: 3}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;locationType&lt;/td&gt;     &lt;td&gt;LocationType&lt;/td&gt;     &lt;td&gt;\&quot;locationType\&quot;: {\&quot;is\&quot;: [1]}, \&quot;locationType\&quot;: {\&quot;isNot\&quot;: [123]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;gender&lt;/td&gt;     &lt;td&gt;StringSingle&lt;/td&gt;     &lt;td&gt;\&quot;gender\&quot;: {\&quot;is\&quot;: [\&quot;FEMALE\&quot;]}, \&quot;gender\&quot;: {\&quot;isNot\&quot;: [\&quot;MALE\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;degrees&lt;/td&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;\&quot;degrees\&quot;: {\&quot;includes\&quot;: [\&quot;MD\&quot;]}, \&quot;degrees\&quot;: {\&quot;notIncludes\&quot;: [\&quot;PHD\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;experiences&lt;/td&gt;     &lt;td&gt;StringList&lt;/td&gt;     &lt;td&gt;\&quot;experiences\&quot;: {\&quot;includes\&quot;: [\&quot;FELLOWSHIP\&quot;]}, \&quot;experiences\&quot;: {\&quot;notIncludes\&quot;:[\&quot;INTERNSHIP\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;yearCompleted&lt;/td&gt;     &lt;td&gt;Number&lt;/td&gt;     &lt;td&gt;\&quot;yearCompleted\&quot;: {\&quot;gt\&quot;: 2000}, \&quot;yearCompleted\&quot;: {\&quot;lt\&quot;: 2015}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;acceptingNewPatients&lt;/td&gt;     &lt;td&gt;Bool&lt;/td&gt;     &lt;td&gt;\&quot;acceptingNewPatients\&quot;: true&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;firstName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;firstName\&quot;: {\&quot;startsWith\&quot;: [\&quot;David\&quot;]}, \&quot;firstName\&quot;: {\&quot;contains\&quot;: [\&quot;A\&quot;,\&quot;B\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;middleName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;middleName\&quot;: {\&quot;startsWith\&quot;: [\&quot;P\&quot;]}, \&quot;middleName\&quot;: {\&quot;contains\&quot;: [\&quot;N\&quot;,\&quot;E\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;lastName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;lastName\&quot;: {\&quot;startsWith\&quot;: [\&quot;Sm\&quot;]}, \&quot;lastName\&quot;: {\&quot;contains\&quot;: [\&quot;Y\&quot;,\&quot;Z\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;officeName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;officeName\&quot;: {\&quot;startsWith\&quot;: [\&quot;Chiropractic\&quot;]}, \&quot;officeName\&quot;: {\&quot;contains\&quot;:[\&quot;Center\&quot;,\&quot;P\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;certifications&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;certifications\&quot;: {\&quot;contains\&quot;: [\&quot;Radiation Oncology\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;institutionName&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;institutionName\&quot;: {\&quot;startsWith\&quot;: [\&quot;New York\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;insuranceAccepted&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;insuranceAccepted\&quot;: {\&quot;startsWith\&quot;: [\&quot;United\&quot;]}, \&quot;insuranceAccepted\&quot;:{\&quot;contains\&quot;: [\&quot;C\&quot;,\&quot;Health\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;admittingHospitals&lt;/td&gt;     &lt;td&gt;Text&lt;/td&gt;     &lt;td&gt;\&quot;admittingHospitals\&quot;: {\&quot;startsWith\&quot;: [\&quot;Children&#39;s\&quot;]}, \&quot;admittingHospitals\&quot;:{\&quot;contains\&quot;: [\&quot;Medical\&quot;,\&quot;University\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;subscriptions&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;subscriptions\&quot;: {\&quot;notIncludes\&quot;: [\&quot;123\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;facebookAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;facebookAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;foursquareAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;foursquareAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;googleplusAccounts&lt;/td&gt;     &lt;td&gt;IdList&lt;/td&gt;     &lt;td&gt;\&quot;googleplusAccounts\&quot;: {\&quot;notIncludes\&quot;: [\&quot;1111\&quot;]}&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;labels&lt;/td&gt;     &lt;td&gt;Labels&lt;/td&gt;     &lt;td&gt;\&quot;labels\&quot;: {\&quot;includes\&quot;: [1, 100]}&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt; 
  # @return [LocationsSearchResponse]
  describe 'search_locations test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for update_asset
  # Assets: Update
  # Update a specific asset.  **NOTE**: This endpoint is a true PUT. Fields that are not provided in an update will be cleared. The entire Asset object must be provided in the request, except for its **&#x60;id&#x60;**, which is given in the path.  **NOTE:** * If the **&#x60;v&#x60;** parameter is on or before &#x60;20190624&#x60;: only the first folder the Asset is available for will be returned in the legacy **&#x60;folderId&#x60;** field. * If the **&#x60;v&#x60;** parameter is after &#x60;20190624&#x60;: the complete list of folders the Asset is available to will be returned in the new **&#x60;folderIds&#x60;** field. **&#x60;folderId&#x60;** will not be returned. 
  # @param account_id 
  # @param asset_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param format The formatting langauge used to parse rich text field values. Present if and only if type of field is \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60; 
  # @param asset 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'update_asset test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for update_bio
  # Bios: Update
  # Update an existing Bios List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param bio 
  # @param [Hash] opts the optional parameters
  # @return [BioListResponse]
  describe 'update_bio test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for update_custom_field
  # Custom Fields: Update
  # Updates a single Custom Field in an Account.  Note that the only updatable values in an existing Custom Field are its name, group, description, alternate language behavior, as well as available options if its &#x60;type&#x60; is &#x60;SINGLE_OPTION&#x60; or &#x60;MULTI_OPTION&#x60;.  * If options are modified, every location with that option selected will have the new value.  * If options are deleted, all locations with that option will no longer have that option selected.  * If the deleted options are the only options selected for a location, the location will no longer have a value set for that Custom Field. 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param account_id 
  # @param custom_field_id ID that should be used when referencing the field in API calls. This ID will also serve as the Custom Field&#39;s key in our upcoming Entities API endpoints. Note that the Custom Fields can still be accessed using their numeric **&#x60;id&#x60;** by invoking the endpoints with a **&#x60;v&#x60;** param before &#x60;20180809&#x60;.  
  # @param field_update 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'update_custom_field test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for update_entity
  # Entities: Update
  # Update the Entity with the given ID
  # @param account_id 
  # @param entity_id The external ID of the requested Entity
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param entity_write Information to update on the entity
  # @param [Hash] opts the optional parameters
  # @option opts [String] :format The formatting language used to parse rich text field values. Present and **required** if an only if the request contains a field with type \&quot;**Rich Text**.\&quot;  Valid values:   * &#x60;markdown&#x60;   * &#x60;html&#x60; 
  # @option opts [Boolean] :strip_unsupported_formats Optional parameter to strip unsupported formats in rich text fields. When this parameter is included, the unsupported formats in rich text fields will be stripped and saved as plain text; otherwise if this parameter is not included, unsupported formats will return an error. 
  # @option opts [String] :template_fields Comma-separated list of top-level fields to apply from the template. If provided, only the fields specified will be applied to the entity.  Ignored if **&#x60;templateId&#x60;** is not provided. 
  # @option opts [String] :template_id The ID of the template to apply to the entity  **NOTE:** Some fields that are part of the provided template but not present in the API will be applied - e.g. Linked Accounts 
  # @return [InlineResponse201]
  describe 'update_entity test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for update_event
  # Events (Legacy): Update
  # Update an existing Event List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param event 
  # @param [Hash] opts the optional parameters
  # @return [EventListResponse]
  describe 'update_event test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for update_location
  # Locations (Legacy): Update
  # Updates the primary profile for a Location.  **NOTE:** Despite using the PUT method, Locations: Update only updates supplied fields. Omitted fields are not modified.  **NOTE:** The Location&#39;s primary profile language can be changed by calling this endpoint with a different, but unused, language code. 
  # @param account_id 
  # @param location_id 
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param location 
  # @param [Hash] opts the optional parameters
  # @return [IdResponse]
  describe 'update_location test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for update_menu
  # Menus: Update
  # Update an existing Menu.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param menu 
  # @param [Hash] opts the optional parameters
  # @return [MenuListResponse]
  describe 'update_menu test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for update_product
  # Products: Update
  # Update an existing Product List.
  # @param account_id 
  # @param list_id ID of this List.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param product 
  # @param [Hash] opts the optional parameters
  # @return [ProductListResponse]
  describe 'update_product test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for upsert_language_profile
  # Entity Language Profiles: Upsert
  # Add a language profile
  # @param account_id 
  # @param entity_id The external ID of the requested Entity
  # @param language_code The language code corresponding to the language of the profile that the user wishes to create or update
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param entity_write The entity profile to create
  # @param [Hash] opts the optional parameters
  # @return [InlineResponse201]
  describe 'upsert_language_profile test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

  # unit tests for upsert_location_language_profile
  # Language Profiles (Legacy): Upsert
  # Creates and / or sets the fields for a Language Profile  **NOTE:** You can change a Language Profile’s language by supplying a different (but unused) language code. 
  # @param account_id 
  # @param location_id 
  # @param language_code Locale code.
  # @param v A date in &#x60;YYYYMMDD&#x60; format.
  # @param location 
  # @param [Hash] opts the optional parameters
  # @option opts [Boolean] :primary When present and set to true, the specified profile will become the location’s primary Language Profile.
  # @return [EmptyResponse]
  describe 'upsert_location_language_profile test' do
    it 'should work' do
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end

end
